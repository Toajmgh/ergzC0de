{"meta":{"title":"ergzC0de","subtitle":"","description":"Java,Python,Code","author":"ergz","url":"http://www.ergzcode.com","root":"/"},"pages":[{"title":"About me","date":"2019-11-26T05:12:36.000Z","updated":"2019-12-10T01:28:48.921Z","comments":true,"path":"about/me.html","permalink":"http://www.ergzcode.com/about/me.html","excerpt":"","text":""}],"posts":[{"title":"PM2介绍","slug":"pm2-common-commands-introduction","date":"2019-12-10T03:22:00.000Z","updated":"2019-12-10T04:15:11.515Z","comments":true,"path":"2019/12/10/pm2-common-commands-introduction.html","link":"","permalink":"http://www.ergzcode.com/2019/12/10/pm2-common-commands-introduction.html","excerpt":"","text":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性： 1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 ) 安装1npm install -g pm2 #命令行安装pm2 用法123456789101112131415161718192021222324252627282930pm2 start app.js -i 4 #后台运行pm2，启动4个app.jspm2 start app.js --name my-api #命名进程pm2 list #显示所有进程状态pm2 monit #监视所有进程pm2 logs #显示所有进程日志pm2 stop all #停止所有进程pm2 restart all #重启所有进程pm2 reload all #0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0 #停止指定的进程pm2 restart 0 #重启指定的进程pm2 startup #产生 init 脚本 保持进程活着pm2 web #运行健壮的 computer API endpointpm2 delete 0 #杀死指定的进程pm2 delete all #杀死全部进程运行进程的不同方式：pm2 start app.js -i max #根据有效CPU数目启动最大进程数目pm2 start app.js -i 3 #启动3个进程pm2 start app.js -x #用fork模式启动 app.js 而不是使用 clusterpm2 start app.js -x -- -a 23 #用fork模式启动 app.js 并且传递参数 (-a 23)pm2 start app.js --name serverone #启动一个进程并把它命名为 serveronepm2 stop serverone #停止serverone进程pm2 start app.json #启动进程, 在app.json里设置选项pm2 start app.js -i max -- -a 23 #在--之后给app.js传递参数pm2 start app.js -i max -e err.log -o out.log #启动 并生成一个配置文件你也可以执行用其他语言编写的app ( fork 模式):pm2 start my-bash-script.sh -x --interpreter bashpm2 start my-python-script.py -x --interpreter pythonpm2 list #列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次pm2 monit #监视每个node进程的CPU和内存的使用情况。","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"}],"author":"ergz"},{"title":"PM2守护hexo的进程","slug":"pm2-watch-hexo-process","date":"2019-12-08T00:01:00.000Z","updated":"2019-12-10T03:35:11.383Z","comments":true,"path":"2019/12/08/pm2-watch-hexo-process.html","link":"","permalink":"http://www.ergzcode.com/2019/12/08/pm2-watch-hexo-process.html","excerpt":"","text":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2 2.写一个shell hexo_daemon.js12345678910//runconst &#123; exec &#125; = require('child_process')exec('hexo server -p 80 &amp; ',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 3.在根目录下执行shell1pm2 start hexo_daemon.js 参考:PM2使用","categories":[{"name":"shell","slug":"shell","permalink":"http://www.ergzcode.com/categories/shell/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.ergzcode.com/tags/hexo/"}],"author":"ergz"},{"title":"Git常用命令使用","slug":"git-common-commands-using","date":"2019-11-26T11:26:00.000Z","updated":"2019-12-10T05:31:40.968Z","comments":true,"path":"2019/11/26/git-common-commands-using.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-common-commands-using.html","excerpt":"","text":"1.查看工作区的状态：git status 2.查看文件具体修改了什么内容：git diff file 3.查看提交的历史记录，该命令显示从最近到最远的历史记录：git log，如果嫌输出信息太多，可以试试加上--pretty=oneline参数：git log --graph --pretty=oneline --abbrev-commit，命令如下： 123git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示 4.git reset该命令用来回退到某个版本，在git中用HEAD表示当前版本，HEAD^表示上个版本，HEAD^^表示上上版本……以此类推，HEAD~100表示往上100个版本现在我们用命令回退到上个版本： 12git reset --hard HEAD^HEAD is now at 1f2508 可以根据版本号commit id指定回退到某个版本：git reset --hard eede19这里的版本号没必要写全，前几位就可以了，Git会自动去找，这样我们就又回到最新的版本了。Git版本的回退速度非常快，在Git内部有个指向当前版本的指针HEAD，所以我们在进行版本回退或回到最新的版本的时候，Git只是帮我们将HEAD指针指向某个版本号。 5.git reflog记录你的每一条命令，可以查看commit id,提交具体的操作和提交输入的信息，命令如下： 12345root@instance-my0hsclo:/usr/local/ergzC0de# git reflog eede197 HEAD@&#123;0&#125;: rebase finished: returning to refs/heads/mastereede197 HEAD@&#123;1&#125;: pull --rebase origin master: init hexo repo1f25086 HEAD@&#123;2&#125;: pull --rebase origin master: checkout 1f2508638115730cb301f73c51b9971fca5c7f09fe14566 HEAD@&#123;3&#125;: commit (initial): init hexo repo 6.git checkout -- file丢弃工作区的修改，文件修改还没有添加到暂存区，命令如下： 1git checkout -- readme.txt 当文件修改后已经添加到了暂存区又作了修改，现在撤销修改就回到添加到暂存区后的状态。 7.git reset HEAD file把添加到暂存区的内容撤销，HEAD表示最新的版本 123root@instance-my0hsclo:/usr/local/learngit# git reset HEAD readme.txtUnstaged changes after reset:M readme.txt 8.查看分支：git branch 9.创建分支：git branch &lt;name&gt;我们创建新分支dev时，Git会新建一个指针叫dev，指向当前分支master的相同的提交点（HEAD指针指向的是当前分支），再把HEAD指向dev，之后的操作就在dev分支上完成，如图： 10.切换分支:git checkout &lt;name&gt;或者git switch &lt;name&gt;创建并切换分支git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 11.合并指定分支到当前分支上：git merge &lt;name&gt;当dev分支开发结束后，我们需要把dev分支合并到master（主分支）上，Git是如何操作的呢？Git直接把master指向dev的当前提交，就完成了合并，这些操作都是靠指针来完成，文件并没有发生变化，如图： 分支合并时，Git默认使用Fast forward模式，使用这种模式，删除分支后，会丢掉分支的历史信息，使用--no-ff可以禁用Fast forward模式 git merge --no-ff -m &quot;merge with no-ff&quot; dev，这样每次合并会创建一个新的commit，加上-m参数，写上commit的描述。 12.删除分支:git branch -d &lt;name&gt;合并完分支后就可以删除dev分支，，删除dev分支就是把dev指针给删掉，删掉后我们就剩下了一条master分支，如图： 13.查看分支合并图:git log --graph 团队协作的分支开发流程图： 参考：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}]}]}
{"meta":{"title":"ergzC0de","subtitle":"代码也是一种艺术","description":"Java,Python,编程","author":"ergz","url":"http://www.ergzcode.com","root":"/"},"pages":[{"title":"声明","date":"2019-12-25T07:44:11.000Z","updated":"2019-12-31T09:58:04.119Z","comments":true,"path":"contact/me.html","permalink":"http://www.ergzcode.com/contact/me.html","excerpt":"","text":"本站仅提供了一个技术交流的平台，没有任何商业盈利的行为。除了原创文章外，从网络上转载的文章或搜集的一些资源在文末都有出处说明，若您认为本站资源侵犯了您的版权，请联系站长删除。 邮箱：itoajm@163.com扣扣：921936477(备注说明来意)微信：wxw0220(备注说明来意)"}],"posts":[{"title":"后端架构师技术图谱","slug":"architect-awesome","date":"2020-01-05T11:03:00.000Z","updated":"2020-01-06T04:57:28.312Z","comments":true,"path":"2020/01/05/architect-awesome.html","link":"","permalink":"http://www.ergzcode.com/2020/01/05/architect-awesome.html","excerpt":"推荐: 《Java技术书籍大全》 - awesome-java-books，从初级开发者到资深架构师，看这些书就够了 原文链接：后端架构师技术图谱MD文件：http://cdn.ergzcode.com/awesome/architect-awesome.md 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》","text":"推荐: 《Java技术书籍大全》 - awesome-java-books，从初级开发者到资深架构师，看这些书就够了 原文链接：后端架构师技术图谱MD文件：http://cdn.ergzcode.com/awesome/architect-awesome.md 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树二叉树每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B，B+，B*树MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。LSM 树 LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一侧都大或小。 归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序TODO 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序按照个位、十位、百位、…依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 – 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论–最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT … FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程TODO 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程—-从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 《设计模式类图与示例》 应用场景 《细数JDK里的设计模式》 结构型模式： 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 创建模式: 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 行为模式： 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式TODO MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APMAPM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件Web ServerNginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 agentzh 的 Nginx 教程 Tengine 官方网站 Apache Httpd 官方网站 Tomcat架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 《memcached全面剖析》 Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存–序列3–原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ TODO 定时调度单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 —- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 ** SPI **TODO Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件Sharding Jdbc 官网 源码解析 日志系统日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络协议OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议)Hessian 《Hessian原理分析》Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 * 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库基础理论关系数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 文中有一处错误： 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。 《MySQL查询where条件的顺序对查询效率的影响》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQLMongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎搜索引擎原理 《倒排索引–搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据流式计算Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 《子雨大数据之Spark入门教程(Python版)》 安全web 安全XSS 《xss攻击原理与解决方法》CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 TODO 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全数据备份TODO 网络隔离内外网分离TODO 登录跳板机在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架TODO Web 框架Spring 家族Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）–网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》 轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路 1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》Java、Spring、Dubbo 优雅关闭方式。 数据库扩展读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统—幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式TODO 响应式编程ReactorTODO RxJavaTODO Vert.xTODO DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 项目管理架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUMSCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3—敏捷方法之scrum》 敏捷开发TODO 极限编程（XP）XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 是一种指导开发人员的方法论。 4大价值： 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式TODO 通用业务术语TODO 技术趋势TODO 政策、法规法律 《中华人民共和国网络安全法》 2016年11月7日发布，自2017年6月1日起施行 《个人信息保护法》 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。 《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》 《解释》共十三条，自2017年6月1日起施行 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”； 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上； 3、对于其他公民个人信息，标准为 5000条以上。 《中华人民共和国电子商务法》 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行 解读电子商务法（一）什么是电商 解读电子商务法（二）电商经营者 解读电子商务法（三）电商行为规范 解读电子商务法（四）电商的法律关系 解读电子商务法（外传）电商挣钱的秘密 解读电子商务法（外传）电商模式 程序员需要知道的法律常识 白话法律42讲-为程序员打造的专属法律武器 严格遵守刑法253法条我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 避风港原则“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。 《避风港原则》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 团队管理TODO 招聘资讯行业资讯 36kr Techweb 公众号列表TODO 博客团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm’s Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区国内： CSDN 老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 InfoQ 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: * [运维派](http://www.yunweipai.com/) * [Abcdocker](https://www.abcdocker.com/) Java: ImportNew 专注于 Java 技术分享 HowToDoInJava 英文博客 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： InfoQ 偏重于基础架构、运维方向 DockerInfo 专注于 Docker 应用及咨询、教程的网站 Linux公社 Linux 主题社区 其他类 程序员技能图谱 推荐参考书在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书更多架构方面书籍参考: awesome-java-books 开发方面 《阿里巴巴Java开发手册》详情 架构方面 《软件架构师的12项修炼：技术技能篇》详情 《架构之美》详情 《分布式服务架构》详情 《聊聊架构》 详情 《云原生应用架构实践》详情 《亿级流量网站架构核心技术》详情 《淘宝技术这十年》详情 《企业IT架构转型之道-中台战略思想与架构实战》 详情 《高可用架构（第1卷）》详情 技术管理方面 《CTO说》详情 《技术管理之巅》详情 《网易一千零一夜：互联网产品项目管理实战》详情 基础理论 《数学之美》详情 《编程珠玑》详情 工具方面TODO 大数据方面技术资源开源资源 github Apache 软件基金会 手册、文档、教程国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode DigitalOcean Vultr","categories":[{"name":"架构技术","slug":"架构技术","permalink":"http://www.ergzcode.com/categories/%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"ergz"},{"title":"最新IDEA永久激活","slug":"idea-latest-active","date":"2019-12-25T12:26:00.000Z","updated":"2019-12-29T09:27:08.686Z","comments":true,"path":"2019/12/25/idea-latest-active.html","link":"","permalink":"http://www.ergzcode.com/2019/12/25/idea-latest-active.html","excerpt":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar","text":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar -Xms512m -Xmx2048m -XX:ReservedCodeCacheSize=480m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot; -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true -javaagent:C:\\Program Files\\JetBrains\\ideaIU 2019.2.3\\bin\\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况，这时候可以删除用户配置目录下的IDEA文件夹: windwos：C:\\Users\\用户名\\ macos：~/Library/Preferences/ ubuntu：~/. 修改完配置文件之后重启IDEA 3.输入激活码重启IDEA之后，点击菜单栏中的 ‘Help ’-&gt; ‘Register…’，这里有两种激活方式： 一.选择最后一种License server激活方式，地址填入：http://jetbrains-license-server ,或者点击按钮：‘Discover Server’来自动填充地址，完成激活。 二.如果服务器激活方式无法激活，还可以选择Activation code方式激活，激活码下载:激活码.txt，下载复制激活码填入，点击OK即可。 服务器激活是没有期限的，是永久有效。激活码激活的有效期到2089年。 本文链接：最新IDEA永久激活欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.ergzcode.com/tags/IDEA/"}],"author":"ergz"},{"title":"Nginx反向代理实现二级域名与端口的映射","slug":"nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports","date":"2019-12-14T09:27:00.000Z","updated":"2019-12-29T09:26:48.202Z","comments":true,"path":"2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","link":"","permalink":"http://www.ergzcode.com/2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","excerpt":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。","text":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。 现在需要做到以下两点： 将http://www.ergzcode.com的请求转发给4000端口下的应用程序，也就是通过这种URL访问本站 将http://cdn.ergzcode.com的请求转发给8080端口下的http文件服务器 当然在这之前，有个前提就是你需要让cdn.ergzcode.com和www.ergzcode.com这两个域名解析到你的服务器IP上，DNS解析在域名提供商那里作处理,这里不再介绍 现在要做到上面的请求转发，就要用到Nginx的反向代理机制，下面来创建Nginx的配置文件，在/etc/nginx/conf.d目录下创建一个叫做reverse_proxy.conf的文件，文件名可以随意指定，但要以.conf为后缀名，然后加入下面的内容 1234567891011121314151617181920212223242526server&#123; listen 80;#监听端口 server_name www.ergzcode.com;#根据域名跳转 location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:4000;#跳转的路径 &#125;&#125;server&#123; listen 80; server_name cdn.ergzcode.com; #root /usr/local/data/file; location / &#123; # try_files $uri $uri/ =404; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080;#跳转的路径 &#125;&#125; 执行命令使修改配置生效/etc/init.d/nginx reload 访问本站：http://www.ergzcode.com访问HTTP服务器：http://cdn.ergzcode.com完成！！ 本文链接：Nginx反向代理实现二级域名与端口的映射欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"开发中常用的一些免费API","slug":"some-common-and-free-apis-for-developing","date":"2019-12-11T10:20:00.000Z","updated":"2019-12-26T15:53:59.177Z","comments":true,"path":"2019/12/11/some-common-and-free-apis-for-developing.html","link":"","permalink":"http://www.ergzcode.com/2019/12/11/some-common-and-free-apis-for-developing.html","excerpt":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址","text":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址数字识别(可在线调用):对图像中的阿拉伯数字进行识别提取，适用于…——接口地址通用文字识别(可在线调用):支持多场景下的文字检测识别，多项ICDA…——接口地址网络图片文字识别(可在线调用):能够快速准确识别各种网络图片中的文字，在…——接口地址身份证识别(可在线调用):支持对二代居民身份证正反面的关键字段识别…——接口地址银行卡识别(可在线调用):支持对主流银行卡卡号识别，并返回发卡行和…——接口地址驾驶证识别(可在线调用):支持对机动车驾驶证正页的关键字段识别，包…——接口地址行驶证识别(可在线调用):支持对机动车行驶证正页的关键字段识别，包…——接口地址手写文字识别(可在线调用):能够对手写汉字和手写数字进行识别——接口地址增值税发票识别(可在线调用):识别并结构化返回增值税发票的各个字段及其…——接口地址营业执照识别(可在线调用):支持对营业执照关键字段的识别，包括单位名…——接口地址车牌识别(可在线调用):支持对中国大陆机动车车牌的识别，包括地域…——接口地址票据识别(可在线调用):支持对增值税发票、火车票、出租车票（支持…——接口地址表格文字识别:自动识别表格线及表格内容，结构化输出表头…——接口地址通用物体和场景识别(可在线调用):支持超过10万类物体和场景识别，接口返回…——接口地址图像主体检测(可在线调用):检测图片中关键主体位置，接口支持检测单张…——接口地址品牌logo识别(可在线调用):实现2万类品牌logo识别，接口返回品牌…——接口地址植物识别(可在线调用):植物识别支持2万多种通用植物识别、近…——接口地址动物识别(可在线调用):支持数千种动物识别，接口返回名称——接口地址菜品识别(可在线调用):识别超过5万个菜品，接口返回菜品的名称、…——接口地址地标识别(可在线调用):支持识别约5万中外著名地标、景点，接口返…——接口地址车型识别(可在线调用):识别车辆的具体车型，以小汽车为主，输出图…——接口地址车辆检测:识别图像中所有机动车辆的类型和位置，并对…——接口地址GIF色情图像识别(可在线调用):人工智能鉴黄技术，智能识别图片和视频中的…——接口地址图像审核(可在线调用):通过人脸检测、文字识别、色情识别、暴恐识…——接口地址人脸检测与属性分析(可在线调用):检测图中的人脸，并为人脸标记出边框。检测…——接口地址在线活体检测(可在线调用):提供在线方式的人脸活体检测能力，在人脸识…——接口地址人体关键点识别(可在线调用):检测人体并返回人体矩形框位置，精准定位1…——接口地址人流量统计(可在线调用):统计图像中的人体个数和流动趋势，以头肩为…——接口地址人体检测与属性识别(可在线调用):检测图像中的所有人体，识别人体的20类属…——接口地址手势识别(可在线调用):识别图片中的手部位置和手势类型，可识别2…——接口地址人像分割(可在线调用):识别图像中的人体轮廓，与背景进行分离——接口地址驾驶行为分析(可在线调用):针对车载场景，识别驾驶员使用手机、抽烟、…——接口地址词法分析(可在线调用):基于大数据和用户行为的分词、词性标注、命…——接口地址词向量表示(可在线调用):词向量计算是通过训练的方法，将语言词表中…——接口地址词义相似度(可在线调用):用于计算两个给定词语的语义相似度，基于自…——接口地址依存句法分析(可在线调用):利用句子中词与词之间的依存关系来表示词语…——接口地址DNN语言模型(可在线调用):语言模型是通过计算给定词组成的句子的概率…——接口地址短文本相似度(可在线调用):短文本相似度计算服务能够提供不同短文本之…——接口地址文本纠错(可在线调用):文本纠错支持短文本、长文本、语音识别结果…——接口地址情感倾向分析(可在线调用):针对带有主观描述的中文文本，可自动判断该…——接口地址评论观点抽取(可在线调用):自动分析评论关注点和评论观点，并输出评论…——接口地址对话情绪识别(可在线调用):针对一段对话文本，自动识别出当前会话者所…——接口地址文章标签(可在线调用):文章标签服务对文章的标题和内容进行深度分…——接口地址文章分类(可在线调用):文章分类服务对文章内容进行深度分析，输出…——接口地址新闻摘要(可在线调用):基于深度语义分析模型，自动抽取新闻文本中…——接口地址通用翻译(可在线调用):支持28种语言实时互译，覆盖中、英、日、…——接口地址实体标注(可在线调用):结合上下文，识别文本中的实体并将其关联到…——接口地址新闻头条(可在线调用):最新新闻头条，各类社会、国内、国际、体育…——接口地址手机号码归属地(可在线调用):根据手机号码或手机号码的前7位，查询手机…——接口地址彩票开奖结果查询(可在线调用):目前支持双色球、大乐透、七乐彩、七星彩、…——接口地址天气预报(可在线调用):查询天气情况：温度、湿度、AQI、天气、…——接口地址二维码生成(可在线调用):按照设定的参数、生成二维码——接口地址汇率(可在线调用):外汇报价，货币汇率——接口地址历史上的今天(可在线调用):回顾历史的长河，历史是生活的一面镜子——接口地址成语词典(可在线调用):新华字典在线查字,最新最全——接口地址新华字典(可在线调用):最大最全的新华汉语词典，按拼音查、按部首…——接口地址微信精选(可在线调用):微信精选文章——接口地址笑话大全(可在线调用):搜集网络幽默、搞笑、内涵段子，不间断更新——接口地址全国WIFI(可在线调用):全国免费的WIFI热点分布——接口地址货币汇率(可在线调用):支持人民币牌价、外汇汇率查询；数据仅供参…——接口地址手机固话来电显示:查询手机/固话号码归属地，是否诈骗、营销…——接口地址简/繁/火星字体转换(可在线调用):实现简体、繁体、火星文之间的转换,转换字…——接口地址全国邮编查询(可在线调用):提供全国邮政编码大全,为你快速准确查邮编——接口地址老黄历(可在线调用):提供老黄历查询,黄历每日吉凶宜忌查询——接口地址周公解梦(可在线调用):周公解梦,周公解梦大全,周公解梦查询，免…——接口地址净值数据(可在线调用):根据基金类型及分页参数来获取数据(开放式…——接口地址星座运势(可在线调用):十二星座每日、每月、每年运势——接口地址图书电商数据(可在线调用):于万千之中选择你所爱–好书推荐，值得你…——接口地址身份证查询(可在线调用):身份证归属地信息查询——接口地址黄金数据(可在线调用):黄金品种、最新价、开盘价、最高价等信息——接口地址IP地址(可在线调用):根据查询的IP地址或者域名，查询该IP所…——接口地址笑话大全——文字(可在线调用):每小时更新。文字笑话大全，信息搜集整理于…——接口地址笑话大全——图片(可在线调用):每小时更新。图片笑话大全，信息搜集整理于…——接口地址最新新闻:新闻API接口 官方自营 会员接口…——接口地址美图大全:根据几十个种类获取图片列表，每日更新。种…——接口地址手机归属地查询:最全、最新的手机号段数据库。本地找不到的…——接口地址历史上的今天:回顾历史的长河,历史是生活的一面镜子;历…——接口地址来福岛笑话——图片:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址来福岛笑话——文字:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址全国景点查询:全国景点查询接口（来自同程网的合作数据）…——接口地址健康知识:根据养生、用药、两性等频道内容获取健康知…——接口地址猜一猜:随机返回谜语，有2.5万谜语，每日更新。…——接口地址身份证查询:可根据身份证号，查询其签发地、生日、性别…——接口地址爱飞天气插件:爱飞天气是ShowAPI官方天气接口的一…——接口地址PM2.5空气质量指数:本接口每小时更新1次。空气质量指数提供实…——接口地址全球IP地址查询:全球IP地址——接口地址域名查询:域名查询地理位置——接口地址汉字转拼音:将汉字转换为拼音和拼音首字母缩写——接口地址中文分词:中文分词接口。将长段中文切词分开。使用场…——接口地址图片验证码生成:图形|图片验证码生成，支持自定义高宽，文…——接口地址新闻、网页正文抽取:传入一个新网或网页地址，接口将返回此ur…——接口地址实时IP代理查询:代理数量并不是越多越好，可以用才是真正的…——接口地址今日油价:今日油价，可查询全国31个省的油价。每天…——接口地址QQ号码测凶吉:输入qq号码，得到此号码的算命情况，例如…——接口地址地址转换经纬度:根据城市和名称转换为相应的经纬度——接口地址经纬度转换地址:根据经纬度转换成相应地址——接口地址黄历运势:根据输入日期，查看某一天的黄历运势——接口地址十大银行实时汇率:包括工商银行、中国银行、农业银行、交通银…——接口地址汇率转换:1分钟更新1次。当前十大银行，包括工商银…——接口地址添加图片水印:传入底板图及水印图，根据位置参数，接口把…——接口地址图像裁剪:裁剪原图的部份区域——接口地址生成缩略图:根据传入的比率将原图生成缩略图——接口地址星座运势:每天1点、7点、17点更新。包含十二星座…——接口地址PDF文件正文抽取:抽取PDF文件中的文字信息——接口地址网络搜索热词排行:每2小时更新一次。根据分类查询网络最热的…——接口地址二维码识别:根据图片的Base64信息,识别图片中的…——接口地址二维码生成:生成二维码图片 图片存放在showapi…——接口地址中文文本相似度检测:通过计算向量间的夹角（余弦公式），来判断…——接口地址全国火车票查询:数据来源于12306。 包括城市列表\\列…——接口地址药品查询:药品信息——接口地址菜谱大全:本菜谱的信息来源于网络,所以本信息仅用于…——接口地址台风最新坐标轨迹:可查询当前存在威胁的台风列表，每个台风的…——接口地址网页级别查询:google的pr查询——接口地址关键词抽取:根据传入的大段文字，使用TextRank…——接口地址全国行政区划分:最新最全的全国省、市、区县、乡镇的分级查…——接口地址微信小程序查询:搜索查询已经上架的微信小程序。包括基本信…——接口地址生成文章摘要:根据传入的长篇文章，系统使用智能算法抽取…——接口地址藏头诗生成:藏头诗生成器。可输入人名生成藏头、藏尾、…——接口地址国际原油价格查询:WTI和布伦特的油价查询——接口地址水质查询:根据地点和时间查询水质——接口地址条码生成:提供EAN_8、EAN_13、CODE_…——接口地址条码识别:提供EAN_8、EAN_13、CODE_…——接口地址全国站点换乘线路查询:提供全国站点换乘线路查询——接口地址全国公交换乘查询:提供全国公交换乘查询——接口地址汽车品牌查询:收录了近200个品牌/子品牌,上万辆车型…——接口地址周公解梦:根据周公解梦全书提供相关信息——接口地址正能量新闻:社会正能量的新闻资讯，每天更新——接口地址全国酒店查询:该接口所返回的所有图片链接将在12小时内…——接口地址经典语句:根据名人，查询经典名言——接口地址商品比价:搜索商品，根据商品url搜索各大商城的历…——接口地址姓名打分:根据姓名，返回此姓名的运势得分——接口地址公司名测吉凶:根据公司名，返回此公司的运势得分——接口地址车牌号测吉凶:根据车牌名，返回此车牌号的运势得分——接口地址手机号测吉凶:根据手机号码，返回此号码的运势得分——接口地址图书ISBN查询:通过国际图书号查询图书相关信息，目前只支…——接口地址影讯查询:影讯查询——接口地址手机套餐售价:全国手机流量充值，4G流量，当月有效——接口地址紫微斗数:根据出生时间定紫薇斗数命盘，供命理研究，…——接口地址唐诗宋词元曲等诗词查询:根据朝代Id或诗人名称查询诗人信息——接口地址脑筋急转弯:查询常见的脑筋急转弯金句——接口地址虚拟数字币|比特币行情:查询主流虚拟货币实时行情，例如btc(比…——接口地址全国房产信息:搜索最新楼盘开盘信息、最新市场房价信息——接口地址手游排行榜:手游最热排行榜及最期待榜——接口地址网游排行榜:网游最热排行榜及最期待榜——接口地址黄金行情:上金所黄金行情——接口地址电商淘宝平台联想词:提供淘宝联想词查询——接口地址中文反义词:中文反义词——接口地址中文近义词:中文近义词——接口地址歇后语查询:查询歇后语列表——接口地址中国互联网络信息:中国互联网络信息——接口地址实时票房排行:实时票房中国（包括香港）、北美、全球票房…——接口地址爱奇艺热点趋势:爱奇艺视频指数——接口地址空气质量指数(可在线调用):空气质量指数提供实时空气质量情况，目前支…——接口地址IP地址查询(可在线调用):提供rest风格的IP地址查询接口，只需…——接口地址天气预报(可在线调用):全国天气预报，预报7天天气，以及当天的生…——接口地址人脸识别(可在线调用):检测图片(Image)中的人脸(Face…——接口地址指纹识别:检测图片(Image)中的指纹(Fing…——接口地址医疗科室(可在线调用):医药健康接口专用的医疗科室字典项获取——接口地址健康菜谱(可在线调用):健康菜谱，让人们在宣泄的都市中体验在家常…——接口地址疾病信息(可在线调用):通过名称取得疾病详情——接口地址药品查询(可在线调用):通过药品名字直接得到药品说明书、价格、生…——接口地址食疗大全(可在线调用):通过名称取得食品详情只要是食品都有它…——接口地址手术项目(可在线调用):通过名称取得手术详情通过名称取得手术…——接口地址药房药店(可在线调用):通过名称取得药店信息通过名称取得药店…——接口地址病状信息(可在线调用):通过名称取得病状详情——接口地址微信精选(可在线调用):微信热门精选文章，实时更新——接口地址国内新闻(可在线调用):国内新闻数据，实时更新——接口地址国际新闻(可在线调用):国际新闻数据，实时更新——接口地址体育新闻(可在线调用):体育新闻数据，实时更新——接口地址科技新闻(可在线调用):科技新闻数据，实时更新——接口地址奇闻轶事(可在线调用):奇闻轶事数据，实时更新——接口地址旅游新闻(可在线调用):旅游热点数据，实时更新——接口地址新华字典(可在线调用):新华字典数据库，可查字的拼音、读音、偏旁…——接口地址五笔字根(可在线调用):查询汉字的五笔字根——接口地址简繁体火星文转换(可在线调用):汉字的简体、繁体、火星文转换——接口地址成语词典(可在线调用):成语查询——接口地址歇后语(可在线调用):歇后语查询，根据关键字搜索歇后语——接口地址唐诗宋词(可在线调用):根据关键字搜索唐诗宋词——接口地址历史上的今天(可在线调用):以史为镜，可以知兴替。借历史上的成败得失…——接口地址辞海(可在线调用):查询词语解释——接口地址手机号码归属地(可在线调用):通过手机号码查询归属地、运营商、号码类型…——接口地址笑话大全(可在线调用):海量互联网幽默、内涵段子、趣味图片，不间…——接口地址同义词:通过输入的词语查询对应的同义词——接口地址全国WIFI(可在线调用):查询周边免费WIFI热点；全国免费WIF…——接口地址NBA赛事(可在线调用):NBA赛事赛程信息，球队赛程赛事查询——接口地址全国邮编查询(可在线调用):通过地名查询地区邮编，精确到街道——接口地址周公解梦(可在线调用):周公解梦大全——接口地址名人名言(可在线调用):通过关键字查询名人名言——接口地址今日油价(可在线调用):可查询全国31个省的油价——接口地址国际白银实时价格:国际交易市场白银实时价格(美元/盎司)，…——接口地址时事新闻检索(可在线调用):时事新闻，新闻检索等，实时更新——接口地址号码吉凶(可在线调用):手机号码、QQ号码、车牌号等所有数字类型…——接口地址金额小写转大写(可在线调用):人民币金额小写转大写——接口地址电影票房(可在线调用):最新票房榜，网票票房——接口地址全国长途汽车(可在线调用):全国长途汽车时刻表查询——接口地址足球联赛(可在线调用):目前支持 英超，西甲，德甲，意甲，法甲，…——接口地址影视影讯(可在线调用):影视信息播放链接检索，城市影讯检索——接口地址标准电码查询(可在线调用):提供的标准中文电码查询程序结果——接口地址火车时刻表(可在线调用):火车时刻表，站到站检索——接口地址姓氏起源(可在线调用):《百家姓》是我国汉族姓氏总集，载有四百多…——接口地址短链接生成(可在线调用):查找网提供长的网址链接缩短为新浪短网扯，…——接口地址翻译(可在线调用):翻译API提供免费开放接口，覆盖中、英、…——接口地址乌云漏洞(可在线调用):查看乌云最新的安全漏洞——接口地址微信公众号查询(可在线调用):根据关键字搜索热门微信文章、微信公众号等…——接口地址在线分词(可在线调用):基于深度学习的中文在线抽词——接口地址MD5破解(可在线调用):md5密文：16位，32位,sha1(4…——接口地址星座配对(可在线调用):星座配对测姻缘——接口地址生肖配对(可在线调用):生肖配对测姻缘——接口地址获取外网IP信息(可在线调用):取得客户端访问互联网时的外网ip及对应的…——接口地址百度权重(可在线调用):根据网址查询百度权重——接口地址新闻头条(可在线调用):最新新闻头条——接口地址星座运势(可在线调用):黄道十二星座每日、每月、每年运势、不间断…——接口地址 2019.7.3更新接口 实时段子(可在线调用):实时段子,神评版本——接口地址音乐搜索(可在线调用):根据音乐名称返回音乐详情——接口地址小说查询(可在线调用):获取小说的详细信息——接口地址天气查询(可在线调用):获取最近天气情况——接口地址音悦tai搜索:音悦Tai-是以高清MV为主的娱乐视频网…——接口地址识别身份证文字(可在线调用):AI人工智能识别身份证图像文字 URL图…——接口地址编码解码:常见的编码和解码——接口地址网站备案查询:网站备案信息查询接口——接口地址身份证信息查询(可在线调用):身份证信息查询(不支持查询百岁老人)——接口地址图片PS:在线图片加文字,返回为字符串,需要处理下——接口地址一言:随机返回一句话——接口地址短链接生成与还原:短链接生成与还原，包括新浪、腾讯、百度——接口地址获取用户大致信息:获取用户信息如网络运营商等等——接口地址三合一收款码:包括支付宝，qq，微信——接口地址IP查询:根据ip地址获取其所在省市区——接口地址IP经纬度查询:根据ip地址和经纬度获取其所在省市区——接口地址 2019.8.7更新接口 淘宝ip(可在线调用):来自淘宝的ip查询，可以根据ip地址查询…——接口地址360ip(可在线调用):来自360的ip查询，可以根据ip地址查…——接口地址地理编码(可在线调用):将详细的结构化地址转换为高德经纬度坐标。…——接口地址逆地理编码(可在线调用):将经纬度转换为详细结构化的地址，且返回附…——接口地址步行路径规划:可以规划100KM以内的步行通勤方案，并…——接口地址驾车路径规划(可在线调用):规划以小客车、轿车通勤出行的方案，并且返…——接口地址公交路径规划:规划综合各类公共（火车、公交、地铁）交通…——接口地址骑行路径规划(可在线调用):用于规划骑行通勤方案，规划时不会考虑路况…——接口地址距离测量:根据经纬度测量距离——接口地址行政区域查询(可在线调用):根据用户输入的搜索条件可以帮助用户快速的…——接口地址矩形区域交通态势:能够确定矩形交通态势情况，路况信息2分钟…——接口地址圆形区域交通态势:能够确定圆形交通态势情况，路况信息2分钟…——接口地址指定线路交通态势:能够确定指定线路交通情况，路况信息2分钟…——接口地址输入提示(可在线调用):提供根据用户输入的关键词查询返回建议列表——接口地址天气查询(可在线调用):查询目标区域当前/未来的天气情况——接口地址IP定位(可在线调用):将IP信息转换为地理位置信息——接口地址地点范围查询(可在线调用):根据经纬度查询查询其地址相关信息——接口地址 2019.9.9更新接口 行政区划区域检索(可在线调用):开发者可通过该功能，检索某一行政区划内（…——接口地址圆形区域检索(可在线调用):开发者可设置圆心和半径，检索圆形区域内的…——接口地址矩形区域检索(可在线调用):开发者可设置检索区域左下角和右上角坐标，…——接口地址地点详情检索(可在线调用):地点详情检索针对指定POI，检索其相关的…——接口地址地点输入提示(可在线调用):用户可通过该服务，匹配用户输入关键词的地…——接口地址地理编码服务(可在线调用):用户可通过该功能，将结构化地址（省/市/…——接口地址全球逆地理编码(可在线调用):用户可通过该功能，将位置坐标解析成对应的…——接口地址公交路线规划(可在线调用):根据起点和终点检索符合条件的公共交通方案…——接口地址骑行路线规划(可在线调用):根据起终点坐标检索符合条件的骑行路线规划…——接口地址驾车路线规划(可在线调用):根据起终点坐标检索符合条件的驾车路线规划…——接口地址批量算路:用户可通过该服务，根据起点和终点坐标计算…——接口地址普通IP定位(可在线调用):用户可以通过该服务，根据IP定位来获取大…——接口地址道路实时路况查询(可在线调用):查询具体道路的实时拥堵评价和拥堵路段、拥…——接口地址时间偏移查询(可在线调用):查询坐标所在地与协调世界时的时间偏移信息…——接口地址周边上车点推荐(可在线调用):用户可通过该功能检索坐标点周围的上车点。…——接口地址非百度坐标系转换(可在线调用):用户可通过该服务，实现 非百度坐标系→百…——接口地址快递查询(可在线调用):可根据快递单号查询大部分主流快递的快递信…——接口地址文件转换:文件转换成指定格式，成功则返回成功转换的…——接口地址获取文件转换内容:根据文件转换成功所获取的id，查询转换成…——接口地址 2019.10.8更新接口 全球IP地理位置(可在线调用):单个IPv4 / IPv6地址或域名…——接口地址域名备案(可在线调用):根据域名查询域名备案状态——接口地址十五天天气预报:采用城市ID来精准查询15天内的天气，接…——接口地址农历查询(可在线调用):根据日期获取农历、黄历、禁忌、星期、生肖…——接口地址ICP备案查询(可在线调用):根据域名查询ICP备案号——接口地址三合一收款二维码:将QQ、微信、支付宝收款集合到一起，省去…——接口地址二维码生成:将网址直接转换成二维码图片——接口地址二维码解码(可在线调用):将二维码图片进行解码，解析处理——接口地址短网址生成(可在线调用):将长网址进行缩短，支持百度、新浪、腾讯短…——接口地址短网址还原(可在线调用):将缩短的短网址进行还原,支持常见的短网址——接口地址网易云音乐随机歌曲(可在线调用):网易云音乐，随机歌曲输出——接口地址获取访客相关信息(可在线调用):根据访客IP地址，操作系统，浏览器，访问…——接口地址随机头像输出(可在线调用):随机头像输出——接口地址 2019.11.5更新接口 文章短篇:根据日期获取一篇文章，有网上的，也有名家…——接口地址必应故事:随机获取来自必应的故事，可根据pid获取…——接口地址每日一言:获取来自一言、有道或金山词霸的每日一言内…——接口地址二维码解析:还原二维码的原始URL，支持支付宝，微信…——接口地址生成海报:根据提交的内容格式化生成可分享的精美海报——接口地址历史上的今天:历史上的今天——接口地址生成二维码:可根据传入的内容，生成对应的二维码，还可…——接口地址IP地址详情信息:IP地址详情信息查询——接口地址XLS生成:生成XLS——接口地址土味情话:和妹妹说的情话，返回一句随机的内容——接口地址随机笑话(可在线调用):随机的笑话——接口地址 2019.12.4更新接口 经纬度信息(可在线调用):获取当前经纬度信息——接口地址历史上的今天(可在线调用):历史上的今天——接口地址Bing 壁纸获取(可在线调用):获取最近的Bing 壁纸——接口地址天气查询(可在线调用):获取今天和未来三天的天气情况，来源于高德——接口地址天气查询(可在线调用):根据城市名，获取今天和未来三天的天气情况…——接口地址天气查询(可在线调用):根据城市id，获取未来15天的天气情况，…——接口地址手机归属地查询(可在线调用):根据手机号码查询手机号的归属地信息——接口地址手机归属地查询:根据手机号码查询手机号的归属地信息，来源…——接口地址IP域名归属地查询(可在线调用):查询IP或者域名归属地——接口地址身份证查询(可在线调用):根据身份证获取该身份证号码的籍贯，出生年…——接口地址淘宝关键字(可在线调用):淘宝搜索关键字——接口地址百度关键字:百度搜索关键字——接口地址Bing关键字(可在线调用):Bing搜索关键字——接口地址获取用户设备信息(可在线调用):通过 user-agent 分析用户设备…——接口地址百度音乐搜索(可在线调用):根据关键字获取音乐的相关信息——接口地址 努力添加中…… 原文链接：https://github.com/fangzesheng/free-api欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"API","slug":"API","permalink":"http://www.ergzcode.com/tags/API/"}],"author":"ergz"},{"title":"PM2介绍","slug":"pm2-common-commands-introduction","date":"2019-12-10T03:22:00.000Z","updated":"2019-12-29T09:26:24.318Z","comments":true,"path":"2019/12/10/pm2-common-commands-introduction.html","link":"","permalink":"http://www.ergzcode.com/2019/12/10/pm2-common-commands-introduction.html","excerpt":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 )","text":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 ) 安装1npm install -g pm2 #命令行安装pm2 用法123456789101112131415161718192021222324252627282930pm2 start app.js -i 4 #后台运行pm2，启动4个app.jspm2 start app.js --name my-api #命名进程pm2 list #显示所有进程状态pm2 monit #监视所有进程pm2 logs #显示所有进程日志pm2 stop all #停止所有进程pm2 restart all #重启所有进程pm2 reload all #0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0 #停止指定的进程pm2 restart 0 #重启指定的进程pm2 startup #产生 init 脚本 保持进程活着pm2 web #运行健壮的 computer API endpointpm2 delete 0 #杀死指定的进程pm2 delete all #杀死全部进程运行进程的不同方式：pm2 start app.js -i max #根据有效CPU数目启动最大进程数目pm2 start app.js -i 3 #启动3个进程pm2 start app.js -x #用fork模式启动 app.js 而不是使用 clusterpm2 start app.js -x -- -a 23 #用fork模式启动 app.js 并且传递参数 (-a 23)pm2 start app.js --name serverone #启动一个进程并把它命名为 serveronepm2 stop serverone #停止serverone进程pm2 start app.json #启动进程, 在app.json里设置选项pm2 start app.js -i max -- -a 23 #在--之后给app.js传递参数pm2 start app.js -i max -e err.log -o out.log #启动 并生成一个配置文件你也可以执行用其他语言编写的app ( fork 模式):pm2 start my-bash-script.sh -x --interpreter bashpm2 start my-python-script.py -x --interpreter pythonpm2 list #列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次pm2 monit #监视每个node进程的CPU和内存的使用情况。 本文链接：PM2介绍欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"}],"author":"ergz"},{"title":"PM2守护hexo的进程","slug":"pm2-watch-hexo-process","date":"2019-12-08T00:01:00.000Z","updated":"2019-12-29T09:26:10.070Z","comments":true,"path":"2019/12/08/pm2-watch-hexo-process.html","link":"","permalink":"http://www.ergzcode.com/2019/12/08/pm2-watch-hexo-process.html","excerpt":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2","text":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2 2.写一个shell hexo_daemon.js12345678910//runconst &#123; exec &#125; = require('child_process')exec('hexo server -p 80 &amp; ',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 3.在根目录下执行shell1pm2 start hexo_daemon.js 本文链接：PM2守护hexo的进程欢迎转载，请注明出处！参考:PM2使用","categories":[{"name":"shell","slug":"shell","permalink":"http://www.ergzcode.com/categories/shell/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.ergzcode.com/tags/hexo/"}],"author":"ergz"},{"title":"Git常用命令使用","slug":"git-orders_02","date":"2019-11-26T14:26:00.000Z","updated":"2019-12-31T08:56:23.134Z","comments":true,"path":"2019/11/26/git-orders_02.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-orders_02.html","excerpt":"1.查看工作区的状态$ git status 2.查看文件具体修改了什么内容$ git diff &lt;file&gt; 3.查看提交的历史记录该命令显示从最近到最远的历史记录：$ git log。如果嫌输出信息太多，可以试试加上--pretty=oneline参数：$ git log --graph --pretty=oneline --abbrev-commit，命令如下： 123$ git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示","text":"1.查看工作区的状态$ git status 2.查看文件具体修改了什么内容$ git diff &lt;file&gt; 3.查看提交的历史记录该命令显示从最近到最远的历史记录：$ git log。如果嫌输出信息太多，可以试试加上--pretty=oneline参数：$ git log --graph --pretty=oneline --abbrev-commit，命令如下： 123$ git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示 4.回退版本$ git reset在git中用HEAD表示当前版本，HEAD^表示上个版本，HEAD^^表示上上版本……以此类推，HEAD~100表示往上100个版本现在我们用命令回退到上个版本： 12$ git reset --hard HEAD^HEAD is now at 1f2508 可以根据版本号commit id指定回退到某个版本：$ git reset --hard eede19这里的版本号没必要写全，前几位就可以了，Git会自动去找，这样我们就又回到最新的版本了。Git版本的回退速度非常快，在Git内部有个指向当前版本的指针HEAD，所以我们在进行版本回退或回到最新的版本的时候，Git只是帮我们将HEAD指针指向某个版本号。 5.记录你的每一条命令$ git reflog可以查看commit id,提交具体的操作和提交输入的信息，命令如下： 12345$ git reflog eede197 HEAD@&#123;0&#125;: rebase finished: returning to refs/heads/mastereede197 HEAD@&#123;1&#125;: pull --rebase origin master: init hexo repo1f25086 HEAD@&#123;2&#125;: pull --rebase origin master: checkout 1f2508638115730cb301f73c51b9971fca5c7f09fe14566 HEAD@&#123;3&#125;: commit (initial): init hexo repo 6.丢弃工作区的修改$ git checkout -- &lt;file&gt;文件修改还没有添加到暂存区，命令如下： 1$ git checkout -- readme.txt 当文件修改后已经添加到了暂存区又作了修改，现在撤销修改就回到添加到暂存区后的状态。 7.把添加到暂存区的内容撤销$ git reset HEAD &lt;file&gt; HEAD表示当前分支的最新提交 8.分支 查看分支：$ git branch 创建分支：$ git branch &lt;name&gt;。我们创建新分支dev时，Git会新建一个指针叫dev，指向当前分支master的相同的提交点（HEAD指针指向的是当前分支），再把HEAD指向dev，之后的操作就在dev分支上完成，如图： 切换分支：$ git checkout &lt;name&gt; OR $ git switch &lt;name&gt; 创建并切换分支：$ git checkout -b &lt;name&gt; OR $ git switch -c &lt;name&gt; 合并分支到当前分支:$ git merge &lt;name&gt;。当dev分支开发结束后，我们需要把dev分支合并到master（主分支）上，Git是如何操作的呢？Git直接把master指向dev的当前提交，就完成了合并，这些操作都是靠指针来完成，文件并没有发生变化，如图：分支合并时，Git默认使用Fast forward模式，使用这种模式，删除分支后，会丢掉分支的历史信息，使用--no-ff可以禁用Fast forward模式 $ git merge --no-ff -m &quot;merge with no-ff&quot; dev，这样每次合并会创建一个新的commit，加上-m参数，写上commit的描述。 删除分支：$ git branch -d &lt;name&gt;。合并完分支后就可以删除dev分支，删除dev分支就是把dev指针给删掉，删掉后我们就剩下了一条master分支，如图： 12.查看分支合并图：$ git log --graph 9.标签 新建一个标签，默认为HEAD,也可以指定一个commit id:$ git tag &lt;tagname&gt; &lt;commit&gt;,不指定commit id时，默认标签是打在最新提交的commit上 创建带有说明的标签，用-a指定标签名，-m指定说明文字:$ git tag -a &lt;tagname&gt; -m &quot;tag message&quot; &lt;commit&gt; 查看所有标签：$ git tag 删除指定标签：$ git tag -d &lt;tagname&gt; 推送某个标签到远程：$ git push &lt;remote&gt; &lt;tagname&gt; 一次性推送全部尚未推送到远程的本地标签:$ git push &lt;remote&gt; --tags 删除远程标签,先从本地删除:$ git tag -d &lt;tagname&gt; ，然后 $ git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 10.cherry-pick从不同的分支里选择某次提交并且把它合并到当前的分支。首先切换到我想要放入该提交的分支，然后执行如下命令：$ git cherry-pick [commit_hash] 团队协作的分支开发流程图，如图： 本文链接：Git常用命令使用欢迎转载，请注明出处！参考：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}]},{"title":"工作中99%能用到的Git命令","slug":"git-orders_01","date":"2019-11-26T13:58:00.000Z","updated":"2019-12-31T09:19:03.086Z","comments":true,"path":"2019/11/26/git-orders_01.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-orders_01.html","excerpt":"分支操作： git branch 创建分支 git branch -b 创建并切换到新建的分支上 git checkout 切换分支 git branch 查看分支列表 git branch -v 查看所有分支的最后一次操作 git branch -vv 查看当前分支 git brabch -b 分支名 origin/分支名 创建远程分支到本地 git branch –merged 查看别的分支和当前分支合并过的分支 git branch –no-merged 查看未与当前分支合并的分支 git branch -d 分支名 删除本地分支 git branch -D 分支名 强行删除分支 git branch origin 分支名 删除远处仓库分支(不可用) git push origin :分支名 删除远处仓库分支（可用），冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支 git merge 分支名 合并分支到当前分支上","text":"分支操作： git branch 创建分支 git branch -b 创建并切换到新建的分支上 git checkout 切换分支 git branch 查看分支列表 git branch -v 查看所有分支的最后一次操作 git branch -vv 查看当前分支 git brabch -b 分支名 origin/分支名 创建远程分支到本地 git branch –merged 查看别的分支和当前分支合并过的分支 git branch –no-merged 查看未与当前分支合并的分支 git branch -d 分支名 删除本地分支 git branch -D 分支名 强行删除分支 git branch origin 分支名 删除远处仓库分支(不可用) git push origin :分支名 删除远处仓库分支（可用），冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支 git merge 分支名 合并分支到当前分支上 暂存操作： git stash 暂存当前修改 git stash apply 恢复最近的一次暂存 git stash pop 恢复暂存并删除暂存记录 git stash list 查看暂存列表 git stash drop 暂存名(例：stash@{0}) 移除某次暂存 git stash clear 清除暂存 回退操作： git reset –hard HEAD^ 回退到上一个版本 git reset –hard ahdhs1(commit_id) 回退到某个版本 git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态) git reset HEAD file 撤回暂存区的文件修改到工作区 标签操作： git tag 标签名 添加标签(默认对当前版本) git tag 标签名 commit_id 对某一提交记录打标签 git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注 git tag 列出所有标签列表 git show 标签名 查看标签信息 git tag -d 标签名 删除本地标签 git push origin 标签名 推送标签到远程仓库 git push origin –tags 推送所有标签到远程仓库 git push origin :refs/tags/标签名 从远程仓库中删除标签 常规操作： git push origin test 推送本地分支到远程仓库 git rm -r –cached 文件/文件夹名字 取消文件被版本控制 git reflog 获取执行过的命令 git log –graph 查看分支合并图 git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录 git check-ignore -v 文件名 查看忽略规则 git add -f 文件名 强制将文件提交 git创建项目仓库： git init 初始化 git remote add origin url 关联远程仓库 git pull git fetch 获取远程仓库中所有的分支到本地 忽略已加入到版本库中的文件： git update-index –assume-unchanged file 忽略单个文件 git rm -r –cached 文件/文件夹名字 (. 忽略全部文件) 取消忽略文件： git update-index –no-assume-unchanged file 拉取、上传免密码： git config –global credential.helper store 原文链接：https://www.cxiansheng.cn/daily/490欢迎转载，请注明出处！","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}],"author":"ergz"},{"title":"GIT命令清单","slug":"git-cheat-sheet","date":"2019-11-24T17:20:00.000Z","updated":"2019-12-30T06:57:37.642Z","comments":true,"path":"2019/11/25/git-cheat-sheet.html","link":"","permalink":"http://www.ergzcode.com/2019/11/25/git-cheat-sheet.html","excerpt":"文档来源于Tower&gt;Git版本控制系统-使一切变的简单 英文原版下载地址：http://cdn.ergzcode.com/git/git-cheatsheet.pdf 由ergzC0de翻译，如有错误之处，欢迎留言指正 1.创建库克隆一个现有版本库 $ git clone ssh://user@domain.com/repo.git","text":"文档来源于Tower&gt;Git版本控制系统-使一切变的简单 英文原版下载地址：http://cdn.ergzcode.com/git/git-cheatsheet.pdf 由ergzC0de翻译，如有错误之处，欢迎留言指正 1.创建库克隆一个现有版本库 $ git clone ssh://user@domain.com/repo.git 创建一个本地版本库 $ git init 2.本地更改查看工作区的状态 $ git status 查看被跟踪的文件更改了什么内容 $ git diff &lt;file&gt;添加所有的文件修改到暂存区 $ git add . 指定某个文件添加到暂存区，-p参数可省略 $ git add -p &lt;file&gt; 提交跟踪文件中的所有本地更改，建议一般不使用-a参数 $ git commit -a将暂存区里的更改给提交到本地版本库，-m参数指定提交信息 $ git commit -m &quot;message&quot;更改最后一次提交,不修改已发布的提交,也就是追加提交，不会增加新的commit id将新的修改追加到前一次的commit id中 $ git commit --amend3.提交历史显示提交的日志 $ git log某个文件的提交日志 $ git log -p &lt;file&gt;何人何时修改的某个文件日志 $ git blame &lt;file&gt;4.分支和标签列出所有的分支 $ git branch -av 切换当前分支 $ git checkout &lt;branch&gt;创建新分支 $ git branch &lt;new-branch&gt;基于远程分支创建一个新的跟踪分支 $ git checkout --track &lt;remote/branch&gt;删除一个分支 $ git branch -d &lt;branch&gt;给当前提交贴一个标签，常用于发布版本 $ git tag &lt;tag-name&gt;5.更新和发布列出所有当前配置的远程地址 $ git remote -v显示某个远程地址的信息 $ git remote show &lt;remote&gt;关联一个远程库，一般别名用origin $ git remote add &lt;shortname&gt; &lt;url&gt;从远程库下载所有的更改，但不合并到当前分支上 $ git fetch &lt;remote&gt;从远程库下载所有的更改并直接合并到当前分支上 $ git pull &lt;remote&gt; &lt;branch&gt;推送本地修改到远程库 $ git push &lt;remote&gt; &lt;branch&gt;删除远程库的分支 $ git branch -dr &lt;remote/branch&gt;推送标签 $ git push --tags6.分支和重定合并指定分支到当前分支上 $ git merge &lt;branch&gt;将最新的分支提交到本地 $ git rebase &lt;branch&gt;中止一个rebase $ git rebase --abort解决冲突后继续重新执行rebase $ git rebase --continue使用您配置的合并工具来解决冲突 $ git mergetool使用您的编辑器手动解决冲突和(解决后)标记文件作为解决 $ git add &lt;resolved-file&gt; $ git rm &lt;resolved-file&gt;7.撤销（回退）撤销工作区的所有本地更改 $ git reset --hard HEAD丢弃工作区的修改，文件修改还没有添加到暂存区,推荐第2种 $ git checkout HEAD &lt;file&gt; or $ git checkout -- &lt;file&gt;还原提交(通过产生具有相反更改的新提交) $ git revert &lt;commit&gt;回退到某个版本 //回退到上个版本 $ git reset --hard HEAD^ //根据指定commit id回退版本 $ git reset --hard &lt;commit&gt;保存未添加暂存区的所有更改 $ git reset &lt;commit&gt;保存未提交的本地更改 $ git reset --keep &lt;commit&gt;把添加到暂存区的内容撤销（补充） $ git reset HEAD &lt;file&gt;本文链接：GIT命令清单欢迎转载，请注明出处！","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}],"author":"ergz"},{"title":"Nginx搭建HTTP文件服务器","slug":"nginx-build-http-file-system","date":"2019-11-14T08:04:00.000Z","updated":"2019-12-29T09:25:33.242Z","comments":true,"path":"2019/11/14/nginx-build-http-file-system.html","link":"","permalink":"http://www.ergzcode.com/2019/11/14/nginx-build-http-file-system.html","excerpt":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署","text":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署 使用1.检查Nignx是否安装使用以下命令检查Nginx服务器状态： 1systemctl status nginx 2.安装Nginx(ubuntu)命令： 1sudo apt-get install nginx Ubuntu安装之后的文件结构大致为： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 程序文件/usr/sbin/nginx 日志在/var/log/nginx目录中 启动脚本nginx在/etc/init.d/下 默认的虚拟主机的目录设置在了/var/www/nginx-default (有的版本默认的虚拟主机的目录设置在了/var/www, 请参考/etc/nginx/sites-available里的配置) 在/etc/nginx目录下，nginx.conf是Nginx的核心配置文件，可以修改处理器数量、日志路径、pid文件等。在nginx.conf文件中有一段代码：inxclude /etc/nginx/conf.d/*.conf,这表示可以将自己的配置文件放在conf.d/中，Nginx会自动识别这个配置文件 3.修改配置文件vim /etc/nginx/sites-available/default 12345678910111213141516server &#123; listen 8080 default_server; listen [::]:8080 default_server; #root /usr/share/nginx/html; root /usr/local/data/file; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; autoindex on;#显示目录 autoindex_exact_size on;#显示文件大小 autoindex_localtime on;#显示文件时间 charset utf-8; &#125;&#125; 4.启动nginx1/etc/init.d/nginx start 5.浏览器访问浏览器打开：http://localhost:8080可以看到/data/file目录下的文件，点击可下载 6.修改配置后重载1/etc/init.d/nginx reload 本文链接：Nginx搭建HTTP文件服务器欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"图解SQL的各种join用法","slug":"diagrams-for-various-join-uses-of-sql","date":"2019-11-09T07:50:00.000Z","updated":"2019-12-26T15:53:59.177Z","comments":true,"path":"2019/11/09/diagrams-for-various-join-uses-of-sql.html","link":"","permalink":"http://www.ergzcode.com/2019/11/09/diagrams-for-various-join-uses-of-sql.html","excerpt":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法","text":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法 具体分解如下：1.INNER JOIN（内连接） 1234SELECT &lt;select_list&gt; FROM Table_A AINNER JOIN Table_B BON A.Key = B.Key 2.LEFT JOIN（左连接） 1234SELECT &lt;select_list&gt;FROM Table_A ALEFT JOIN Table_B BON A.Key = B.Key 3.RIGHT JOIN（右连接） 1234SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.Key 4.OUTER JOIN（外连接） 1234SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.Key 5.LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接） 12345SELECT &lt;select_list&gt; FROM Table_A ALEFT JOIN Table_B BON A.Key = B.KeyWHERE B.Key IS NULL 6.RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL 7.OUTER JOIN EXCLUDING INNER JOIN（外连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL OR B.Key IS NULL 原文链接：看一张图秒懂SQL的各种JOIN用法欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://www.ergzcode.com/tags/sql/"}],"author":"ergz"},{"title":"IDEA常用快捷键","slug":"idea-keyboard-shortcuts_01","date":"2019-06-08T10:27:00.000Z","updated":"2019-12-31T10:37:02.124Z","comments":true,"path":"2019/06/08/idea-keyboard-shortcuts_01.html","link":"","permalink":"http://www.ergzcode.com/2019/06/08/idea-keyboard-shortcuts_01.html","excerpt":"快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标的下一行 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按一次取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按一次取消注释 Alt+Ins 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 移动当前代码行 Shift+F6 鼠标选中全局修改名称","text":"快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标的下一行 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按一次取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按一次取消注释 Alt+Ins 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 移动当前代码行 Shift+F6 鼠标选中全局修改名称 更新… 本文链接：IDEA常用快捷键欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.ergzcode.com/tags/IDEA/"}],"author":"ergz"},{"title":"面试官：Maven的jar包冲突如何解决","slug":"java-interview_0029","date":"2019-01-31T08:58:00.000Z","updated":"2020-01-04T09:04:45.169Z","comments":true,"path":"2019/01/31/java-interview_0029.html","link":"","permalink":"http://www.ergzcode.com/2019/01/31/java-interview_0029.html","excerpt":"介绍本文主要介绍了解决Maven中jar包冲突的几种方式 依赖传递假设我们现在又一个多模块的项目，依赖关系如下，我们在st-web模块中引入st-dal依赖时，st-common-lib这个依赖也会被我们引入，这个就是依赖传递。下表列出了scope在依赖过程中发生的变化，列标题为被依赖的模块，每行为要依赖的模块","text":"介绍本文主要介绍了解决Maven中jar包冲突的几种方式 依赖传递假设我们现在又一个多模块的项目，依赖关系如下，我们在st-web模块中引入st-dal依赖时，st-common-lib这个依赖也会被我们引入，这个就是依赖传递。下表列出了scope在依赖过程中发生的变化，列标题为被依赖的模块，每行为要依赖的模块 st-common-lib &lt;- st-dal &lt;- st-web [scope] compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime 依赖仲裁依赖仲裁就是当项目中引入的jar包，groupID（公司名倒过来）和artifactID（功能命令）一样，但是version不一样，应该选用哪一个version？经常也被人叫做依赖冲突 最短路径原则 假如说我们现在的项目依赖关系如下，那么maven会选用st-common-lib的那个版本呢？ 答案是1.1这个版本，st-web到st-common-lib（1.1）的距离为1，st-web到st-common-lib（1.0）的距离为2，选用距离短的，即最短路径原则 st-common-lib(1.0) &lt;- st-dal &lt;- st-web -&gt; st-common-lib(1.1) 如何看出依赖的距离关系呢？之前的一篇关于maven的文章说过，执行如下命令打印出全局的依赖树，层级关系特别清楚mvn dependency：tree &gt; show.txt 声明优先原则 项目依赖如下，路径一样？会选用st-common-lib的哪个版本呢？这就得看你在pom文件中先声明哪个依赖，如果在pom.xml文件中，st-remote-invoke写在前面，就会用1.0这个版本，如果st-dal写在前面，则会用1.1这个版本 st-common-lib（1.0） &lt;- st-remote-invoke &lt;- st-webst-common-lib（1.1） &lt;- st-dal &lt;- st-web 依赖排除 去掉间接引入的jar包 如果不想用spring boot默认提供的log，想集成第三方的log时 或者说上面依赖仲裁的第二个例子中，只想用st-common-lib的1.1版本，就可以把1.0版本排除 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;本文链接：面试官：Maven的jar包冲突如何解决欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：mvn package和mvn install都能打包，他们有区别吗","slug":"java-interview_0028","date":"2019-01-30T08:50:00.000Z","updated":"2020-01-04T08:57:38.197Z","comments":true,"path":"2019/01/30/java-interview_0028.html","link":"","permalink":"http://www.ergzcode.com/2019/01/30/java-interview_0028.html","excerpt":"介绍我们用maven打包一般用如下2个命令 mvn clean package 清理打包mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 区别就是install比package多了一步将打好的jar包放到本地仓库的过程 我从头说一下maven帮我们做了那些，并解释一下maven的工程流程","text":"介绍我们用maven打包一般用如下2个命令 mvn clean package 清理打包mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 区别就是install比package多了一步将打好的jar包放到本地仓库的过程 我从头说一下maven帮我们做了那些，并解释一下maven的工程流程 没有Maven之前的日子个人的一个小感受，学习一个新技术，应该以历史的眼光来看待这个新技术出现的原因，以及帮我们解决了什么问题。我们来回忆一下没有Maven的日子是怎么样的？ 开发一个项目，需要用别人写好的jar包，我们先把开源的jar包下载下来放到项目的lib目录下，并且把这个目录添加到classpath（告诉Java执行环境，在哪些目录下可以找到你要执行的Java程序需要的类或者包）。我们下载了a.jar发现a.jar还需要依赖b.jar，结果又去把b.jar下载下来开始运行。如果运气够好，我们项目在添加完所有的依赖后，能正常运行了。如果运气不好，还会遇到jar包版本的问题，例如a.jar在调用b.jar的时候发现b.jar根本没有这个方法，在别的版本中才有，现在好了，光找依赖和适配版本就能花上不少时间。而且我们往git上上传代码的时候，还必须把这些lib都上传上去。别人下载我们的代码也必须把lib下载下来，这个真心耗费时间 这时候Maven作为Java世界包管理工具出现了，当然Java的世界还有其他的包管理工具，例如gradle等。就像yum是Linux世界的包管理工具，webpack是前端世界的包管理工具一样 Maven仓库的种类本地仓库，私服，中央仓库Maven找jar包的过程是这样的，先在本地仓库找，找不到再去私服(如果配置了的话)，再找不到去中央仓库（Maven团队维护中） 从中央仓库找到后，会在私服和本地仓库放一份，从私服找到后也会在本地仓库放一份 当你安装好了Maven后，在conf目录下有个settings.xml文件，这个里面的配置的项很多，后文会详细介绍这个配置文件 &lt;!-- localRepository --&gt; Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;在这个配置文件下有这样的一段话，说了Maven默认的本地仓库的地址为${user.home}/.m2/repository（当然你可以重新设置本地仓库的地址，上面就是模板），我是windows电脑，来看看这个目录可以看到很多jar包被存在本地，当然如果你想配置私服也是在settings.xml进行配置，随便一搜很多教程，不再赘述 搭建私服好处多多，在一个公司内部可以开发一些公共的基础组件放到私服上，方便其他同事使用 Maven的默认配置一个Maven的项目整体结构是这样的 在这里插入图片描述（图片省略…） 为什么一个Maven项目的文件结构是这种的呢？ 这里就不得不说Maven的一个特性，约定优于配置 Maven默认配置了：${project.basedir}/src/main/java为项目的源代码目录${project.basedir}/src/main/test为项目的测试源代码目录${project.basedir}/target为项目的编译输出目录等 spring boot 就是约定优于配置的体现，想想我们用springMVC的时候还得配置视图解析器，包的自动扫描，而用spring boot框架后，我们就完全不用再配置了 Maven的项目详解安装还是挺简单的，我就不再介绍了，我也没有单独下载，一般就有了idea自带的Maven插件，下载完后目录结构如下：bin目录该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。 boot目录该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的Java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库 conf目录该目录包含了一个非常重要的文件settings.xml文件。直接修改该文件，就能在机器上全局的定制Maven的行为，即对所有用户都生效。一般情况下，我们更偏向于复制该文件至/.m2/目录下（表示用户家目录，windows下~就是C:\\Users{用户名}），然后修改该文件，在用户级别定制Maven的行为。 lib目录该目录包含了所有Maven运行需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar，maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如common-cli-1.2.jar,common-lang-2.6.jar等等。 settings.xml配置文件详解我们来细说一下settings.xml文件，这个文件可以定制Maven的行为，上面已经说到settings.xml可以可以放在2个位置，~/.m2/settings.xml(默认没有，需要我们自己复制)和${maven.home}/conf/settings.xml 这2个配置文件的加载顺序为~/.m2/settings.xml &gt; ${maven.home}/conf/settings.xml，为了不影响他人，所以我们将conf下的settings.xml配置文件复制到家目录，在用户级别定制Maven的行为 这个和配置环境变量有点类似，Windows和Linux都可以配置系统级别的环境变量和用户级别的环境变量，这里单说一下Linux的吧，在/etc/profile里面配置的就是系统级别的环境变量，在~/.bash_profile里面配置的就是用户级别的环境变量 各种配置项还是挺多的，设置镜像仓库（国内用阿里云的比较多），设置代理，不再赘述 Maven常用命令 命令 描述 mvn -version 显示版本信息 mvn clean 删除target目录 mvn compile 编译src/main/java下的代码 mvn package 打包，在target目录下生成jar或war包 mvn test 执行src/test/java下以Test开头或者以Test结尾的的测试用例 mvn install 打包，并把jar或war包复制到本地仓库，供其他模块引用 mvn deploy 将打包的文件发到私服 mvn dependency：tree 打印出项目整个依赖树 当然也可以连着使用mvn clean package 清理打包mvn clean package -DskipTest=true 清理打包，并跳过测试用例mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 运行单元测试的时候也没必要一个一个的点击测试方法，mvn test一个命令跑完所有的测试用例，要注意的是只会执行以Test开头或者结尾的测试类，也没必要自己写测试类，网上有些文章介绍了快速生成测试类的方法，可以去搜索看看，生成的测试类都是以Test开头或结尾的，这里不再赘述。 mvn dependency:tree &gt; show.txt将项目的整个依赖重定向到文件中，方便查看 本文链接：面试官：mvn package和mvn install都能打包，他们有区别吗欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：每次你可以爬1或者2个台阶，爬到第n级台阶有多少种方法","slug":"java-interview_0019","date":"2019-01-29T07:38:00.000Z","updated":"2019-12-31T10:36:02.184Z","comments":true,"path":"2019/01/29/java-interview_0019.html","link":"","permalink":"http://www.ergzcode.com/2019/01/29/java-interview_0019.html","excerpt":"介绍这是leeCode的第70题 题目描述 假设你正在爬楼梯。需要n阶你才能到达楼顶。 每次你可以爬1或者2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定n是一个正整数。 示例1： 输入：2 输出：2 解释：有两种方法可以爬到楼顶。 1.1阶 + 1阶 2.2阶","text":"介绍这是leeCode的第70题 题目描述 假设你正在爬楼梯。需要n阶你才能到达楼顶。 每次你可以爬1或者2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定n是一个正整数。 示例1： 输入：2 输出：2 解释：有两种方法可以爬到楼顶。 1.1阶 + 1阶 2.2阶 示例2： 输入：3 输出：3解释：有三种方法可以爬到楼顶。 1.1阶 + 1阶 + 1阶 2.1阶 + 2阶 3.2阶 + 1阶思路分析这是一个简单的递推题目，搞懂了其实就是一个斐波那契数列。你想的没错，就是你开始学编程时，那个兔子繁殖的问题。 如果一开始有一对兔子，他们每月生育一对兔子，小兔出生后一个月又开始生育繁殖的情况与最初的那对兔子一样，那么一年后有多少对兔子呢？ 答案是，每月兔子的总数可以用一下数列表示：1，1，2，3，5，8，13，21，34，55，89，144，233… 来想一下，第n阶台阶可以从那一节上爬上来?只能是n-1和n-2啊，所以我们就能得到递推公式f(n)=f(n-1)+f(n-2),f(n)表示到n阶台阶方法数，这不就是典型的斐波那契数列吗？有意思的是斐波那契数列有很多种实现方法，看来一一道来。 第一种：递归 递归出口是当n=1的值为1，当n=2时值为2 class solution{ public int climbStairs(int n){ if(n==1||n==2) return n; } return climbStairs(n-1)+climbStairs(n-2); }这种代码在Leecode上会超时，因为递归比较耗时和耗内存。面试的时候也不要回答这种方法。 第二种：递推当n=1值为1，当n=2时值为2 当n&gt;=3的递推公式是f(n)=f(n-1)+f(n-2) public class solution{ public int climbStairs(int n){ if(n==1) return 1; } int[] f = new int[n+1]; f[1]=1; f[2]=2; for (int i = 3; i &lt;= n; i++) { f[i] = f[i-2] + f[i-1]; } return f[n]; }一般回答这种方式即可，时间复杂度为O(n) 第三种 通向公式 很多人其实并不知道有通向公式，通向公式如下 递推过程就不分析了，写这种算法是因为你可以和面试官说一波，因为很多面试官其实也不知道这种方法 public static int climbStaris1(int n){ double sqrt5=Math.sqrt(5); double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1); return (int) (fibn/sqrt5); } public static void main(String[] args) { System.out.println(climbStaris1(4)); }矩阵快速幂 这种算法用了矩阵乘法的思想，因为要讲清楚还得复习一遍高等数学的矩阵乘法，面试也很少写这种算法，就不再解释了，有兴趣的可以找相关的资料来看，面试中一般用递推打出来就行。面大厂的可以看一波这个算法，偶尔会问的深一点。 本文链接：面试官：每次你可以爬1或者2个台阶，爬到第n级台阶有多少种方法欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：写一下单例模式吧，知道单例模式有几种写法吗","slug":"java-interview_0012","date":"2019-01-28T04:24:00.000Z","updated":"2019-12-31T05:29:06.741Z","comments":true,"path":"2019/01/28/java-interview_0012.html","link":"","permalink":"http://www.ergzcode.com/2019/01/28/java-interview_0012.html","excerpt":"参考之前的一篇文章：深入Java单例模式 介绍设计模式很多，单例模式绝对是问的最多的一个了，也是让手写的最多的一个设计模式。很多人只会写双重检测的设计模式，但问的深一点其实很多人答不上来。比如，变量为什么要用volatile修饰，为什么要写2个if，一个if不行吗？还有就是单例模式有很多种写法。我以演进的方式写一个单例模式的5种写法，面试的时候建议写双重检测的写法和静态内部类的写法。 有一些对象其实我们只需要一个，比如说：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能看到一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者不一致的结果。","text":"参考之前的一篇文章：深入Java单例模式 介绍设计模式很多，单例模式绝对是问的最多的一个了，也是让手写的最多的一个设计模式。很多人只会写双重检测的设计模式，但问的深一点其实很多人答不上来。比如，变量为什么要用volatile修饰，为什么要写2个if，一个if不行吗？还有就是单例模式有很多种写法。我以演进的方式写一个单例模式的5种写法，面试的时候建议写双重检测的写法和静态内部类的写法。 有一些对象其实我们只需要一个，比如说：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能看到一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者不一致的结果。 第一种（懒汉）//code1 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } }当2个线程同时进入getInstance()的if语句里面，会返回2个不同的实例，因此这种方式是线程不安全的 //code2 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} //同步方法 public static synchronized Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } }用所synchronized修饰可以保证线程安全，但是只有第一次执行此方法时才需要同步，设置好uniqueInstance，就不需要同步这个方法了，之后每次调用这个方法，同步都是一种累赘。 双重检查锁定（推荐）synchronized锁粒度太大，人们就想到通过双重检查锁定来降低同步的开销，下面是实例代码 //code3 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ //同步代码块 synchronized(Singleton.class){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } } } return uniqueInstance; } }如上面的代码所示，如果第一次检查uniqueInstance不为null，那么就不需要执行下面的加锁和初始化操作，可以大幅降低synchronized带来的性能消耗，当在多线程环境下试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象，这就保证了只有一个实例的创建。 经常有人对code3中，为什么要执行2次if语句不太清楚，简答的描述一下，有可能有AB2个线程同时进入第一个if语句，然后A拿到锁，创建对象完成。因为B线程也判断了uniqueInstance为null,如果不再做一次判空处理的话，B拿到锁后会重新创建对象，但是加了第二个if语句后，就直接返回退出了。 双重检查锁定看起来似乎很完美，但这里一个错误的优化！在线程执行到getInstance()方法的第4行时，代码读取到uniqueInstance不为null，uniqueSingleton引用指向的对象有可能还没有完成初始化（半初始化）。 简单概述一下《Java并发编程的艺术》的解释， uniqueInstance = new Singleton()可以分解为如下三行代码： memory = allocate();//1：申请一块内存空间分配给对象 ctorInstance(memory);//2:调用构造方法初始化对象 uniqueInstance = memory;//3：设置uniqueInstance指向刚分配的内存地址3行伪代码中的2和3之间，可能会被重排序，重排序后执行的顺序如下 memory = allocate();//1：申请一块内存空间分配给对象 uniqueInstance = memory;//3：设置uniqueInstance指向刚分配的内存地址 //注意：此时对象还没有初始化 ctorInstance(memory);//2:调用构造方法初始化对象多个线程访问时可能出现如下的情况 时间 线程A 线程B 11 A1：分配对象的内存空间 12 A3：设置uniqueInstance指向的内存地址 13 B1：判断uniqueInstance是否为空 14 B2：由于uniqueInstance不为null，线程B访问uniqueInstance引用的对象 15 A2：初始化对象 16 A4：访问instance引用的对象 这样会导致线程B访问到一个还没有初始化的对象，此时可以用volatile修饰Singleton,这样3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止 //code4 public class Singleton { private volatile static Singleton uniqueSingleton; private Singleton(){} public static Singleton getInstance(){ if (uniqueSingleton == null){ synchronized(Singleton.class){ if (uniqueSingleton == null){ uniqueSingleton = new Singleton(); } } } return uniqueSingleton; } }第三种（饿汉）如果应用程序总是创建并使用单例模式，或者在创建和运行时方面的负担不太繁重，我们可以以饿汉式的方式来创建单例code5（静态常量） //code5 public class Singleton { private static final Singleton INSTANCE =new Singleton(); private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } }code6（静态代码块） //code6 public class Singleton { private static Singleton instance; private Singleton(){} static { uniqueSingleton = new Singleton(); } public static Singleton getInstance(){ return instance; } }在类加载的时候直接创建这个对象，这样既可以提高效率，又能保证线程安全，code5和code6几乎没有区别，因为静态成员变量和静态代码块都是类初始化的时候加载执行。 第四种静态内部类（推荐用）//code7 public class Singleton { private static class SingletonHolder{ private static final Singleton instance = new Singleton(); } private Singleton(){} public static Singleton getInstance(){ return SingletonHolder.instance ; } }饿汉式的方式只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading的效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示的通过调用getInstance()方法时，才会显示装载SingletonHolder类，从而实例化instance。 第五种枚举（推荐用）public enum Singleton { INSTANCE; public void whateverMethod() { } }枚举是公认实现单例的最好方式。借助JDK1.5中添加的枚举来实现的单例模式，不仅能避免多线程安全问题，而且还能防止反序列化和反射对单例的破坏问题。 总结不管采用何种方案，请记住使用单例的三大点： 线程安全 延迟加载 序列化和反序列化安全 本文链接：面试官：写一下单例模式吧，知道单例模式有几种写法吗欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：volatile关键字用过吧？说一下作用和实现吧","slug":"java-interview_0017","date":"2019-01-27T06:14:00.000Z","updated":"2019-12-31T05:28:45.441Z","comments":true,"path":"2019/01/27/java-interview_0017.html","link":"","permalink":"http://www.ergzcode.com/2019/01/27/java-interview_0017.html","excerpt":"极简计算机发展史我们知道，计算机的CPU和内存的交互是最频繁的，内存是我们的高速缓存区。而刚开始是用户磁盘和CPU进行交互，CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一矛盾，CPU厂商在每颗CPU上加上了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。 CPU&lt;-&gt;High Speed cache memory&lt;-&gt;Main memory physical menory","text":"极简计算机发展史我们知道，计算机的CPU和内存的交互是最频繁的，内存是我们的高速缓存区。而刚开始是用户磁盘和CPU进行交互，CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一矛盾，CPU厂商在每颗CPU上加上了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。 CPU&lt;-&gt;High Speed cache memory&lt;-&gt;Main memory physical menory 单核CPU的性能不可能无限制的增长，要想很多的提升性能，需要多个处理器协同工作，这就是多核处理器的由来。基于高速缓存的存储交互很好的解决了处理器和内存之间的矛盾。也引入了新的问题：缓存一致性的问题。在多核处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一个块内存（下文成主存，main memory主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要用这些协议来保证数据的一致性。 缓存一致性协议中最出名的就是Intel的MESI协议。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它的核心的思想是：当CPU写数据时，如果发生操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存设置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量是无效状态，那么它就会从内存中重新读取 Java内存模型Java的内存模型和上面的结构还是挺相似的，此时在看工作内存和主内存的关系，从逻辑上，高速缓存对应工作内存，每个线程分配到CPU时间片时，独自享有高速缓存的使用能力。主内存对应存储的物理内存，这只是逻辑上的对等关系，物理上的具体对应关系十分复杂，这里不讨论。 volatile的作用是什么volatile可以保证可见性，有序性，但不保证原子性： 可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值 假如说有2个线程对一个变量data进行操作，线程先会把主内存中的值缓存到工作内存，这样做的原因和上面提到的高速缓存类似，提高效率 但是这样会引入新的问题，假如说线程A把data的值修改为1，线程A的工作内存data的值为1，但是主内存和线程B的工作内存data值为0，此时就有可能出现Java并发编程中的可见性问题 举个例子，如下面代码，线程A已经将flag的值改变，但是线程B并没有及时感知到，导致一直进行死循环 public class Test{ public static boolean flag = false; public static void main(String[] args){ new Thread(()-&gt;{ while(!flag){ } System.out.println(&quot;threadB end&quot;); }).start(); try{ TimeUnit.SECONDS.sleep(1); }catch(InterruptedException e){ e.printstackTrace(); } new Thread(()-&gt;{ flag= =true; System.out.println(&quot;threadA end&quot;); }).start(); } }线程B一直没有结束,输出为: threadA end但是如果将data定义为如下形式，线程A对data的变更，线程B立马能感知到 public static volatile boolean flag = false;输出为: threadA end threadB end那么是如何实现的呢？其实volatile保证可见性的方式和上面提到的缓存一致性协议的原理很类似： 1.线程A将工作内存的data更改后，强制将data值刷回主内存2.如果线程B的工作内存中有data值变量的缓存，会强制让这个data变量缓存失效3.当线程B需要读取data变量的值时，先从工作内存中读，发现已经失效过期，就会从主内存中加载data变量的最新值了 放个图理解的更清楚 有序性 有序性即程序执行的顺序按照代码的先后顺序执行 int i = 0; boolean flag = false; i = 1;//语句1 flag = true;//语句2上面的代码定义了一个int型的变量，定义了一个boolean类型的变量，然后分别对这两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序的运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码的执行结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序运行结果并没有影响，那么就有可能在执行的过程中，语句2先执行而语句1后执行。 但是有依赖关系的语句不会进行重排序，如下面求圆面积的代码 double pi = 4.14;//A double r = 1.0;//B double area = pi * r * r;//C程序的执行顺序只有下面这2种形式 A-&gt;B-&gt;C和B-&gt;A-&gt;C，因为A和C之间存在依赖关系，同时B和C之间也存在依赖关系。因此最终执行的指令序列中C不能被重排序到A和B前面。 虽然重排序不会影响单个线程内程序的执行结果，但是多线程呢？下面看一个例子 //线程1 context = loadContext();//语句1 inited = true;//语句2 //线程2 while(!inited){ sleep(); } doSomethingwithconfig(context);上面的代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行的过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)的方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性 当写双重检测锁定版本（double check）的单例模式时，就要用到volatile关键来保证可见性 原子性 原子性即一个操作或多个操作，要么全部执行并且执行的过程中不会被任何因素打断，要么就都不会执行。 public class Test{ public static volatile int inc = 0; public static void main(String[] args){ //新建一个线程池 ExecutorService service = Executors.newCachedThreadPool(); for(int i = 0;i &lt; 5;i++){ service.execute(()-&gt;{ for(int j = 0;j &lt; 1000;j++){ inc++; } }); } //关闭线程池 service.shutdown(); try{ TimeUnit.SECONDS.sleep(1); }cacth(InterruptedException e){ e.printStackTrace(); } System.out.println(&quot;inc = &quot;+inc); } }执行上面的代码结果并不是每次都是5000，表明volatile并不能保证原子性 可能回有朋友就会有疑问，不对啊，上面是对变量Inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对Inc自增完之后，其他线程中都能看到修改后的值啊，所以有5个线程分别进行了1000次操作，那么最终Inc的值应该是1000*5=5000。 这里面就有一个误区了，volatile关键字能保证可见性是没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值，进行加1操作，写入工作内存。那么就是说自增操作的三个子操作可能会分割执行，就有可能导致下面这种情况出现： 加入某个时刻变量Inc的值为10，线程1对变量进行自增操作，线程1先读取变量Inc的原始值，然后线程1倍阻塞了；然后线程2对变量进行自增操作，线程2也去读取inc的原始值，由于线程1只是对变量进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存失效，也不会导致主内存中inc的值刷新，所以线程2会直接从工作内存中读取Inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值（inc++，包括3个操作，1.读取inc的值，2.进行加1操作，3.写入新的值），注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加1。 根源就在这里，自增操作不是原子操作，而且volatile关键字也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过使用AtomicInteger 应用前面已经演示过了 1.状态标记量 2.单例模式中的double check 总结volatile有两部分，一个是lock，禁止指令重排序，因为重排序会导致MESI的一致性协议失效；二是push,设置cache line失效。 本文链接：面试官：volatile关键字用过吧？说一下作用和实现吧欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下Spring StringBuffer StringBuilder的区别","slug":"java-interview_0003","date":"2019-01-26T14:23:00.000Z","updated":"2019-12-30T04:33:23.161Z","comments":true,"path":"2019/01/26/java-interview_0003.html","link":"","permalink":"http://www.ergzcode.com/2019/01/26/java-interview_0003.html","excerpt":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象","text":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 可以看到String类和保存变量的value数组都被final修饰，表明String类是不可变的。 StringBuffer和StringBuilder都继承自AbstractStringBuilder类，看一下AbstractStringBuilder类的定义 abstract class AbstractStringBuilder implements Appendable,CharSequence{ /** *The value is userd for character storage */ char[] value; }看到区别了吗？ value数组没有用private和final修饰，说明了StringBuffer和StringBuilder是可变的。 而StringBuilder和StringBuffer的方法是差不多的，只不过StringBuffer在方法上添加了synchronized关键字，所以在多线程环境下用StringBuffer来获得更高的效率。 看2个类中同一个方法的定义 StringBUffer类 //StringBuffer append方法 @Override public synchronized StringBuffer append(char[] str){ toStringCache = null; super.append(str); return this; }StringBuilder类 //StringBuilder append方法 @Override public StringBuilder append(char[] str){ super.append(str); return this; }因为StringBuffer和StringBulider的实现类似，所以性能比较就落在String和StringBuilder之间了。 1.String是不可变对象，每次操作都会生成新的String对象，然后指针指向新的对象。 2.抽象类AbstractStringBuilder内部提供了一个自动扩容机制，当发现长度不够的时候，会自动进行扩容工作（具体扩容可以看源码，很容易理解），会创建一个新的数组，并将原来数组的数据复制到新的数组，不会创建新的对象，所以拼接字符串的效率高。 用源码证实一下 String类 public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); }StringBuilder类 public StringBuilder append(String str) { super.append(str); return this; }介绍完毕，所以你应该知道这道题应该怎么答了 常见面试题1. 说一下String StringBuffer StringBuilder的区别 都是final类，不能被继承 String长度是不可变的，StringBuffer和StringBuilder长度是可变的 StringBuffer是线程安全的，StringBuilder不是线程安全的。但他们的方法很相似，StringBuffer在方法上添加了synchronized关键字修饰，保证了线程安全 StringBuilder比StringBuffer拥有更好的性能 如果一个String类型的字符串，在编译时可以确定是一个字符串常量，则编译完成后，字符串会自动拼接成一个常量，此时String比StringBuffer和StringBuilder的性能好的多 我用例子解释一下第五条 String a = &quot;a&quot;; String b = &quot;b&quot;; String c = a+b; String d = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;反编译class的文件是这样的 String a = &quot;a&quot;; String b = &quot;b&quot;; (new StringBuilder()).append(a).append(b).toString(); String d = &quot;abc&quot;;看到String d,理解了吗？ 同时看c的拼接过程，先生成一个StringBuilder对象，再调用2次append方法，最后再返回一个String对象，知道StringBuilder比String慢的愿意了吧。 本文链接：面试官：说一下Spring StringBuffer StringBuilder的区别欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下构造函数，静态代码块，构造代码块的加载顺序","slug":"java-interview_0002","date":"2019-01-25T03:00:00.000Z","updated":"2019-12-30T04:33:04.537Z","comments":true,"path":"2019/01/25/java-interview_0002.html","link":"","permalink":"http://www.ergzcode.com/2019/01/25/java-interview_0002.html","excerpt":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } }","text":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } } 来New一个Test类看看会输出什么？ public class TestShow{ public static void main(String[] args){ /*创建第一个对象 我是静态代码块1 我的静态代码块2 我的构造代码块1 我的构造代码块2 我是无参数构造函数 */ System.out.println(&quot;创建第一个对象：&quot;); Test test1 = new Test(); /*创建第二个对象 我的构造代码块1 我的构造代码块2 我是带参数构造函数，参数是5 */ System.out.println(&quot;创建第二个对象：&quot;); Test test2 = new Test(5); } }从输出我们可以总结处如下结论： 执行时间：静态代码块 &gt; 构造代码块 &gt; 构造函数，静态代码块只会在类被加载入内存时加载一次，构造代码块和构造函数都是在对象创建的时候执行，有几个对象就会执行几次，所以一般将加载配置文件的过程写在静态代码块中。 没有继承的加载顺序 先定义一个类作为成员变量，方便看打印输出 public class Parameter { public Parameter(String str){ System.out.println(str); } }写一个测试类 public Test1{ public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); public Test1(){ System.out.println(&quot;构造函数&quot;); } //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } }输出如下 public class ForShow{ public static void main(String[] args){ /*静态成员变量 静态代码块 非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); /*非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); } }可以看出静态成员变量和静态代码块一样，只会在类被加载到内存时加载唯一的一次 改变一下Test类中定义的顺序，看看有什么变化。 public Test2{ //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造函数 public Test2(){ System.out.println(&quot;构造函数&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); }输出如下 public class ForShow{ public static void main(String[] args){ /*静态代码块 静态成员变量 构造代码块b 构造代码块a 非静态成员变量 构造函数 */ new Test2(); } }没有继承情况的执行顺序 静态代码块和静态成员变量，加载的顺序由编写的顺序决定 构造代码块和非静态成员变量，加载顺序由编写顺序决定 构造函数 有继承情况的执行顺序 定义父类 public class Father{ public static Prarmeter parameter1 = new Parameter(&quot;父类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;父类非静态成员变量&quot;); public Father(){ System.out.println(&quot;父类构造函数&quot;); } }定义子类 public class Son extends Father{ public static Prarmeter parameter1 = new Parameter(&quot;子类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;子类非静态成员变量&quot;); public Son(){ System.out.println(&quot;子类构造函数&quot;); } }有继承情况的执行顺序 父类的静态（静态代码块，静态成员变量），子类的静态（静态代码块，静态成员变量） 父类的非静态（构造代码块，非静态成员变量），父类的构造函数 子类的非静态（构造代码块，非静态成员变量），子类的构造函数 记住这几条规则足以应付这一类型的所有面试题 常见的面试题1.Java类定义如下，写出main函数执行后的输出结果 public class A{ static { System.out.println(&quot;static A&quot;); } public A(){ System.out.println(&quot;class A&quot;); } } public class B extends A{ public B(){ System.out.println(&quot;class B&quot;); } public static void main(String[] args){ B instance = new B(); } }上面的知识点如果理解的很清楚的话，这个结果立马就能写出来 所以输出如下 static A class A class B2.问题是如果main函数中的代码如下呢？就是B这个类new了2次 public static void main(String[] args){ B instance1 = new B(); B instance2 = new B(); }万变不离其宗，输出如下 static A class A class B class A class B因为静态成员变量和静态代码块只会在类被载入内存时加载一次。 本文链接：面试官：说一下构造函数，静态代码块，构造代码块的加载顺序欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下八种基本数据类型及其包装类吧","slug":"java-interview_0001","date":"2019-01-24T14:40:00.000Z","updated":"2019-12-31T03:10:21.457Z","comments":true,"path":"2019/01/24/java-interview_0001.html","link":"","permalink":"http://www.ergzcode.com/2019/01/24/java-interview_0001.html","excerpt":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character","text":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character 常见面试题要注意的是基本数据的包装类很多都实现了享元模式。享元模式就是运用共享技术有效地支持大量细粒度对象的复用。用一个常见的面试题来解释 1.判断如下代码的输出，并说出原因 Integer a1 = 40; Integer a2 = 40; System.out.println(a1==a2); Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);由自动装箱和拆箱可以知道这2种写法是等价的 Integer a1 = 40; Integer a1 = Integer.valueOf(40);看一下Integer.valueOf(int i)的方法 //...valueOf(int):Integer public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } //...IntegerCache private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }IntegerCache是Integer的静态内部类，默认创建了[-128,127]的对象，并放到IntegerCache内部的一个cache数组中，在[-128,127]这个范围内的整数对象，不用创建。直接从IntegerCache中的cache数组中根据下标拿就可以了,超出这个范围的每次去创建新的对象。其他几种包装类型的常量池和Integer的思路差不多，源码都很相似。所以答案如下： Integer a1 = 40; Integer a2 = 40; System.out.println(a1 == a2);//true Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);//false包装类缓存数据范围如下： 包装类 缓存范围 Byte -128~127 Short -128~127 Integer -128~127 Long -128~127 Character 0~127 2.Java一个char类型可以存储中文吗？ 可以，因为Java中使用了Unicode字符，不论是中文还是英文固定占用2个字节。 char a = &apos;中&apos;； // 中 System.out.println(a); 3.什么是自动装箱，自动拆箱 自动装箱就是Java自动将原始类型转换为对应的对象，比如将int的变量转换为Integer对象，这个过程就是装箱，反之将Integer对象转换为int类型的值，这个过程就是拆箱。因为这里的装箱和拆箱是自动进行的非人为转换的，所以就称作自动装箱和自动拆箱。 自动装箱时编译器调用ValueOf将原始类型值转换为对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换为原始类型值 //jdk1.5之前的写法 Integer tempNum1 = Integer.valueOf(5); int num1 = tempNum1.intValue(); //jdk1.5之后的写法，自动装箱和拆箱 Integer tempNum2= 5; int num1 = tempNum2;4.为什么要需要基本数据类型的包装类 （1）Java是面向对象的语言，很多地方是需要使用的是对象而不是基本数据类型。例如，List,Map等容器类中基本数据类型是放不进去的。（2）包装类在原先的基本数据类型上，新增加了很多方法，比如Integer.valueOf(String s)等 5.既然包装类能完成所有的功能，为啥还需要基本数据类型 基本数据类型基于数值，对象类型基于引用。基本数据类型存储在栈的局部变量表中。 而对象类型的变量则是存储堆中引用，实例放在堆中，因此对象类型的变量需要占用更多的内存空间，基本数据类型因为占用更少内存被保留下来。 6.写出如下代码的输出 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2); System.out.println(i1 == i2 + i3); System.out.println(i1 == i4); System.out.println(i4 == i5); System.out.println(i4 == i5 + i6); System.out.println(40 == i5 + i6);输出及解释如下 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2);//true //Integer.valueOf()用了常量池，看上面的源码 //比较是内存地址 System.out.println(i1 == i2 + i3);//true // + 操作会导致左右两边都转换为基本数据类型 //比较是值 System.out.println(i1 == i4);//false //Integer.valueOf()使用常量池中的对象 //new Integer每次都会创建新对象 //比较是内存地址 System.out.println(i4 == i5);//false //new关键字会创建新的实例所以这是2个不同的对象 //比较是内存地址 System.out.println(i4 == i5 + i6);//true //解释在下面，比较的是值 System.out.println(40 == i5 + i6);//true //解释在下面，比较的是值语句i4 = i5 + i6,因为这个 + 操作符不适用于Integer对象，首先i5和i6进行了自动拆箱的操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int数据类型，值为40，最终这条语句转为40 == 40进行数值的比较。 本文链接：面试官：说一下八种基本数据类型及其包装类吧欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"MySQL数据库优化，看这篇就够了","slug":"mysql-database-optimization-this-article-is-enough","date":"2018-10-18T15:00:00.000Z","updated":"2019-12-26T15:53:59.177Z","comments":true,"path":"2018/10/18/mysql-database-optimization-this-article-is-enough.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/mysql-database-optimization-this-article-is-enough.html","excerpt":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图","text":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图 2. 优化笔者将优化分为了两大类,软优化和硬优化,软优化一般是操作数据库即可,而硬优化则是操作服务器硬件及参数设置. 2.1 软优化2.1.1 查询语句优化1.首先我们可以用EXPLAIN或DESCRIBE(简写:DESC)命令分析一条查询语句的执行信息.2.例:DESC SELECT * FROM user显示：其中会显示索引和查询数据读取数据条数等信息. 2.1.2 优化子查询在MySQL中,尽量使用JOIN来代替子查询.因为子查询需要嵌套查询,嵌套查询时会建立一张临时表,临时表的建立和删除都会有较大的系统开销,而连接查询不会创建临时表,因此效率比嵌套子查询高. 2.1.3 使用索引索引是提高数据库查询速度最重要的方法之一,关于索引可以参高笔者&lt;MySQL数据库索引&gt;一文,介绍比较详细,此处记录使用索引的三大注意事项: 1.LIKE关键字匹配’%’开头的字符串,不会使用索引. 2.OR关键字的两个字段必须都是用了索引,该查询才会使用索引. 3.使用多列索引必须满足最左匹配. 2.1.4 分解表对于字段较多的表,如果某些字段使用频率较低,此时应当,将其分离出来从而形成新的表, 2.1.5 中间表对于将大量连接查询的表可以创建中间表,从而减少在查询时造成的连接耗时. 2.1.6 增加冗余字段类似于创建中间表,增加冗余也是为了减少连接查询. 2.1.7 分析表,检查表,优化表分析表主要是分析表中关键字的分布,检查表主要是检查表中是否存在错误,优化表主要是消除删除或更新造成的表空间浪费. 一.分析表: 使用 ANALYZE 关键字,如ANALYZE TABLE user;1.Op:表示执行的操作.2.Msg_type:信息类型,有status,info,note,warning,error.3.Msg_text:显示信息. 二.检查表: 使用CHECK关键字,如CHECK TABLE user [option]option只对MyISAM有效,共五个参数值:1.QUICK:不扫描行,不检查错误的连接.2.FAST:只检查没有正确关闭的表.3.CHANGED:只检查上次检查后被更改的表和没被正确关闭的表.4.MEDIUM:扫描行,以验证被删除的连接是有效的,也可以计算各行关键字校验和.5.EXTENDED:最全面的的检查,对每行关键字全面查找. 三.优化表:使用OPTIMIZE关键字,如OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE user;LOCAL|NO_WRITE_TO_BINLOG都是表示不写入日志.,优化表只对VARCHAR,BLOB和TEXT有效,通过OPTIMIZE TABLE语句可以消除文件碎片,在执行过程中会加上只读锁. 2.2 硬优化2.2.1 硬件三件套1.配置多核心和频率高的cpu,多核心可以执行多个线程.2.配置大内存,提高内存,即可提高缓存区容量,因此能减少磁盘I/O时间,从而提高响应速度.3.配置高速磁盘或合理分布磁盘:高速磁盘提高I/O,分布磁盘能提高并行操作的能力. 2.2.2 优化数据库参数优化数据库参数可以提高资源利用率,从而提高MySQL服务器性能.MySQL服务的配置参数都在my.cnf或my.ini,下面列出性能影响较大的几个参数. 1.key_buffer_size:索引缓冲区大小2.table_cache:能同时打开表的个数3.query_cache_size和query_cache_type:前者是查询缓冲区大小,后者是前面参数的开关,0表示不使用缓冲区,1表示使用缓冲区,但可以在查询中使用4.SQL_NO_CACHE表示不要使用缓冲区,2表示在查询中明确指出使用缓冲区才用缓冲区,即SQL_CACHE.5.sort_buffer_size:排序缓冲区 传送门:更多参数 2.2.3 分库分表因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。另外一个，压力过大把你的数据库给搞挂了怎么办？所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这时作为主库承载写入请求。然后每个主库都挂载至少一个从库，由从库来承载读请求。 2.2.4 缓存集群 结语一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统和各种精妙的架构设计.因此一篇小文顶多具有抛砖引玉的效果,但是数据库优化的思想差不多就这些了. 原文链接:MySQL数据库优化欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.ergzcode.com/tags/Mysql/"}],"author":"ergz"},{"title":"Tomcat优化之修改内存配置","slug":"tomcat-modifying-memory-configuration-for-optimization","date":"2018-10-18T14:17:00.000Z","updated":"2019-12-29T09:21:04.754Z","comments":true,"path":"2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","excerpt":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明","text":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明 maxIdleTime：最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms）； minSpareThreads：最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值4； maxSpareThreads：最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50； maxThreads：最大线程数，大并发请求时，tomcat能创建来处理请求的最大线程数，超过则放入请求队列中进行排队，默认值为200； acceptCount：当最大线程数（maxThreads）被使用完时，可以放入请求队列排队个数，超过这个数返回connection refused（请求被拒绝），一般设置和maxThreads一样，不过这个具体需要根据自己的应用实际访问峰值和平均值来权衡，默认值为100； connectionTimeout：网络连接超时，假设设置为0表示永不超时，这样设置隐患巨大，通常可设置为30000ms，默认60000ms； Windows Tomcat允许每个进程maxThreads（最大线程数）2000，Linux Tomcat允许每个进程maxThreads（最大线程数）1000 请看下面三种情况情况1：接受一个请求，此时tomcat起动的线程数没有到达maxThreads，tomcat会起动一个线程来处理此请求。 情况2：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，tomcat会把此请求放入等待队列，等待空闲线程。 情况3：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，等待队列中的请求个数也达到了acceptCount，此时tomcat会直接拒绝此次请求，返回connection refused maxThreads如何配置一般的服务器操作都包括两方面：1计算（主要消耗cpu），2等待（io、数据库等）。 第一种极端情况，如果我们的操作是纯粹的计算，那么系统响应时间的主要限制就是cpu的运算能力，此时maxThreads应该尽量设的小，降低同一时间内争抢cpu的线程个数，可以提高计算效率，提高系统的整体处理能力。 第二种极端情况，如果我们的操作纯粹是IO或者数据库，那么响应时间的主要限制就变为等待外部资源，此时maxThreads应该尽量设的大，这样才能提高同时处理请求的个数，从而提高系统整体的处理能力。此情况下因为tomcat同时处理的请求量会比较大，所以需要关注一下tomcat的虚拟机内存设置和linux的open file限制。 我在测试时遇到一个问题，maxThreads我设置的比较大比如3000，当服务的线程数大到一定程度时，一般是2000出头，单次请求的响应时间就会急剧的增加，百思不得其解这是为什么，四处寻求答案无果，最后我总结的原因可能是cpu在线程切换时消耗的时间随着线程数量的增加越来越大，cpu把大多数时间都用来在这2000多个线程直接切换上了，当然cpu就没有时间来处理我们的程序了。以前一直简单的认为多线程=高效率。其实多线程本身并不能提高cpu效率，线程过多反而会降低cpu效率。当cpu核心数&lt;线程数时，cpu就需要在多个线程直接来回切换，以保证每个线程都会获得cpu时间，即通常我们说的并发执行。所以maxThreads的配置绝对不是越大越好。 现实应用中，我们的操作都会包含以上两种类型（计算、等待），所以maxThreads的配置并没有一个最优值，一定要根据具体情况来配置。最好的做法是：在不断测试的基础上，不断调整、优化，才能得到最合理的配置。acceptCount的配置，我一般是设置的跟maxThreads一样大，这个值应该是主要根据应用的访问峰值与平均值来权衡配置的。如果设的较小，可以保证接受的请求较快相应，但是超出的请求可能就直接被拒绝。如果设的较大，可能就会出现大量的请求超时的情况，因为我们系统的处理能力是一定的。 原文链接：Tomcat修改内存配置欢迎转载，请注明出处！","categories":[{"name":"web服务器","slug":"web服务器","permalink":"http://www.ergzcode.com/categories/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://www.ergzcode.com/tags/tomcat/"}],"author":"ergz"},{"title":"设计模式之代理模式","slug":"proxy-pattern","date":"2016-06-11T12:32:00.000Z","updated":"2020-01-10T17:25:59.751Z","comments":true,"path":"2016/06/11/proxy-pattern.html","link":"","permalink":"http://www.ergzcode.com/2016/06/11/proxy-pattern.html","excerpt":"在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。","text":"在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 步骤 1创建一个接口:Image.java public interface Image { void display(); }步骤 2创建实现接口的实体类:RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(&quot;Displaying &quot; + fileName); } private void loadFromDisk(String fileName){ System.out.println(&quot;Loading &quot; + fileName); } }ProxyImage.java public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); } }步骤 3当被请求时，使用 ProxyImage 来获取 RealImage 类的对象:ProxyPatternDemo.java public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(&quot;test_10mb.jpg&quot;); // 图像将从磁盘加载 image.display(); System.out.println(&quot;&quot;); // 图像不需要从磁盘加载 image.display(); } }步骤 4执行程序，输出结果： Loading test_10mb.jpg Displaying test_10mb.jpg Displaying test_10mb.jpg扩展JDK自带的动态代理原理：JDK的动态代理是通过反射类Proxy和InvocationHandler回调接口实现的缺点：JDK中要代理的类必须要实现一个接口，也就是说只能对该类所实现的接口中定义的方法进行代理，另外是通过反射来实现的动态代理效率也不是很高，这2点跟CGLIB这个类库还是有区别的。 java.lang.reflect.Proxy:生成动态代理类和对象 java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现 对真实角色的代理访问每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。 代码：a) 接口：Subject.java /** * @author gnehcgnaw * @date 2018/11/5 19:29 */ public interface Subject { public int sellBooks(); public String speak(); }b)真实对象：RealSubject.java /** * @author gnehcgnaw * @date 2018/11/5 18:54 */ public class RealSubject implements Subject{ @Override public int sellBooks() { System.out.println(&quot;卖书&quot;); return 1 ; } @Override public String speak() { System.out.println(&quot;说话&quot;); return &quot;张三&quot;; } }c)处理器对象：MyInvocationHandler.java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; /** * 定义一个处理器 * @author gnehcgnaw * @date 2018/11/5 19:26 */ public class MyInvocationHandler implements InvocationHandler { /** * 因为需要处理真实角色，所以要把真实角色传进来 */ Subject realSubject ; public MyInvocationHandler(Subject realSubject) { this.realSubject = realSubject; } /** * * @param proxy 代理类 * @param method 正在调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;调用代理类&quot;); if(method.getName().equals(&quot;sellBooks&quot;)){ int num = (int)method.invoke(realSubject, args); System.out.println(&quot;调用的是卖书的方法&quot;); return num; }else { String string = (String) method.invoke(realSubject,args) ; System.out.println(&quot;调用的是说话的方法&quot;); return string ; } } }d)调用端：Main.java import java.lang.reflect.Proxy; /** * 调用类 * @author gnehcgnaw * @date 2018/11/7 20:26 */ public class Client { public static void main(String[] args) { //真实对象 Subject realSubject = new RealSubject(); MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject); //代理对象 Subject proxyClass = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Subject.class}, myInvocationHandler); proxyClass.sellBooks(); proxyClass.speak(); } }CGLIB介绍：CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib原理：CGLIB动态代理主要针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或者final关键字修饰的方法，则不会被重写。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。底层：CGLIB代理主要是通过对字节码的操作，利用了字节码处理框架ASM，来转换字节码生成新的类。但是不鼓励直接使用ASM ，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。缺点：对于final方法，无法进行代理。 需要代理的类:Engineer.java public class Engineer { // 可以被代理 public void eat() { System.out.println(&quot;工程师正在吃饭&quot;); } // final 方法不会被生成的子类覆盖 public final void work() { System.out.println(&quot;工程师正在工作&quot;); } // private 方法不会被生成的子类覆盖 private void play() { System.out.println(&quot;this engineer is playing game&quot;); } }CGLIB 代理类:CglibProxy.java import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor { private Object target; public CglibProxy(Object target) { this.target = target; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;### before invocation&quot;); Object result = method.invoke(target, objects); System.out.println(&quot;### end invocation&quot;); return result; } public static Object getProxy(Object target) { Enhancer enhancer = new Enhancer(); // 设置需要代理的对象 enhancer.setSuperclass(target.getClass()); // 设置代理人 enhancer.setCallback(new CglibProxy(target)); return enhancer.create(); } }测试方法: import java.lang.reflect.Method; import java.util.Arrays; public class CglibMainTest { public static void main(String[] args) { // 生成 Cglib 代理类 Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer()); // 调用相关方法 engineerProxy.eat(); } }运行结果: ### before invocation 工程师正在吃饭 ### end invocationJDK的动态和CGLIB的比较CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。 原文链接：代理模式其他相关文章：CGLIB(Code Generation Library) 介绍与原理欢饮转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"设计模式之抽象工厂模式","slug":"abstract-factory-pattern","date":"2016-06-10T15:03:00.000Z","updated":"2020-01-10T17:17:42.000Z","comments":true,"path":"2016/06/10/abstract-factory-pattern.html","link":"","permalink":"http://www.ergzcode.com/2016/06/10/abstract-factory-pattern.html","excerpt":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。","text":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1为形状创建一个接口:Shape.java public interface Shape { void draw(); }步骤 2创建实现接口的实体类:Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(&quot;Inside Rectangle::draw() method.&quot;); } }Square.java public class Square implements Shape { @Override public void draw() { System.out.println(&quot;Inside Square::draw() method.&quot;); } }Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(&quot;Inside Circle::draw() method.&quot;); } }步骤 3为颜色创建一个接口:Color.java public interface Color { void fill(); }步骤4创建实现接口的实体类:Red.java public class Red implements Color { @Override public void fill() { System.out.println(&quot;Inside Red::fill() method.&quot;); } }Green.java public class Green implements Color { @Override public void fill() { System.out.println(&quot;Inside Green::fill() method.&quot;); } }Blue.java public class Blue implements Color { @Override public void fill() { System.out.println(&quot;Inside Blue::fill() method.&quot;); } }步骤 5为 Color 和 Shape 对象创建抽象类来获取工厂:AbstractFactory.java public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; }步骤 6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象:ShapeFactory.java public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){ return new Circle(); } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } }ColorFactory.java public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(&quot;RED&quot;)){ return new Red(); } else if(color.equalsIgnoreCase(&quot;GREEN&quot;)){ return new Green(); } else if(color.equalsIgnoreCase(&quot;BLUE&quot;)){ return new Blue(); } return null; } }步骤 7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂:FactoryProducer.java public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(&quot;SHAPE&quot;)){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(&quot;COLOR&quot;)){ return new ColorFactory(); } return null; } }步骤 8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象:AbstractFactoryPatternDemo.java public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;Green&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); } }步骤 9执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. Inside Red::fill() method. Inside Green::fill() method. Inside Blue::fill() method.扩展(图文理解)下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。 简单工厂模式简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。 工厂模式工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由具体鼠标工厂决定。后续直接调用鼠标工厂.生产鼠标()方法即可。 抽象工厂模式抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。创建工厂时，由戴尔工厂创建。后续调用工厂.生产鼠标()方法则生产戴尔鼠标，调用工厂.生产键盘()方法则生产戴尔键盘。 在抽象工厂模式中，假设我们需要增加一个工厂假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商，之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。 在抽象工厂模式中，假设我们需要增加一个产品假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。 原文链接：抽象工厂模式欢饮转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"设计模式之工厂模式","slug":"factory-pattern","date":"2016-06-09T13:03:00.000Z","updated":"2020-01-10T17:17:24.000Z","comments":true,"path":"2016/06/09/factory-pattern.html","link":"","permalink":"http://www.ergzcode.com/2016/06/09/factory-pattern.html","excerpt":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。","text":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1创建一个接口:Shape.java public interface Shape { void draw(); }步骤 2创建实现接口的实体类:Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(&quot;Inside Rectangle::draw() method.&quot;); } }Square.java public class Square implements Shape { @Override public void draw() { System.out.println(&quot;Inside Square::draw() method.&quot;); } }Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(&quot;Inside Circle::draw() method.&quot;); } }步骤 3创建一个工厂，生成基于给定信息的实体类的对象:ShapeFactory.java public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){ return new Circle(); } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){ return new Square(); } return null; } }扩展：1.使用反射机制和泛型，修改后的代码如下： public class ShapeFactory { public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) { if (clazz == null ) { return null; } T obj = null; try { obj = (T) Class.forName(clazz.getName()).newInstance(); } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) { e.printStackTrace(); } return obj; } }省略类型强制转换，支持多态 Rectangle rect = ShapeFactory.getClass(Rectangle.class); rect.draw(); Shape square = ShapeFactory.getClass(Square.class); square.draw();2.在jdk9中直接使用泛型的newInstance方法已经过时。重写的getClass()方法如下： public class ShapeFactory { public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) { if (clazz == null ) { return null; } T obj = null; try { obj = (T)clazz.getDeclaredConstructor().newInstance(); } catch (ReflectiveOperationException e) { e.printStackTrace(); } return obj; } }步骤 4使用该工厂，通过传递类型信息来获取实体类的对象:FactoryPatternDemo.java public class FactoryPatternDemo { public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); } }步骤 5执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method.总结工厂设计模式的优点 面向接口编程，体现了面向对象的思想； 将创建对象的工作转移到了工厂类； JDK 中的工厂设计模式实例 java.util.Calendar, ResourceBundle and NumberFormat getInstance() 使用了工厂方法模式； valueOf() 在包装类中，如Boolean, Integer 也使用了工厂方法模式； 一句话概括工厂模式 简单工厂：一个工厂类，一个产品抽象类。 工厂方法：多个工厂类，一个产品抽象类 抽象工厂：多个工厂类，多个产品抽象类。 生活中的工厂模式： 简单工厂类：一个麦当劳店，可以生产多种汉堡。 工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。 百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。 原文链接：工厂模式其他相关文章：设计模式 – 工厂模式欢饮转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"设计模式之单例模式","slug":"singleton-pattern","date":"2016-06-08T14:03:00.000Z","updated":"2020-01-10T17:17:01.000Z","comments":true,"path":"2016/06/08/singleton-pattern.html","link":"","permalink":"http://www.ergzcode.com/2016/06/08/singleton-pattern.html","excerpt":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。注意 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。注意 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。何时使用：当您想控制实例数目，节省系统资源的时候。如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1创建一个 Singleton 类：SingleObject.java public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(&quot;Hello World!&quot;); } }步骤 2从 singleton 类获取唯一的对象：SingletonPatternDemo.java public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }步骤 3执行程序，输出结果： Hello World!单例模式的几种实现方式单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 实例： public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 实例： public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }3、饿汉式是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 实例： public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 实例： public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }volatile关键字不能少 5、登记式/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 实例： public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }6、枚举JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 实例： public enum Singleton { INSTANCE; public void whateverMethod() { } }经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 原文链接：单例模式欢饮转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"设计模式介绍","slug":"design-pattern-intro","date":"2016-06-08T11:03:00.000Z","updated":"2020-01-10T17:22:03.479Z","comments":true,"path":"2016/06/08/design-pattern-intro.html","link":"","permalink":"http://www.ergzcode.com/2016/06/08/design-pattern-intro.html","excerpt":"介绍设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。本系列文章将通过 Java 实例，一步一步向您讲解设计模式的概念:1.设计模式之单例模式2.设计模式之工厂模式3.设计模式之抽象工厂模式4.设计模式之代理模式……更新 设计模式简介设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。","text":"介绍设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。本系列文章将通过 Java 实例，一步一步向您讲解设计模式的概念:1.设计模式之单例模式2.设计模式之工厂模式3.设计模式之抽象工厂模式4.设计模式之代理模式……更新 设计模式简介设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程 优先使用对象组合而不是继承 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 1.创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 2.结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和和定义组合对象新功能的方式 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 3.行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） 4.J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3.依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5.迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 原文链接：设计模式欢饮转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"Maven之私服nexus","slug":"maven-nexus_01","date":"2016-05-24T11:03:00.000Z","updated":"2020-01-04T11:15:23.562Z","comments":true,"path":"2016/05/24/maven-nexus_01.html","link":"","permalink":"http://www.ergzcode.com/2016/05/24/maven-nexus_01.html","excerpt":"介绍Maven仓库分为本地仓库，远程仓库（私服），中央仓库，本文主要介绍了私服的使用。 将项目发布到私服首先要把代码上传到私服上，必须要能登录到私服上，在Maven的settings.xml文件，配置连接私服的用户和密码。","text":"介绍Maven仓库分为本地仓库，远程仓库（私服），中央仓库，本文主要介绍了私服的使用。 将项目发布到私服首先要把代码上传到私服上，必须要能登录到私服上，在Maven的settings.xml文件，配置连接私服的用户和密码。 1.在Maven配置文件settings.xml的域中添加以下代码： &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;releases 连接发布版本项目仓库snapshots 连接测试版本项目仓库 2.配置项目pom.xml配置私服仓库的地址，本公司的自己的jar包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt;注意：pom.xml这里和settings.xml配置对应！ 从私服下载jar包1.在setting.xml中配置仓库 &lt;!-- 下载jar包配置 --&gt; &lt;profile&gt; &lt;!--profile的id --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库id，repositories可以配置多个仓库，保证id不重复 --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即nexus仓库组的地址 --&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载releases构件 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载snapshots构件 --&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;使用profile定义仓库需要激活才可生效 &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt;这里的activeProfile必须与上方profile的id一致 安装第三方jar包到本地仓库这里将fastjson-1.1.37.jar上传到本地仓库，有2种方式：1.进入jar包所在目录运行 mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dfile=fastjson-1.1.37.jar -Dpackaging=jar2.打开cmd直接运行 mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=C:\\Users\\TOAJMER\\Desktop\\fastjson-1.1.37.jar安装第三方jar包到私服这里将fastjson-1.1.37.jar上传到私服，在settings配置文件中添加登录私服第三方登录信息： &lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;有2种方式：1.进入jar包所在目录运行 mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=fastjson-1.1.37.jar -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty2.打开cmd直接运行 mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=C:\\Users\\TOAJMER\\Desktop\\fastjson-1.1.37.jar -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty本文链接：Maven之私服nexus欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"author":"ergz"},{"title":"应届毕业生踏入社会需要注意的几点社会经验总结","slug":"a-few-social-experience-summary-for-fresh-graduates ","date":"2016-05-22T13:54:00.000Z","updated":"2020-01-03T16:04:50.184Z","comments":true,"path":"2016/05/22/a-few-social-experience-summary-for-fresh-graduates .html","link":"","permalink":"http://www.ergzcode.com/2016/05/22/a-few-social-experience-summary-for-fresh-graduates%20.html","excerpt":"一、经历比学历重要现在一些年轻人，大学毕业后便急着考研究生，以为学历越高便越有水平，便越好找工作。其实对多数人来说，考研究生是浪费时间，说不定学的越多越无能。 当代社会的工作，多数要不了那么多知识，大学毕业的水平就足够了。大学所学的知识，十分之一也用不到。还要考研究生，实在是浪费青春。除非你是想做科学研究工作，想当物理学家、数学家，那是一定要上研究生的。不然就没有必要。尤其是学文科专业，更是没有必要上研究生。","text":"一、经历比学历重要现在一些年轻人，大学毕业后便急着考研究生，以为学历越高便越有水平，便越好找工作。其实对多数人来说，考研究生是浪费时间，说不定学的越多越无能。 当代社会的工作，多数要不了那么多知识，大学毕业的水平就足够了。大学所学的知识，十分之一也用不到。还要考研究生，实在是浪费青春。除非你是想做科学研究工作，想当物理学家、数学家，那是一定要上研究生的。不然就没有必要。尤其是学文科专业，更是没有必要上研究生。 对于非科研工作，多数是要在工作中有针对性的学习的。在工作中实际可用的专业知识很少，多数是要在工作中根据实际需要学习。由于在工作中的学习是有目的的，是可应用的，学二个月胜过在学校学一年。成效非常明显。因此人要在工作中不断学习，而不是在学校学习。 有些人想上研究生，是因为对找工作没有信心，以为学历高了，就好找工作。其实如果有三年的实际工作经验，比上研究生可能更容易找工作。上研究生有两大缺点。本来学生最缺的是工作经验和社会经验，大学刚一毕业就上研究生，不会增加工作经验，更不能锻炼社会经验。本来就因为天天上学，显得傻乎乎，再上三年学，会变得更是傻乎乎。长期呆在校园，人会没有竞争意识，看什么都很难，看什么都不顺眼。研究生毕业了，更经不起社会的摔打和磨难，只想着能留校或是在一个稳稳当当的单位工作。意志被书本磨灭，一生都不可能有闯劲。 长期上学，人会变得清高自负，而实际工作能力很差。即使研究生毕业了，也可能缺少实际工作能力。人需要的是磨练，受苦，经历各种人生的磨难，才能真正理解人，适应社会。上研究生，则是在逃避社会，受不了委屈，受不了苦，不懂世故，干什么事都会碰壁，又不能圆通的解决。我带过很多新记者，发现一个现象，研究生不如本科生，本科生不如大专生。研究生采访不到的，专科生由于人生经验丰富，能屈能伸，随机应变，反而能采访到。 有三年的时间上研究生，不如三年换六个单位积累的人生经验多。每半年换一个单位，接触一批人，三年下来，会积累很多的社会经验和人脉关系。比上研究生收获大多了。人在三十岁之前，可以尽可能多的换单位，五六年下来，你将会成为全才，为三十岁以后的发展打下基础。 再说了，现在的学校里，没有几个有实际工作经验的老师，学不到真东西，无非是多读了几本书。用不上，也没有多少实际意义。 二、会说比会做重要现在的年轻人，一般都不懂世故，不会说话。有时一句话不慎，就可能毁掉自己一生，而自己还不知道原因。记得有一位年轻人，说了一句老同志能干的事情，我也能干。结果十年时间里，没有老同志愿带他工作，也没有独立工作的机会。有的年轻人，说话比较冲，在领导批评时，爱辩解，看起来维护了面子，但领导不喜欢这样的人，对他敬而远之。 会做的不如会说的。这就是现实。年轻人总相信有水平就一定能受领导重视，其不知任何领导用人的第一原则是听话和亲近。年轻人喜欢追求个性，好张扬，老同志看不惯，无形当中被当成了另类。人的一生，要么是动手，要么是动嘴。多数人注意培养动手能力，不注意培养动嘴能力。这是一大误区。多数做管理的人，都是靠一张嘴。会不会管理，其实就是看你会不会说话。能不能做成生意，也在于你会不会说话。 三、会笑比会说重要年轻人由于心理自卑，表现上喜欢装成熟，一般不爱笑，或是笑不出。最美丽的表情是微笑，比化装品重要。会笑的人，心情好，表情好，易被人接受。你去看周围的人，会笑的人可以左右逢源，容易做事。 四、做人比做事重要年轻人一般都比较愿意多做事，做大事，但往往忽视做人。有的人性格孤避，不爱结交朋友，不爱巴结领导，不爱说讨好人的话，遇事固执己见。做了很多事，却受不到大家肯定。有的人做事不多，能力不强，却见职务在上升。没有办法，不要看不惯，社会本来就是如此，柯责没有意义，也改变不了，反倒是要多反思自己。其实是自己不会做人。 五、做早比做好重要*拒绝拖延症，想到什么就立即实施。关于oracle方面想要学习到更多必然要去一些有用的网站看看，比如IT PUB, CSDN, Chinaunix, 思庄、中国IT、CNOUG等等。 六、听话比说话重要七、心态比成绩重要有的人是一个积极的心态，乐观的心态，不管遇到什么困难、委屈，仍然会积极进取。有的人，稍吃一点亏便难以承受。有的人有了一点成绩，便要翅尾巴，结果引来嫉妒。心态决定人的一生，应当好好修练。 八、性格比水平重要多数人干不了大事，不是由于水平问题，而是性格问题。在中国的企业家当中，有一半是从部队转业的。这些人本来专业技能并不算高，为何却能做大事呢。主要是在部队经过了严格的组织纪律性训练，养成了良好的生活和工作习惯，坚韧不拔，善于协作，敢担责任，敢冒风险。而学生出身的人，多作风散慢，性格懦弱，反而干不了什么大事。 九、今天比明天重要先把今天的事做好，比构想明天的事更有意义。 来源：CSDN社区推荐欢迎转载，请注明出处！","categories":[{"name":"生活职场","slug":"生活职场","permalink":"http://www.ergzcode.com/categories/%E7%94%9F%E6%B4%BB%E8%81%8C%E5%9C%BA/"}],"tags":[],"author":"ergz"},{"title":"深入Java单例模式","slug":"design-pattern-for-singleton","date":"2016-05-22T09:11:00.000Z","updated":"2020-01-04T09:10:39.697Z","comments":true,"path":"2016/05/22/design-pattern-for-singleton.html","link":"","permalink":"http://www.ergzcode.com/2016/05/22/design-pattern-for-singleton.html","excerpt":"前言这是关于单例，我看过的，真的写的最好的一篇博文。非常的详尽，并且有浅及深 在GoF的23种设计模式中，单例模式是比较简单的一种。然而有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用生命周期中保证只有一个实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。","text":"前言这是关于单例，我看过的，真的写的最好的一篇博文。非常的详尽，并且有浅及深 在GoF的23种设计模式中，单例模式是比较简单的一种。然而有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用生命周期中保证只有一个实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 1. 最简单的实现首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给调用者。这样，调用者就可以通过这个引用使用到这个类的实例了。 public class SingletonClass { private static final SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() { return instance; } private SingletonClass() { } }如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 2. 性能优化——lazy loaded上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？为了解决这个问题，我们想到了新的解决方案： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。 我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。 3. 同步上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下： 线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！ 解决的方法也很简单，那就是加锁： public class SingletonClass { private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } }是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。 4. 又是性能上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } return instance; } private SingletonClass() { } }首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？ public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if (instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } }还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。 这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。 5. 从源头检查下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。 要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。 下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存空间，然后把指针指向这块内存，最后调用构造方法进行初始化。 下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存空间，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就使用了这个实例，程序就会出现错误了！ 6. 解决方案说了这么多，难道单例没有办法在Java中实现吗？其实不然！在JDK5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。 public class SingletonClass { private volatile static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } }然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响： public class SingletonClass { private static class SingletonClassInstance { private static final SingletonClass instance = new SingletonClass(); } public static SingletonClass getInstance() { return SingletonClassInstance.instance; } private SingletonClass() { } }在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。 由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是非并发的，所以getInstance()也并不需要加同步。 至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。 本文链接：深入Java单例模式欢迎转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"MarkdownPad2.5注册码","slug":"markdownpad2.5-license-key","date":"2016-05-15T07:25:00.000Z","updated":"2019-12-29T09:19:06.130Z","comments":true,"path":"2016/05/15/markdownpad2.5-license-key.html","link":"","permalink":"http://www.ergzcode.com/2016/05/15/markdownpad2.5-license-key.html","excerpt":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==","text":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 输入Email address和license key 注册完成 本文链接：MarkdownPad2.5注册码欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://www.ergzcode.com/tags/markdown/"}],"author":"ergz"},{"title":"阅读生活之人生赢家","slug":"read-lifes_01","date":"2016-01-04T14:05:00.000Z","updated":"2020-01-03T16:59:40.020Z","comments":true,"path":"2016/01/04/read-lifes_01.html","link":"","permalink":"http://www.ergzcode.com/2016/01/04/read-lifes_01.html","excerpt":"1、给你90天，成为不一样的自己 如果你想成功，从现在起和比自己成功的人去接触，别人的成功不是没有道理的；如果你想得到某个领域的经验，那就跨出你自己的领域去认识这个领域的人，任何方式都可以；如果你碍于面子，跨不出现有的圈子你就一直会在原地踏步；放下面子，放下偏见，放下自卑，重新认识你身边的人 2、吵架公约：把最后一句话留给对方说 不论我们正在遭遇何种困局或是挣扎，所谓的吵架如果不能避免，那最后那一句话也要留给对方说，适可而止也是人生的一种高境界，能够成全自己的幸福人生。","text":"1、给你90天，成为不一样的自己 如果你想成功，从现在起和比自己成功的人去接触，别人的成功不是没有道理的；如果你想得到某个领域的经验，那就跨出你自己的领域去认识这个领域的人，任何方式都可以；如果你碍于面子，跨不出现有的圈子你就一直会在原地踏步；放下面子，放下偏见，放下自卑，重新认识你身边的人 2、吵架公约：把最后一句话留给对方说 不论我们正在遭遇何种困局或是挣扎，所谓的吵架如果不能避免，那最后那一句话也要留给对方说，适可而止也是人生的一种高境界，能够成全自己的幸福人生。 3、做事要找靠谱的人，聪明的人只能聊聊天 这些年体会最深的是，一个靠谱的人给你介绍的朋友，合作起来就是人品好，办事靠谱的人。而一个不靠谱的人给你介绍一个朋友或者一个同事，也能碰到靠谱的，但需要你有慧眼，否则就只能碰运气。我们做事选择靠谱，是选择一种优秀的品质。一旦你靠谱的对待事情，你可能暂时受到伤害。 4、如何在这操蛋的世界里保持快乐？ 恩，本质上，快乐的技术就是烂俗的。海明威不是说了嘛，心理健康有时候就意味着庸俗。爱你所拥有的。珍惜你所拥有的。快乐不等于傻逼。我们深知世界的复杂、黑暗和荒谬，依然选择面对复杂，保持欢喜。 5、那些不声不响就把事情做了的人 你何时才能做一个不动声色的大人，取决于你拥有一颗怎样的心。树欲静则风止，这才是不动声色的境界。继续修炼吧！少年。 6、为什么以前对你好的同学现在都不理你了？ 我们不要指望别人有义务拉你一把。人家又不是你爹你妈，凭什么要惯着你啊。这个世界就是马太效应。你越牛逼，机会越多。没有什么雪中送炭，这个世界只有锦上添花。你想要锦上添花，你得先变成锦。 7、向这些教育方式说不 爱孩子要爱得其法，孩子，不仅给了我们生命最本质的活力和喜悦，也给我们一个契机，重新审视生活，自省个人的言行。带孩子，是一条和孩子共同修行的路，我们不是领他们成长，而是和他们相伴，一起成长。 8、朋友升官发财，你不必难过 所以，不必看到别人手里拿着利剑而万分焦虑，很可能你的怀里揣着枪呢。在被打得落花流水的时候想一想，你是不是比错了项目，好好摸摸自己的口袋，找到那个最让你自信的、最多人为你点赞的、最常带给你优越感的能力，那就是你的武器，掏出它来，到属于你的战场战斗吧。 9、不要一直在自己身上找原因 和人划清界限，知道哪些责任是自己的，哪些东西根本和自己无关是非常重要的。一个没有界限感的人，即便是怀着好心，最终也很有可能酿成大错。“一日三省吾身”是好，但这个“省身”也应该包括检查自己有没有过分承担。换句话说，你若一直在自己身上找原因，也是你太高估自己了。 10、听懂另一半说爱你的方式 而我也慢慢学会，不再用自己表达爱的方式去绑架他，他也和我一样，而是渐渐懂得他表达爱和责任的方式，然后默默记在日记本里，记在心里… … 11、你不是不会爱，而是怕麻烦 坚持本来就是一件极其不易的事情，即便我们能够一辈子做自己的太阳，光芒偶尔也会被雾霾遮挡，但心中有爱的人终究不会迷途，因为从未曾忘记一路上予人玫瑰，手留余香又会还你满满的正能量。 12、你永远不可能靠点赞融入那个不属于你的圈子 其次时间宝贵，年纪越大越不想徒劳消耗，有这个时间还不如去想想怎么挣钱，或者消耗在自己真心喜欢的人和事上。最后很残酷的一点，如果你自己没资本，社交也并不能给你带来什么你需要的人脉或真心的朋友。“没有平起平坐的资本，任何社交都无法换来有用的人脉。”所以不用硬融，你到了那种阶段，你会很自然被你喜欢的那群人吸纳进去。 13、等人把话说完，是一种修养 等别人把话说完是一种素质，看似絮絮叨叨的表达，身前身后却是气象万千的智慧和懂得。听别人说话，其实在渡你我到彼岸，一回头已是郁郁葱葱，繁花似锦。 14、好与不好都走了，幸与不幸都过了 有时候，珍惜，是为了更好的拥有；而放下，则是为了更好的前行。好与不好都走了，幸与不幸都过了。人生的际遇，就像那窗外的雨，淋过，湿过；散了，远了。容不得我们许与不许，便已然不再。于是，人生，便总是从告别中走向明天。将美好留于心底，淡淡的就好；将悲伤置于脑后，遗忘了最好。 15、为什么很多人工资不高，却还要拥挤在大城市生活？ 演出场地也是很多城市的标配，但是扪心自问，你一年内会在小城市看几场演出？体验是由物质和精神两个层面叠加起来的，即便配套跟一线城市完全没有区别，但生活在这个地方的人群跟你不同道，你也无法习惯。 16、岁月美人都是养出来的 天生丽质的女子凤毛麟角，绝大多数的美人儿都是后天养出来的，而且绝对要富养，经济条件的好坏并不能决定你的颜值，但精神世界的高低，却能让岁月美人从众多莺莺燕燕中脱颖而出，在水一方窈窈窕窕，孤不孤单都是一种最精彩。美人需要很多爱的供养，很多自律的修炼，很多快乐的分享，很多生活的勇气，很多纯真的执着，所以我们要一起上路，任重道远也要彼此共勉，成就做一位岁月美人的终极梦想。 17、林清玄：死在路上也是很好的事，总比没去过好 因此，我们对生命如果还有未完成的期盼，此刻就要去融入它，不要寄希望于渺茫的来生，活在一个又一个的片刻里，到死前都保有向前的姿势，只要完全融入一个纯粹天真的片刻，那也就够了。有很多人活在过去与未来的交错、预期、烦恼之中，从来没有进入过那个片刻呢！ 18、没人稀罕你做自己 中国人讲究含蓄，西方人讲究距离，没人稀罕你做自己。还不如回家照照镜子，看看对着那张熟悉的放肆面容能不能和平相处，再考虑其他。至于真正的自己，回到斗室中再做也不迟。毕竟，能容忍自己的只有自己，能原谅自己的也只有自己。 19、他没有用你理想的方式爱你，也很好 在非原则性的问题上，降低期望值，不较真儿，不偏执，懂得尊重与退让，愿意为爱妥协，才能爱得更轻松、更愉快。要相信，即使他没有用你理想的方式爱你，但只要真心依旧，其实也很好。 20、你不快乐，是因为活得不宽容 哪怕我们身边的世界再复杂再艰难，也要好好保护你内心的宽容与温柔，愿你能遇见未知的那个美好的自己，在此之前你先要对别人宽容，愿你被世界温柔相待，在此之前你先要温柔相待这个世界。生活从不会辜负那些快乐又美好的人生，你若宽容温柔，不必算计争抢，自有命运打赏。 来源：阅读时间欢迎转载，请注明出处！","categories":[{"name":"生活职场","slug":"生活职场","permalink":"http://www.ergzcode.com/categories/%E7%94%9F%E6%B4%BB%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.ergzcode.com/tags/%E7%94%9F%E6%B4%BB/"}],"author":"ergz"},{"title":"关于mysql查询缓存详解","slug":"mysql-query-cache_01","date":"2016-01-01T14:48:00.000Z","updated":"2020-01-03T17:11:23.656Z","comments":true,"path":"2016/01/01/mysql-query-cache_01.html","link":"","permalink":"http://www.ergzcode.com/2016/01/01/mysql-query-cache_01.html","excerpt":"mysql查询缓存 在sql调优的过程中，发现原本很慢的一条sql（将近1分钟）在第二次运行时，瞬间就完成了（0.04sec）。 这是因为mysql自带的缓存机制，将查询结果进行缓存，如果table数据未发生变化，再次使用同一条sql进行查询时，直接从上次的查询结果缓存中读取数据，而不是重新分析、执行sql。 如果table数据发生变化，所有与之相关的缓存数据都会被释放刷新，这样就不会出现数据脏读问题。","text":"mysql查询缓存 在sql调优的过程中，发现原本很慢的一条sql（将近1分钟）在第二次运行时，瞬间就完成了（0.04sec）。 这是因为mysql自带的缓存机制，将查询结果进行缓存，如果table数据未发生变化，再次使用同一条sql进行查询时，直接从上次的查询结果缓存中读取数据，而不是重新分析、执行sql。 如果table数据发生变化，所有与之相关的缓存数据都会被释放刷新，这样就不会出现数据脏读问题。 The query cache stores the text of a SELECT statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client. 是否使用查询缓存 为了避免缓存，可以在sql查询语句的字段前增加SQL_NO_CACHE关键字，如： 1select * from t_user; 1select SQL_NO_CACHE * from t_user; 反之，你也可以使用SQL_CACHE关键字，强制mysql从缓存中读取数据，如： 1select SQL_CACHE * from t_user; mysql还提供了一种释放全部缓存的方法: 1reset query cache; 设置查询缓存 查看是否有查询缓存： 1SHOW VARIABLES LIKE 'have_query_cache'; 注意，只要数据库拥有查询缓存功能，这个VALUE就是YES，无论查询缓存是否启用，mysql默认为启用状态。mysql查询缓存可以通过两个变量来控制：query_cache_type和query_cache_size。 querycachetype 1SHOW VARIABLES LIKE 'query_cache_type'; query_cache_type包含三种状态： 0 or OFF 此时不会从缓存中读取查询数据。 1 or ON 表示除非声明了SELECT SQL_NO_CACHE，否则都会从缓存中读取数据。 2 or DEMAND 表示所有语句都会从缓存中读取，相当于所有查询语句都使用了SELECT SQL_CACHE。 通过如下命令可以设置查询缓存状态(需要管理员权限)，执行后，需要重启mysql服务才能生效。 1SET GLOBAL query_cache_type = 1; 但是此命令会影响所有的使用此mysql服务的client。可以通过如下命令，关闭此客户端的查询缓存状态，但是同样需要重启server后才能生效。 12SET SESSION query_cache_type = OFF; SHOW VARIABLES LIKE 'query_cache_type'; querycachesize 1SHOW VARIABLES LIKE 'query_cache_size'; querycachesize表示缓存大小，默认为1M。如果设置为0，则相当于:query_cache_type=OFF，同样可通过SET GLOBAL进行设置。 SET GLOBAL query_cache_size=40000; 需要注意的是，设置的querycachesize，并不全是用于存储数据，还有约40KB的空间来维护查询缓存的结构。 本文链接：关于mysql查询缓存详解欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.ergzcode.com/tags/Mysql/"}],"author":"ergz"},{"title":"Hibernate查询Jackson序列化懒加载问题","slug":"jackson-hibernateLazyInitializer_01","date":"2015-05-26T05:51:00.000Z","updated":"2019-12-31T08:16:58.226Z","comments":true,"path":"2015/05/26/jackson-hibernateLazyInitializer_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/26/jackson-hibernateLazyInitializer_01.html","excerpt":"在Hibernate查询出数据实体类使用jackson序列化为json时,出现下面错误： org.springframework.http.converter.HttpMessageNotWritableException... ... disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS引起以上问题的主要原因就是jackson把懒加载也作为pojo进行序列化了。一般解决方法：在实体类上加上 @JsonIgnoreProperties({&quot;hibernateLazyInitializer&quot;, &quot;handler&quot;})","text":"在Hibernate查询出数据实体类使用jackson序列化为json时,出现下面错误： org.springframework.http.converter.HttpMessageNotWritableException... ... disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS引起以上问题的主要原因就是jackson把懒加载也作为pojo进行序列化了。一般解决方法：在实体类上加上 @JsonIgnoreProperties({&quot;hibernateLazyInitializer&quot;, &quot;handler&quot;}) 如果实体类中有集合属性那么将类里面所有的集合都加入到@JsonIgnoreProperties 这个方法注解是放在类定义上面的,例如:@JsonIgnorePropertiesclass A{} 如果你定义的类是这样的: class A{ private String description; private Boolean enable; private Integer createUser; private Date createTime; private Integer updateUser; private Date updateTime; private Set operations = new HashSet(0); private Set roles = new HashSet(0); private Set menus = new HashSet(0); }则把下面这句话加到类上 @JsonIgnoreProperties(value={“hibernateLazyInitializer”,”handler”,”operations”,”roles”,”menus”})注意：其中hibernateLazyInitializer，handler必须添加！ 本文链接：Hibernate查询Jackson序列化懒加载问题欢迎转载，请注明出处！","categories":[{"name":"Json","slug":"Json","permalink":"http://www.ergzcode.com/categories/Json/"}],"tags":[{"name":"jackson","slug":"jackson","permalink":"http://www.ergzcode.com/tags/jackson/"}],"author":"ergz"},{"title":"JSP中basePath作用","slug":"jsp-basePath_01","date":"2015-05-19T08:11:00.000Z","updated":"2019-12-31T08:18:11.738Z","comments":true,"path":"2015/05/19/jsp-basePath_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/19/jsp-basePath_01.html","excerpt":"","text":"通常在JSP页面中有如下代码： 1234&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\"; %&gt; 这段代码的意思是获取当前项目的路径，如：http://localhost:8080/项目名称。 在中通常有如下代码： 1&lt;base href=\"&lt;%=basePath%&gt;\"&gt; 这是设置基础路径的，basePath为变量，简单的静态网页的话你设置比如：&lt;base href=&quot;http://www.baidu.com&quot;&gt;，那你下面的href属性就会以你上面设置的值的为基准，如：&lt;a href=&quot;http://www.baidu.com/xxx.htm&quot;&gt;&lt;/a&gt;你现在就只需要写&lt;a href=&quot;xxx.htm&quot;&gt;&lt;/a&gt; 原文链接：http://lzc0088.iteye.com/blog/504015欢迎转载，请注明出处！","categories":[{"name":"前端","slug":"前端","permalink":"http://www.ergzcode.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Jsp","slug":"Jsp","permalink":"http://www.ergzcode.com/tags/Jsp/"}],"author":"ergz"},{"title":"Java备份和还原MySQL数据库","slug":"java-backup-and-recover-mysql_01","date":"2015-05-16T02:11:00.000Z","updated":"2020-01-01T02:15:21.830Z","comments":true,"path":"2015/05/16/java-backup-and-recover-mysql_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/16/java-backup-and-recover-mysql_01.html","excerpt":"使用Java代码备份和还原MySQL数据库","text":"使用Java代码备份和还原MySQL数据库 备份12345678910111213141516171819202122public static void backup(String path) throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(\"mysqldump -u root -p123456 db\"); InputStream inputStream = process.getInputStream(); InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader br = new BufferedReader(reader); String s = null; StringBuffer sb = new StringBuffer(); while ((s = br.readLine()) != null) &#123; sb.append(s + \"\\r\\n\"); &#125; s = sb.toString(); System.out.println(s); File file = new File(path); file.getParentFile().mkdirs(); FileOutputStream fileOutputStream = new FileOutputStream(file); fileOutputStream.write(s.getBytes()); fileOutputStream.close(); br.close(); reader.close(); inputStream.close(); &#125; 还原12345678910111213141516171819public static void recover(String path) throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(\"mysql -u root -p123456 --default-character-set=utf8 db\"); OutputStream outputStream = process.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(path))); String str = null; StringBuffer sb = new StringBuffer(); while ((str = br.readLine()) != null) &#123; sb.append(str + \"\\r\\n\"); &#125; str = sb.toString(); System.out.println(str); OutputStreamWriter writer = new OutputStreamWriter(outputStream, \"utf-8\"); writer.write(str); writer.flush(); outputStream.close(); br.close(); writer.close(); &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"}],"author":"ergz"},{"title":"Java中的this关键字","slug":"java-this_01","date":"2015-05-08T11:04:00.000Z","updated":"2020-01-01T02:46:10.626Z","comments":true,"path":"2015/05/08/java-this_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/08/java-this_01.html","excerpt":"","text":"主要有三点： 1.使用this调用本类的属性(this.xx) 2.使用this调用构造方法(this(),this(xx)) 3.表示当前对象的引用(谁调用就代表谁)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"}],"author":"ergz"},{"title":"Java中的final关键字","slug":"java-final_01","date":"2015-05-07T07:55:00.000Z","updated":"2019-12-31T11:10:40.509Z","comments":true,"path":"2015/05/07/java-final_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/07/java-final_01.html","excerpt":"介绍Java中的final关键字非常重要，它可以应用于类、方法以及变量。这篇文章中我将带你看看什么是final关键字？将变量，方法和类声明为final代表了什么？使用final的好处是什么？最后也有一些使用final关键字的实例。final经常和static一起使用来声明常量，你也会看到final是如何改善应用性能的。 final关键字的含义?final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。","text":"介绍Java中的final关键字非常重要，它可以应用于类、方法以及变量。这篇文章中我将带你看看什么是final关键字？将变量，方法和类声明为final代表了什么？使用final的好处是什么？最后也有一些使用final关键字的实例。final经常和static一起使用来声明常量，你也会看到final是如何改善应用性能的。 final关键字的含义?final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。 什么是final变量？凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。下面是final变量的例子： public static final String LOAN = &quot;loan&quot;; LOAN = new String(&quot;loan&quot;) //invalid compilation errorfinal变量是只读的。 什么是final方法?final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。下面是final方法的例子： class PersonalLoan{ public final String getName(){ return &quot;personal loan&quot;; } } class CheapPersonalLoan extends PersonalLoan{ @Override public final String getName(){ //compilation error: overridden method is final return &quot;cheap personal loan&quot;; } }什么是final类？使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。下面是final类的实例： final class PersonalLoan{ } //compilation error: cannot inherit from final class class CheapPersonalLoan extends PersonalLoan{ }final关键字的好处下面总结了一些使用final关键字的好处 final关键字提高了性能。JVM和Java应用都会缓存final变量 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销 使用final关键字，JVM会对方法、变量及类进行优化 不可变类创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。 关于final的重要知识点 final关键字可以用于成员变量、本地变量（局部变量）、方法以及类 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误 不能够对final变量再次赋值 局部变量必须在声明时赋值 在匿名类中使用的所有外部变量都必须是final变量（*） final方法不能被重写 final类不能被继承 final关键字不同于finally关键字，后者用于异常处理 final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法 接口中声明的所有变量本身是final的（*） final和abstract这两个关键字是反相关的，final类就不可能是abstract的 final方法在编译阶段绑定，称为静态绑定(static binding) 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化” 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化 按照Java代码惯例，final变量就是常量，而且通常常量名要大写： private final int COUNT = 10; 对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容，譬如： private final List Loans = new ArrayList(); list.add(“home loan”); //valid list.add(“personal loan”); //valid loans = new Vector(); //not valid 我们已经知道final变量、final方法以及final类是什么了。必要的时候使用final，能写出更快、更好的代码的。 本文链接：Java中的final关键字欢迎转载，请注明出处！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"}]}
{"meta":{"title":"ergzC0de","subtitle":"代码也是一种艺术","description":"Java,Python,编程","author":"ergz","url":"http://www.ergzcode.com","root":"/"},"pages":[{"title":"本站声明","date":"2019-12-25T07:44:11.000Z","updated":"2019-12-25T07:44:29.658Z","comments":true,"path":"about/me.html","permalink":"http://www.ergzcode.com/about/me.html","excerpt":"","text":"本站仅提供了一个技术交流的平台，没有任何商业盈利的行为。除了原创文章外，从网络上转载的文章或搜集的一些资源在文末都有出处说明，若您认为本站资源侵犯了您的版权，请联系站长删除。 邮箱：itoajm@163.com扣扣：921936477(备注说明来意)微信：wxw0220(备注说明来意)"}],"posts":[{"title":"最新IDEA永久激活","slug":"idea-latest-active","date":"2019-12-25T12:26:00.000Z","updated":"2019-12-26T01:38:19.186Z","comments":true,"path":"2019/12/25/idea-latest-active.html","link":"","permalink":"http://www.ergzcode.com/2019/12/25/idea-latest-active.html","excerpt":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar","text":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar -Xms512m -Xmx2048m -XX:ReservedCodeCacheSize=480m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot; -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true -javaagent:C:\\Program Files\\JetBrains\\ideaIU 2019.2.3\\bin\\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况，这时候可以删除用户配置目录下的IDEA文件夹: windwos：C:\\Users\\用户名\\ macos：~/Library/Preferences/ ubuntu：~/. 修改完配置文件之后重启IDEA 3.输入激活码重启IDEA之后，点击菜单栏中的 ‘Help ’-&gt; ‘Register…’，这里有两种激活方式： 一.选择最后一种License server激活方式，地址填入：http://jetbrains-license-server ,或者点击按钮：‘Discover Server’来自动填充地址，完成激活。 二.如果服务器激活方式无法激活，还可以选择Activation code方式激活，激活码下载:激活码.txt，下载复制激活码填入，点击OK即可。 服务器激活是没有期限的，是永久有效。激活码激活的有效期到2089年。 本文链接：最新IDEA永久激活欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.ergzcode.com/tags/IDEA/"}],"author":"ergz"},{"title":"Nginx反向代理实现二级域名与端口的映射","slug":"nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports","date":"2019-12-14T09:27:00.000Z","updated":"2019-12-18T14:03:57.775Z","comments":true,"path":"2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","link":"","permalink":"http://www.ergzcode.com/2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","excerpt":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。","text":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。 现在需要做到以下两点： 将http://www.ergzcode.com的请求转发给4000端口下的应用程序，也就是通过这种URL访问本站 将http://cdn.ergzcode.com的请求转发给8080端口下的http文件服务器 当然在这之前，有个前提就是你需要让cdn.ergzcode.com和www.ergzcode.com这两个域名解析到你的服务器IP上，DNS解析在域名提供商那里作处理,这里不再介绍 现在要做到上面的请求转发，就要用到Nginx的反向代理机制，下面来创建Nginx的配置文件，在/etc/nginx/conf.d目录下创建一个叫做reverse_proxy.conf的文件，文件名可以随意指定，但要以.conf为后缀名，然后加入下面的内容 1234567891011121314151617181920212223242526server&#123; listen 80;#监听端口 server_name www.ergzcode.com;#根据域名跳转 location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:4000;#跳转的路径 &#125;&#125;server&#123; listen 80; server_name cdn.ergzcode.com; #root /usr/local/data/file; location / &#123; # try_files $uri $uri/ =404; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080;#跳转的路径 &#125;&#125; 执行命令使修改配置生效/etc/init.d/nginx reload 访问本站：http://www.ergzcode.com访问HTTP服务器：http://cdn.ergzcode.com完成！！ 本文链接：Nginx反向代理实现二级域名与端口的映射欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"开发中常用的一些免费API","slug":"some-common-and-free-apis-for-developing","date":"2019-12-11T10:20:00.000Z","updated":"2019-12-18T15:42:20.840Z","comments":true,"path":"2019/12/11/some-common-and-free-apis-for-developing.html","link":"","permalink":"http://www.ergzcode.com/2019/12/11/some-common-and-free-apis-for-developing.html","excerpt":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址","text":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址数字识别(可在线调用):对图像中的阿拉伯数字进行识别提取，适用于…——接口地址通用文字识别(可在线调用):支持多场景下的文字检测识别，多项ICDA…——接口地址网络图片文字识别(可在线调用):能够快速准确识别各种网络图片中的文字，在…——接口地址身份证识别(可在线调用):支持对二代居民身份证正反面的关键字段识别…——接口地址银行卡识别(可在线调用):支持对主流银行卡卡号识别，并返回发卡行和…——接口地址驾驶证识别(可在线调用):支持对机动车驾驶证正页的关键字段识别，包…——接口地址行驶证识别(可在线调用):支持对机动车行驶证正页的关键字段识别，包…——接口地址手写文字识别(可在线调用):能够对手写汉字和手写数字进行识别——接口地址增值税发票识别(可在线调用):识别并结构化返回增值税发票的各个字段及其…——接口地址营业执照识别(可在线调用):支持对营业执照关键字段的识别，包括单位名…——接口地址车牌识别(可在线调用):支持对中国大陆机动车车牌的识别，包括地域…——接口地址票据识别(可在线调用):支持对增值税发票、火车票、出租车票（支持…——接口地址表格文字识别:自动识别表格线及表格内容，结构化输出表头…——接口地址通用物体和场景识别(可在线调用):支持超过10万类物体和场景识别，接口返回…——接口地址图像主体检测(可在线调用):检测图片中关键主体位置，接口支持检测单张…——接口地址品牌logo识别(可在线调用):实现2万类品牌logo识别，接口返回品牌…——接口地址植物识别(可在线调用):植物识别支持2万多种通用植物识别、近…——接口地址动物识别(可在线调用):支持数千种动物识别，接口返回名称——接口地址菜品识别(可在线调用):识别超过5万个菜品，接口返回菜品的名称、…——接口地址地标识别(可在线调用):支持识别约5万中外著名地标、景点，接口返…——接口地址车型识别(可在线调用):识别车辆的具体车型，以小汽车为主，输出图…——接口地址车辆检测:识别图像中所有机动车辆的类型和位置，并对…——接口地址GIF色情图像识别(可在线调用):人工智能鉴黄技术，智能识别图片和视频中的…——接口地址图像审核(可在线调用):通过人脸检测、文字识别、色情识别、暴恐识…——接口地址人脸检测与属性分析(可在线调用):检测图中的人脸，并为人脸标记出边框。检测…——接口地址在线活体检测(可在线调用):提供在线方式的人脸活体检测能力，在人脸识…——接口地址人体关键点识别(可在线调用):检测人体并返回人体矩形框位置，精准定位1…——接口地址人流量统计(可在线调用):统计图像中的人体个数和流动趋势，以头肩为…——接口地址人体检测与属性识别(可在线调用):检测图像中的所有人体，识别人体的20类属…——接口地址手势识别(可在线调用):识别图片中的手部位置和手势类型，可识别2…——接口地址人像分割(可在线调用):识别图像中的人体轮廓，与背景进行分离——接口地址驾驶行为分析(可在线调用):针对车载场景，识别驾驶员使用手机、抽烟、…——接口地址词法分析(可在线调用):基于大数据和用户行为的分词、词性标注、命…——接口地址词向量表示(可在线调用):词向量计算是通过训练的方法，将语言词表中…——接口地址词义相似度(可在线调用):用于计算两个给定词语的语义相似度，基于自…——接口地址依存句法分析(可在线调用):利用句子中词与词之间的依存关系来表示词语…——接口地址DNN语言模型(可在线调用):语言模型是通过计算给定词组成的句子的概率…——接口地址短文本相似度(可在线调用):短文本相似度计算服务能够提供不同短文本之…——接口地址文本纠错(可在线调用):文本纠错支持短文本、长文本、语音识别结果…——接口地址情感倾向分析(可在线调用):针对带有主观描述的中文文本，可自动判断该…——接口地址评论观点抽取(可在线调用):自动分析评论关注点和评论观点，并输出评论…——接口地址对话情绪识别(可在线调用):针对一段对话文本，自动识别出当前会话者所…——接口地址文章标签(可在线调用):文章标签服务对文章的标题和内容进行深度分…——接口地址文章分类(可在线调用):文章分类服务对文章内容进行深度分析，输出…——接口地址新闻摘要(可在线调用):基于深度语义分析模型，自动抽取新闻文本中…——接口地址通用翻译(可在线调用):支持28种语言实时互译，覆盖中、英、日、…——接口地址实体标注(可在线调用):结合上下文，识别文本中的实体并将其关联到…——接口地址新闻头条(可在线调用):最新新闻头条，各类社会、国内、国际、体育…——接口地址手机号码归属地(可在线调用):根据手机号码或手机号码的前7位，查询手机…——接口地址彩票开奖结果查询(可在线调用):目前支持双色球、大乐透、七乐彩、七星彩、…——接口地址天气预报(可在线调用):查询天气情况：温度、湿度、AQI、天气、…——接口地址二维码生成(可在线调用):按照设定的参数、生成二维码——接口地址汇率(可在线调用):外汇报价，货币汇率——接口地址历史上的今天(可在线调用):回顾历史的长河，历史是生活的一面镜子——接口地址成语词典(可在线调用):新华字典在线查字,最新最全——接口地址新华字典(可在线调用):最大最全的新华汉语词典，按拼音查、按部首…——接口地址微信精选(可在线调用):微信精选文章——接口地址笑话大全(可在线调用):搜集网络幽默、搞笑、内涵段子，不间断更新——接口地址全国WIFI(可在线调用):全国免费的WIFI热点分布——接口地址货币汇率(可在线调用):支持人民币牌价、外汇汇率查询；数据仅供参…——接口地址手机固话来电显示:查询手机/固话号码归属地，是否诈骗、营销…——接口地址简/繁/火星字体转换(可在线调用):实现简体、繁体、火星文之间的转换,转换字…——接口地址全国邮编查询(可在线调用):提供全国邮政编码大全,为你快速准确查邮编——接口地址老黄历(可在线调用):提供老黄历查询,黄历每日吉凶宜忌查询——接口地址周公解梦(可在线调用):周公解梦,周公解梦大全,周公解梦查询，免…——接口地址净值数据(可在线调用):根据基金类型及分页参数来获取数据(开放式…——接口地址星座运势(可在线调用):十二星座每日、每月、每年运势——接口地址图书电商数据(可在线调用):于万千之中选择你所爱–好书推荐，值得你…——接口地址身份证查询(可在线调用):身份证归属地信息查询——接口地址黄金数据(可在线调用):黄金品种、最新价、开盘价、最高价等信息——接口地址IP地址(可在线调用):根据查询的IP地址或者域名，查询该IP所…——接口地址笑话大全——文字(可在线调用):每小时更新。文字笑话大全，信息搜集整理于…——接口地址笑话大全——图片(可在线调用):每小时更新。图片笑话大全，信息搜集整理于…——接口地址最新新闻:新闻API接口 官方自营 会员接口…——接口地址美图大全:根据几十个种类获取图片列表，每日更新。种…——接口地址手机归属地查询:最全、最新的手机号段数据库。本地找不到的…——接口地址历史上的今天:回顾历史的长河,历史是生活的一面镜子;历…——接口地址来福岛笑话——图片:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址来福岛笑话——文字:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址全国景点查询:全国景点查询接口（来自同程网的合作数据）…——接口地址健康知识:根据养生、用药、两性等频道内容获取健康知…——接口地址猜一猜:随机返回谜语，有2.5万谜语，每日更新。…——接口地址身份证查询:可根据身份证号，查询其签发地、生日、性别…——接口地址爱飞天气插件:爱飞天气是ShowAPI官方天气接口的一…——接口地址PM2.5空气质量指数:本接口每小时更新1次。空气质量指数提供实…——接口地址全球IP地址查询:全球IP地址——接口地址域名查询:域名查询地理位置——接口地址汉字转拼音:将汉字转换为拼音和拼音首字母缩写——接口地址中文分词:中文分词接口。将长段中文切词分开。使用场…——接口地址图片验证码生成:图形|图片验证码生成，支持自定义高宽，文…——接口地址新闻、网页正文抽取:传入一个新网或网页地址，接口将返回此ur…——接口地址实时IP代理查询:代理数量并不是越多越好，可以用才是真正的…——接口地址今日油价:今日油价，可查询全国31个省的油价。每天…——接口地址QQ号码测凶吉:输入qq号码，得到此号码的算命情况，例如…——接口地址地址转换经纬度:根据城市和名称转换为相应的经纬度——接口地址经纬度转换地址:根据经纬度转换成相应地址——接口地址黄历运势:根据输入日期，查看某一天的黄历运势——接口地址十大银行实时汇率:包括工商银行、中国银行、农业银行、交通银…——接口地址汇率转换:1分钟更新1次。当前十大银行，包括工商银…——接口地址添加图片水印:传入底板图及水印图，根据位置参数，接口把…——接口地址图像裁剪:裁剪原图的部份区域——接口地址生成缩略图:根据传入的比率将原图生成缩略图——接口地址星座运势:每天1点、7点、17点更新。包含十二星座…——接口地址PDF文件正文抽取:抽取PDF文件中的文字信息——接口地址网络搜索热词排行:每2小时更新一次。根据分类查询网络最热的…——接口地址二维码识别:根据图片的Base64信息,识别图片中的…——接口地址二维码生成:生成二维码图片 图片存放在showapi…——接口地址中文文本相似度检测:通过计算向量间的夹角（余弦公式），来判断…——接口地址全国火车票查询:数据来源于12306。 包括城市列表\\列…——接口地址药品查询:药品信息——接口地址菜谱大全:本菜谱的信息来源于网络,所以本信息仅用于…——接口地址台风最新坐标轨迹:可查询当前存在威胁的台风列表，每个台风的…——接口地址网页级别查询:google的pr查询——接口地址关键词抽取:根据传入的大段文字，使用TextRank…——接口地址全国行政区划分:最新最全的全国省、市、区县、乡镇的分级查…——接口地址微信小程序查询:搜索查询已经上架的微信小程序。包括基本信…——接口地址生成文章摘要:根据传入的长篇文章，系统使用智能算法抽取…——接口地址藏头诗生成:藏头诗生成器。可输入人名生成藏头、藏尾、…——接口地址国际原油价格查询:WTI和布伦特的油价查询——接口地址水质查询:根据地点和时间查询水质——接口地址条码生成:提供EAN_8、EAN_13、CODE_…——接口地址条码识别:提供EAN_8、EAN_13、CODE_…——接口地址全国站点换乘线路查询:提供全国站点换乘线路查询——接口地址全国公交换乘查询:提供全国公交换乘查询——接口地址汽车品牌查询:收录了近200个品牌/子品牌,上万辆车型…——接口地址周公解梦:根据周公解梦全书提供相关信息——接口地址正能量新闻:社会正能量的新闻资讯，每天更新——接口地址全国酒店查询:该接口所返回的所有图片链接将在12小时内…——接口地址经典语句:根据名人，查询经典名言——接口地址商品比价:搜索商品，根据商品url搜索各大商城的历…——接口地址姓名打分:根据姓名，返回此姓名的运势得分——接口地址公司名测吉凶:根据公司名，返回此公司的运势得分——接口地址车牌号测吉凶:根据车牌名，返回此车牌号的运势得分——接口地址手机号测吉凶:根据手机号码，返回此号码的运势得分——接口地址图书ISBN查询:通过国际图书号查询图书相关信息，目前只支…——接口地址影讯查询:影讯查询——接口地址手机套餐售价:全国手机流量充值，4G流量，当月有效——接口地址紫微斗数:根据出生时间定紫薇斗数命盘，供命理研究，…——接口地址唐诗宋词元曲等诗词查询:根据朝代Id或诗人名称查询诗人信息——接口地址脑筋急转弯:查询常见的脑筋急转弯金句——接口地址虚拟数字币|比特币行情:查询主流虚拟货币实时行情，例如btc(比…——接口地址全国房产信息:搜索最新楼盘开盘信息、最新市场房价信息——接口地址手游排行榜:手游最热排行榜及最期待榜——接口地址网游排行榜:网游最热排行榜及最期待榜——接口地址黄金行情:上金所黄金行情——接口地址电商淘宝平台联想词:提供淘宝联想词查询——接口地址中文反义词:中文反义词——接口地址中文近义词:中文近义词——接口地址歇后语查询:查询歇后语列表——接口地址中国互联网络信息:中国互联网络信息——接口地址实时票房排行:实时票房中国（包括香港）、北美、全球票房…——接口地址爱奇艺热点趋势:爱奇艺视频指数——接口地址空气质量指数(可在线调用):空气质量指数提供实时空气质量情况，目前支…——接口地址IP地址查询(可在线调用):提供rest风格的IP地址查询接口，只需…——接口地址天气预报(可在线调用):全国天气预报，预报7天天气，以及当天的生…——接口地址人脸识别(可在线调用):检测图片(Image)中的人脸(Face…——接口地址指纹识别:检测图片(Image)中的指纹(Fing…——接口地址医疗科室(可在线调用):医药健康接口专用的医疗科室字典项获取——接口地址健康菜谱(可在线调用):健康菜谱，让人们在宣泄的都市中体验在家常…——接口地址疾病信息(可在线调用):通过名称取得疾病详情——接口地址药品查询(可在线调用):通过药品名字直接得到药品说明书、价格、生…——接口地址食疗大全(可在线调用):通过名称取得食品详情只要是食品都有它…——接口地址手术项目(可在线调用):通过名称取得手术详情通过名称取得手术…——接口地址药房药店(可在线调用):通过名称取得药店信息通过名称取得药店…——接口地址病状信息(可在线调用):通过名称取得病状详情——接口地址微信精选(可在线调用):微信热门精选文章，实时更新——接口地址国内新闻(可在线调用):国内新闻数据，实时更新——接口地址国际新闻(可在线调用):国际新闻数据，实时更新——接口地址体育新闻(可在线调用):体育新闻数据，实时更新——接口地址科技新闻(可在线调用):科技新闻数据，实时更新——接口地址奇闻轶事(可在线调用):奇闻轶事数据，实时更新——接口地址旅游新闻(可在线调用):旅游热点数据，实时更新——接口地址新华字典(可在线调用):新华字典数据库，可查字的拼音、读音、偏旁…——接口地址五笔字根(可在线调用):查询汉字的五笔字根——接口地址简繁体火星文转换(可在线调用):汉字的简体、繁体、火星文转换——接口地址成语词典(可在线调用):成语查询——接口地址歇后语(可在线调用):歇后语查询，根据关键字搜索歇后语——接口地址唐诗宋词(可在线调用):根据关键字搜索唐诗宋词——接口地址历史上的今天(可在线调用):以史为镜，可以知兴替。借历史上的成败得失…——接口地址辞海(可在线调用):查询词语解释——接口地址手机号码归属地(可在线调用):通过手机号码查询归属地、运营商、号码类型…——接口地址笑话大全(可在线调用):海量互联网幽默、内涵段子、趣味图片，不间…——接口地址同义词:通过输入的词语查询对应的同义词——接口地址全国WIFI(可在线调用):查询周边免费WIFI热点；全国免费WIF…——接口地址NBA赛事(可在线调用):NBA赛事赛程信息，球队赛程赛事查询——接口地址全国邮编查询(可在线调用):通过地名查询地区邮编，精确到街道——接口地址周公解梦(可在线调用):周公解梦大全——接口地址名人名言(可在线调用):通过关键字查询名人名言——接口地址今日油价(可在线调用):可查询全国31个省的油价——接口地址国际白银实时价格:国际交易市场白银实时价格(美元/盎司)，…——接口地址时事新闻检索(可在线调用):时事新闻，新闻检索等，实时更新——接口地址号码吉凶(可在线调用):手机号码、QQ号码、车牌号等所有数字类型…——接口地址金额小写转大写(可在线调用):人民币金额小写转大写——接口地址电影票房(可在线调用):最新票房榜，网票票房——接口地址全国长途汽车(可在线调用):全国长途汽车时刻表查询——接口地址足球联赛(可在线调用):目前支持 英超，西甲，德甲，意甲，法甲，…——接口地址影视影讯(可在线调用):影视信息播放链接检索，城市影讯检索——接口地址标准电码查询(可在线调用):提供的标准中文电码查询程序结果——接口地址火车时刻表(可在线调用):火车时刻表，站到站检索——接口地址姓氏起源(可在线调用):《百家姓》是我国汉族姓氏总集，载有四百多…——接口地址短链接生成(可在线调用):查找网提供长的网址链接缩短为新浪短网扯，…——接口地址翻译(可在线调用):翻译API提供免费开放接口，覆盖中、英、…——接口地址乌云漏洞(可在线调用):查看乌云最新的安全漏洞——接口地址微信公众号查询(可在线调用):根据关键字搜索热门微信文章、微信公众号等…——接口地址在线分词(可在线调用):基于深度学习的中文在线抽词——接口地址MD5破解(可在线调用):md5密文：16位，32位,sha1(4…——接口地址星座配对(可在线调用):星座配对测姻缘——接口地址生肖配对(可在线调用):生肖配对测姻缘——接口地址获取外网IP信息(可在线调用):取得客户端访问互联网时的外网ip及对应的…——接口地址百度权重(可在线调用):根据网址查询百度权重——接口地址新闻头条(可在线调用):最新新闻头条——接口地址星座运势(可在线调用):黄道十二星座每日、每月、每年运势、不间断…——接口地址 2019.7.3更新接口 实时段子(可在线调用):实时段子,神评版本——接口地址音乐搜索(可在线调用):根据音乐名称返回音乐详情——接口地址小说查询(可在线调用):获取小说的详细信息——接口地址天气查询(可在线调用):获取最近天气情况——接口地址音悦tai搜索:音悦Tai-是以高清MV为主的娱乐视频网…——接口地址识别身份证文字(可在线调用):AI人工智能识别身份证图像文字 URL图…——接口地址编码解码:常见的编码和解码——接口地址网站备案查询:网站备案信息查询接口——接口地址身份证信息查询(可在线调用):身份证信息查询(不支持查询百岁老人)——接口地址图片PS:在线图片加文字,返回为字符串,需要处理下——接口地址一言:随机返回一句话——接口地址短链接生成与还原:短链接生成与还原，包括新浪、腾讯、百度——接口地址获取用户大致信息:获取用户信息如网络运营商等等——接口地址三合一收款码:包括支付宝，qq，微信——接口地址IP查询:根据ip地址获取其所在省市区——接口地址IP经纬度查询:根据ip地址和经纬度获取其所在省市区——接口地址 2019.8.7更新接口 淘宝ip(可在线调用):来自淘宝的ip查询，可以根据ip地址查询…——接口地址360ip(可在线调用):来自360的ip查询，可以根据ip地址查…——接口地址地理编码(可在线调用):将详细的结构化地址转换为高德经纬度坐标。…——接口地址逆地理编码(可在线调用):将经纬度转换为详细结构化的地址，且返回附…——接口地址步行路径规划:可以规划100KM以内的步行通勤方案，并…——接口地址驾车路径规划(可在线调用):规划以小客车、轿车通勤出行的方案，并且返…——接口地址公交路径规划:规划综合各类公共（火车、公交、地铁）交通…——接口地址骑行路径规划(可在线调用):用于规划骑行通勤方案，规划时不会考虑路况…——接口地址距离测量:根据经纬度测量距离——接口地址行政区域查询(可在线调用):根据用户输入的搜索条件可以帮助用户快速的…——接口地址矩形区域交通态势:能够确定矩形交通态势情况，路况信息2分钟…——接口地址圆形区域交通态势:能够确定圆形交通态势情况，路况信息2分钟…——接口地址指定线路交通态势:能够确定指定线路交通情况，路况信息2分钟…——接口地址输入提示(可在线调用):提供根据用户输入的关键词查询返回建议列表——接口地址天气查询(可在线调用):查询目标区域当前/未来的天气情况——接口地址IP定位(可在线调用):将IP信息转换为地理位置信息——接口地址地点范围查询(可在线调用):根据经纬度查询查询其地址相关信息——接口地址 2019.9.9更新接口 行政区划区域检索(可在线调用):开发者可通过该功能，检索某一行政区划内（…——接口地址圆形区域检索(可在线调用):开发者可设置圆心和半径，检索圆形区域内的…——接口地址矩形区域检索(可在线调用):开发者可设置检索区域左下角和右上角坐标，…——接口地址地点详情检索(可在线调用):地点详情检索针对指定POI，检索其相关的…——接口地址地点输入提示(可在线调用):用户可通过该服务，匹配用户输入关键词的地…——接口地址地理编码服务(可在线调用):用户可通过该功能，将结构化地址（省/市/…——接口地址全球逆地理编码(可在线调用):用户可通过该功能，将位置坐标解析成对应的…——接口地址公交路线规划(可在线调用):根据起点和终点检索符合条件的公共交通方案…——接口地址骑行路线规划(可在线调用):根据起终点坐标检索符合条件的骑行路线规划…——接口地址驾车路线规划(可在线调用):根据起终点坐标检索符合条件的驾车路线规划…——接口地址批量算路:用户可通过该服务，根据起点和终点坐标计算…——接口地址普通IP定位(可在线调用):用户可以通过该服务，根据IP定位来获取大…——接口地址道路实时路况查询(可在线调用):查询具体道路的实时拥堵评价和拥堵路段、拥…——接口地址时间偏移查询(可在线调用):查询坐标所在地与协调世界时的时间偏移信息…——接口地址周边上车点推荐(可在线调用):用户可通过该功能检索坐标点周围的上车点。…——接口地址非百度坐标系转换(可在线调用):用户可通过该服务，实现 非百度坐标系→百…——接口地址快递查询(可在线调用):可根据快递单号查询大部分主流快递的快递信…——接口地址文件转换:文件转换成指定格式，成功则返回成功转换的…——接口地址获取文件转换内容:根据文件转换成功所获取的id，查询转换成…——接口地址 2019.10.8更新接口 全球IP地理位置(可在线调用):单个IPv4 / IPv6地址或域名…——接口地址域名备案(可在线调用):根据域名查询域名备案状态——接口地址十五天天气预报:采用城市ID来精准查询15天内的天气，接…——接口地址农历查询(可在线调用):根据日期获取农历、黄历、禁忌、星期、生肖…——接口地址ICP备案查询(可在线调用):根据域名查询ICP备案号——接口地址三合一收款二维码:将QQ、微信、支付宝收款集合到一起，省去…——接口地址二维码生成:将网址直接转换成二维码图片——接口地址二维码解码(可在线调用):将二维码图片进行解码，解析处理——接口地址短网址生成(可在线调用):将长网址进行缩短，支持百度、新浪、腾讯短…——接口地址短网址还原(可在线调用):将缩短的短网址进行还原,支持常见的短网址——接口地址网易云音乐随机歌曲(可在线调用):网易云音乐，随机歌曲输出——接口地址获取访客相关信息(可在线调用):根据访客IP地址，操作系统，浏览器，访问…——接口地址随机头像输出(可在线调用):随机头像输出——接口地址 2019.11.5更新接口 文章短篇:根据日期获取一篇文章，有网上的，也有名家…——接口地址必应故事:随机获取来自必应的故事，可根据pid获取…——接口地址每日一言:获取来自一言、有道或金山词霸的每日一言内…——接口地址二维码解析:还原二维码的原始URL，支持支付宝，微信…——接口地址生成海报:根据提交的内容格式化生成可分享的精美海报——接口地址历史上的今天:历史上的今天——接口地址生成二维码:可根据传入的内容，生成对应的二维码，还可…——接口地址IP地址详情信息:IP地址详情信息查询——接口地址XLS生成:生成XLS——接口地址土味情话:和妹妹说的情话，返回一句随机的内容——接口地址随机笑话(可在线调用):随机的笑话——接口地址 2019.12.4更新接口 经纬度信息(可在线调用):获取当前经纬度信息——接口地址历史上的今天(可在线调用):历史上的今天——接口地址Bing 壁纸获取(可在线调用):获取最近的Bing 壁纸——接口地址天气查询(可在线调用):获取今天和未来三天的天气情况，来源于高德——接口地址天气查询(可在线调用):根据城市名，获取今天和未来三天的天气情况…——接口地址天气查询(可在线调用):根据城市id，获取未来15天的天气情况，…——接口地址手机归属地查询(可在线调用):根据手机号码查询手机号的归属地信息——接口地址手机归属地查询:根据手机号码查询手机号的归属地信息，来源…——接口地址IP域名归属地查询(可在线调用):查询IP或者域名归属地——接口地址身份证查询(可在线调用):根据身份证获取该身份证号码的籍贯，出生年…——接口地址淘宝关键字(可在线调用):淘宝搜索关键字——接口地址百度关键字:百度搜索关键字——接口地址Bing关键字(可在线调用):Bing搜索关键字——接口地址获取用户设备信息(可在线调用):通过 user-agent 分析用户设备…——接口地址百度音乐搜索(可在线调用):根据关键字获取音乐的相关信息——接口地址 努力添加中…… 原文链接：https://github.com/fangzesheng/free-api欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"API","slug":"API","permalink":"http://www.ergzcode.com/tags/API/"}],"author":"ergz"},{"title":"PM2介绍","slug":"pm2-common-commands-introduction","date":"2019-12-10T03:22:00.000Z","updated":"2019-12-26T14:44:30.513Z","comments":true,"path":"2019/12/10/pm2-common-commands-introduction.html","link":"","permalink":"http://www.ergzcode.com/2019/12/10/pm2-common-commands-introduction.html","excerpt":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 )","text":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 ) 安装1npm install -g pm2 #命令行安装pm2 用法123456789101112131415161718192021222324252627282930pm2 start app.js -i 4 #后台运行pm2，启动4个app.jspm2 start app.js --name my-api #命名进程pm2 list #显示所有进程状态pm2 monit #监视所有进程pm2 logs #显示所有进程日志pm2 stop all #停止所有进程pm2 restart all #重启所有进程pm2 reload all #0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0 #停止指定的进程pm2 restart 0 #重启指定的进程pm2 startup #产生 init 脚本 保持进程活着pm2 web #运行健壮的 computer API endpointpm2 delete 0 #杀死指定的进程pm2 delete all #杀死全部进程运行进程的不同方式：pm2 start app.js -i max #根据有效CPU数目启动最大进程数目pm2 start app.js -i 3 #启动3个进程pm2 start app.js -x #用fork模式启动 app.js 而不是使用 clusterpm2 start app.js -x -- -a 23 #用fork模式启动 app.js 并且传递参数 (-a 23)pm2 start app.js --name serverone #启动一个进程并把它命名为 serveronepm2 stop serverone #停止serverone进程pm2 start app.json #启动进程, 在app.json里设置选项pm2 start app.js -i max -- -a 23 #在--之后给app.js传递参数pm2 start app.js -i max -e err.log -o out.log #启动 并生成一个配置文件你也可以执行用其他语言编写的app ( fork 模式):pm2 start my-bash-script.sh -x --interpreter bashpm2 start my-python-script.py -x --interpreter pythonpm2 list #列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次pm2 monit #监视每个node进程的CPU和内存的使用情况。 本文链接：PM2介绍欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"}],"author":"ergz"},{"title":"PM2守护hexo的进程","slug":"pm2-watch-hexo-process","date":"2019-12-08T00:01:00.000Z","updated":"2019-12-26T14:44:49.661Z","comments":true,"path":"2019/12/08/pm2-watch-hexo-process.html","link":"","permalink":"http://www.ergzcode.com/2019/12/08/pm2-watch-hexo-process.html","excerpt":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2","text":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2 2.写一个shell hexo_daemon.js12345678910//runconst &#123; exec &#125; = require('child_process')exec('hexo server -p 80 &amp; ',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 3.在根目录下执行shell1pm2 start hexo_daemon.js 本文链接：PM2守护hexo的进程欢迎转载，请注明出处！参考:PM2使用","categories":[{"name":"shell","slug":"shell","permalink":"http://www.ergzcode.com/categories/shell/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.ergzcode.com/tags/hexo/"}],"author":"ergz"},{"title":"Git常用命令使用","slug":"git-common-commands-using","date":"2019-11-26T11:26:00.000Z","updated":"2019-12-18T14:08:32.342Z","comments":true,"path":"2019/11/26/git-common-commands-using.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-common-commands-using.html","excerpt":"1.查看工作区的状态：git status 2.查看文件具体修改了什么内容：git diff file 3.查看提交的历史记录，该命令显示从最近到最远的历史记录：git log，如果嫌输出信息太多，可以试试加上--pretty=oneline参数：git log --graph --pretty=oneline --abbrev-commit，命令如下： 123git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示","text":"1.查看工作区的状态：git status 2.查看文件具体修改了什么内容：git diff file 3.查看提交的历史记录，该命令显示从最近到最远的历史记录：git log，如果嫌输出信息太多，可以试试加上--pretty=oneline参数：git log --graph --pretty=oneline --abbrev-commit，命令如下： 123git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示 4.git reset该命令用来回退到某个版本，在git中用HEAD表示当前版本，HEAD^表示上个版本，HEAD^^表示上上版本……以此类推，HEAD~100表示往上100个版本现在我们用命令回退到上个版本： 12git reset --hard HEAD^HEAD is now at 1f2508 可以根据版本号commit id指定回退到某个版本：git reset --hard eede19这里的版本号没必要写全，前几位就可以了，Git会自动去找，这样我们就又回到最新的版本了。Git版本的回退速度非常快，在Git内部有个指向当前版本的指针HEAD，所以我们在进行版本回退或回到最新的版本的时候，Git只是帮我们将HEAD指针指向某个版本号。 5.git reflog记录你的每一条命令，可以查看commit id,提交具体的操作和提交输入的信息，命令如下： 12345root@instance-my0hsclo:/usr/local/ergzC0de# git reflog eede197 HEAD@&#123;0&#125;: rebase finished: returning to refs/heads/mastereede197 HEAD@&#123;1&#125;: pull --rebase origin master: init hexo repo1f25086 HEAD@&#123;2&#125;: pull --rebase origin master: checkout 1f2508638115730cb301f73c51b9971fca5c7f09fe14566 HEAD@&#123;3&#125;: commit (initial): init hexo repo 6.git checkout -- file丢弃工作区的修改，文件修改还没有添加到暂存区，命令如下： 1git checkout -- readme.txt 当文件修改后已经添加到了暂存区又作了修改，现在撤销修改就回到添加到暂存区后的状态。 7.git reset HEAD file把添加到暂存区的内容撤销，HEAD表示最新的版本 123root@instance-my0hsclo:/usr/local/learngit# git reset HEAD readme.txtUnstaged changes after reset:M readme.txt 8.查看分支：git branch 9.创建分支：git branch &lt;name&gt;我们创建新分支dev时，Git会新建一个指针叫dev，指向当前分支master的相同的提交点（HEAD指针指向的是当前分支），再把HEAD指向dev，之后的操作就在dev分支上完成，如图： 10.切换分支:git checkout &lt;name&gt;或者git switch &lt;name&gt;创建并切换分支git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 11.合并指定分支到当前分支上：git merge &lt;name&gt;当dev分支开发结束后，我们需要把dev分支合并到master（主分支）上，Git是如何操作的呢？Git直接把master指向dev的当前提交，就完成了合并，这些操作都是靠指针来完成，文件并没有发生变化，如图： 分支合并时，Git默认使用Fast forward模式，使用这种模式，删除分支后，会丢掉分支的历史信息，使用--no-ff可以禁用Fast forward模式 git merge --no-ff -m &quot;merge with no-ff&quot; dev，这样每次合并会创建一个新的commit，加上-m参数，写上commit的描述。 12.删除分支:git branch -d &lt;name&gt;合并完分支后就可以删除dev分支，，删除dev分支就是把dev指针给删掉，删掉后我们就剩下了一条master分支，如图： 13.查看分支合并图:git log --graph 团队协作的分支开发流程图： 本文链接：Git常用命令使用欢迎转载，请注明出处！参考：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}]},{"title":"Nginx搭建HTTP文件服务器","slug":"nginx-build-http-file-system","date":"2019-11-14T08:04:00.000Z","updated":"2019-12-18T14:10:04.506Z","comments":true,"path":"2019/11/14/nginx-build-http-file-system.html","link":"","permalink":"http://www.ergzcode.com/2019/11/14/nginx-build-http-file-system.html","excerpt":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署","text":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署 使用1.检查Nignx是否安装使用以下命令检查Nginx服务器状态： 1systemctl status nginx 2.安装Nginx(ubuntu)命令： 1sudo apt-get install nginx Ubuntu安装之后的文件结构大致为： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 程序文件/usr/sbin/nginx 日志在/var/log/nginx目录中 启动脚本nginx在/etc/init.d/下 默认的虚拟主机的目录设置在了/var/www/nginx-default (有的版本默认的虚拟主机的目录设置在了/var/www, 请参考/etc/nginx/sites-available里的配置) 在/etc/nginx目录下，nginx.conf是Nginx的核心配置文件，可以修改处理器数量、日志路径、pid文件等。在nginx.conf文件中有一段代码：inxclude /etc/nginx/conf.d/*.conf,这表示可以将自己的配置文件放在conf.d/中，Nginx会自动识别这个配置文件 3.修改配置文件vim /etc/nginx/sites-available/default 12345678910111213141516server &#123; listen 8080 default_server; listen [::]:8080 default_server; #root /usr/share/nginx/html; root /usr/local/data/file; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; autoindex on;#显示目录 autoindex_exact_size on;#显示文件大小 autoindex_localtime on;#显示文件时间 charset utf-8; &#125;&#125; 4.启动nginx1/etc/init.d/nginx start 5.浏览器访问浏览器打开：http://localhost:8080可以看到/data/file目录下的文件，点击可下载 6.修改配置后重载1/etc/init.d/nginx reload 本文链接：Nginx搭建HTTP文件服务器欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"图解SQL的各种join用法","slug":"diagrams-for-various-join-uses-of-sql","date":"2019-11-09T07:50:00.000Z","updated":"2019-12-18T15:43:04.408Z","comments":true,"path":"2019/11/09/diagrams-for-various-join-uses-of-sql.html","link":"","permalink":"http://www.ergzcode.com/2019/11/09/diagrams-for-various-join-uses-of-sql.html","excerpt":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法","text":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法 具体分解如下：1.INNER JOIN（内连接） 1234SELECT &lt;select_list&gt; FROM Table_A AINNER JOIN Table_B BON A.Key = B.Key 2.LEFT JOIN（左连接） 1234SELECT &lt;select_list&gt;FROM Table_A ALEFT JOIN Table_B BON A.Key = B.Key 3.RIGHT JOIN（右连接） 1234SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.Key 4.OUTER JOIN（外连接） 1234SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.Key 5.LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接） 12345SELECT &lt;select_list&gt; FROM Table_A ALEFT JOIN Table_B BON A.Key = B.KeyWHERE B.Key IS NULL 6.RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL 7.OUTER JOIN EXCLUDING INNER JOIN（外连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL OR B.Key IS NULL 原文链接：看一张图秒懂SQL的各种JOIN用法欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://www.ergzcode.com/tags/sql/"}],"author":"ergz"},{"title":"面试官：说一下Spring StringBuffer StringBuilder的区别","slug":"java-interview-0003","date":"2019-01-26T14:23:00.000Z","updated":"2019-12-26T14:32:29.581Z","comments":true,"path":"2019/01/26/java-interview-0003.html","link":"","permalink":"http://www.ergzcode.com/2019/01/26/java-interview-0003.html","excerpt":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象","text":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 可以看到String类和保存变量的value数组都被final修饰，表明String类是不可变的。 StringBuffer和StringBuilder都继承自AbstractStringBuilder类，看一下AbstractStringBuilder类的定义 abstract class AbstractStringBuilder implements Appendable,CharSequence{ /** *The value is userd for character storage */ char[] value; }看到区别了吗？ value数组没有用private和final修饰，说明了StringBuffer和StringBuilder是可变的。 而StringBuilder和StringBuffer的方法是差不多的，只不过StringBuffer在方法上添加了synchronized关键字，所以在多线程环境下用StringBuffer来获得更高的效率。 看2个类中同一个方法的定义 StringBUffer类 //StringBuffer append方法 @Override public synchronized StringBuffer append(char[] str){ toStringCache = null; super.append(str); return this; }StringBuilder类 //StringBuilder append方法 @Override public StringBuilder append(char[] str){ super.append(str); return this; }因为StringBuffer和StringBulider的实现类似，所以性能比较就落在String和StringBuilder之间了。 1.String是不可变对象，每次操作都会生成新的String对象，然后指针指向新的对象。 2.抽象类AbstractStringBuilder内部提供了一个自动扩容机制，当发现长度不够的时候，会自动进行扩容工作（具体扩容可以看源码，很容易理解），会创建一个新的数组，并将原来数组的数据复制到新的数组，不会创建新的对象，所以拼接字符串的效率高。 用源码证实一下 String类 public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); }StringBuilder类 public StringBuilder append(String str) { super.append(str); return this; }介绍完毕，所以你应该知道这道题应该怎么答了 常见面试题1. 说一下String StringBuffer StringBuilder的区别 都是final类，不能被继承 String长度是不可变的，StringBuffer和StringBuilder长度是可变的 StringBuffer是线程安全的，StringBuilder不是线程安全的。但他们的方法很相似，StringBuffer在方法上添加了synchronized关键字修饰，保证了线程安全 StringBuilder比StringBuffer拥有更好的性能 如果一个String类型的字符串，在编译时可以确定是一个字符串常量，则编译完成后，字符串会自动拼接成一个常量，此时String比StringBuffer和StringBuilder的性能好的多 我用例子解释一下第五条 String a = &quot;a&quot;; String b = &quot;b&quot;; String c = a+b; String d = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;反编译class的文件是这样的 String a = &quot;a&quot;; String b = &quot;b&quot;; (new StringBuilder()).append(a).append(b).toString(); String d = &quot;abc&quot;;看到String d,理解了吗？ 同时看c的拼接过程，先生成一个StringBuilder对象，再调用2次append方法，最后再返回一个String对象，知道StringBuilder比String慢的愿意了吧。 本文链接：面试官：说一下Spring StringBuffer StringBuilder的区别欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下构造函数，静态代码块，构造代码块的加载顺序","slug":"java-interview-0002","date":"2019-01-25T03:00:00.000Z","updated":"2019-12-26T14:45:19.409Z","comments":true,"path":"2019/01/25/java-interview-0002.html","link":"","permalink":"http://www.ergzcode.com/2019/01/25/java-interview-0002.html","excerpt":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } }","text":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } } 来New一个Test类看看会输出什么？ public class TestShow{ public static void main(String[] args){ /*创建第一个对象 我是静态代码块1 我的静态代码块2 我的构造代码块1 我的构造代码块2 我是无参数构造函数 */ System.out.println(&quot;创建第一个对象：&quot;); Test test1 = new Test(); /*创建第二个对象 我的构造代码块1 我的构造代码块2 我是带参数构造函数，参数是5 */ System.out.println(&quot;创建第二个对象：&quot;); Test test2 = new Test(5); } }从输出我们可以总结处如下结论： 执行时间：静态代码块 &gt; 构造代码块 &gt; 构造函数，静态代码块只会在类被加载入内存时加载一次，构造代码块和构造函数都是在对象创建的时候执行，有几个对象就会执行几次，所以一般将加载配置文件的过程写在静态代码块中。 没有继承的加载顺序 先定义一个类作为成员变量，方便看打印输出 public class Parameter { public Parameter(String str){ System.out.println(str); } }写一个测试类 public Test1{ public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); public Test1(){ System.out.println(&quot;构造函数&quot;); } //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } }输出如下 public class ForShow{ public static void main(String[] args){ /*静态成员变量 静态代码块 非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); /*非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); } }可以看出静态成员变量和静态代码块一样，只会在类被加载到内存时加载唯一的一次 改变一下Test类中定义的顺序，看看有什么变化。 public Test2{ //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造函数 public Test2(){ System.out.println(&quot;构造函数&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); }输出如下 public class ForShow{ public static void main(String[] args){ /*静态代码块 静态成员变量 构造代码块b 构造代码块a 非静态成员变量 构造函数 */ new Test2(); } }没有继承情况的执行顺序 静态代码块和静态成员变量，加载的顺序由编写的顺序决定 构造代码块和非静态成员变量，加载顺序由编写顺序决定 构造函数 有继承情况的执行顺序 定义父类 public class Father{ public static Prarmeter parameter1 = new Parameter(&quot;父类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;父类非静态成员变量&quot;); public Father(){ System.out.println(&quot;父类构造函数&quot;); } }定义子类 public class Son extends Father{ public static Prarmeter parameter1 = new Parameter(&quot;子类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;子类非静态成员变量&quot;); public Son(){ System.out.println(&quot;子类构造函数&quot;); } }有继承情况的执行顺序 父类的静态（静态代码块，静态成员变量），子类的静态（静态代码块，静态成员变量） 父类的非静态（构造代码块，非静态成员变量），父类的构造函数 子类的非静态（构造代码块，非静态成员变量），子类的构造函数 记住这几条规则足以应付这一类型的所有面试题 常见的面试题1.Java类定义如下，写出main函数执行后的输出结果 public class A{ static { System.out.println(&quot;static A&quot;); } public A(){ System.out.println(&quot;class A&quot;); } } public class B extends A{ public B(){ System.out.println(&quot;class B&quot;); } public static void main(String[] args){ B instance = new B(); } }上面的知识点如果理解的很清楚的话，这个结果立马就能写出来 所以输出如下 static A class A class B2.问题是如果main函数中的代码如下呢？就是B这个类new了2次 public static void main(String[] args){ B instance1 = new B(); B instance2 = new B(); }万变不离其宗，输出如下 static A class A class B class A class B因为静态成员变量和静态代码块只会在类被载入内存时加载一次。 本文链接：面试官：说一下构造函数，静态代码块，构造代码块的加载顺序欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下八种基本数据类型及其包装类吧","slug":"java-interview-0001","date":"2019-01-24T14:40:00.000Z","updated":"2019-12-26T14:42:37.705Z","comments":true,"path":"2019/01/24/java-interview-0001.html","link":"","permalink":"http://www.ergzcode.com/2019/01/24/java-interview-0001.html","excerpt":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 原始类型所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character","text":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 原始类型所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character 常见面试题要注意的是基本数据的包装类很多都实现了享元模式。享元模式就是运用共享技术有效地支持大量细粒度对象的复用。用一个常见的面试题来解释 1.判断如下代码的输出，并说出原因 Integer a1 = 40; Integer a2 = 40; System.out.println(a1==a2); Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);由自动装箱和拆箱可以知道这2种写法是等价的 Integer a1 = 40; Integer a1 = Integer.valueOf(40);看一下Integer.valueOf(int i)的方法 //...valueOf(int):Integer public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } //...IntegerCache private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }IntegerCache是Integer的静态内部类，默认创建了[-128,127]的对象，并放到IntegerCache内部的一个cache数组中，在[-128,127]这个范围内的整数对象，不用创建。直接从IntegerCache中的cache数组中根据下标拿就可以了,超出这个范围的每次去创建新的对象。其他几种包装类型的常量池和Integer的思路差不多，源码都很相似。所以答案如下： Integer a1 = 40; Integer a2 = 40; System.out.println(a1 == a2);//true Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);//false包装类缓存数据范围如下： 包装类 缓存范围 Byte -128~127 Short -128~127 Integer -128~127 Long -128~127 Character 0~127 2.Java一个char类型可以存储中文吗？ 可以，因为Java中使用了Unicode字符，不论是中文还是英文固定占用2个字节。 char a = &apos;中&apos;； // 中 System.out.println(a); 3.什么是自动装箱，自动拆箱 自动装箱就是Java自动将原始类型转换为对应的对象，比如将int的变量转换为Integer对象，这个过程就是装箱，反之将Integer对象转换为int类型的值，这个过程就是拆箱。因为这里的装箱和拆箱是自动进行的非人为转换的，所以就称作自动装箱和自动拆箱。 自动装箱时编译器调用ValueOf将原始类型值转换为对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换为原始类型值 //jdk1.5之前的写法 Integer tempNum1 = Integer.valueOf(5); int num1 = tempNum1.intValue(); //jdk1.5之后的写法，自动装箱和拆箱 Integer tempNum2= 5; int num1 = tempNum2;4.为什么要需要基本数据类型的包装类 （1）Java是面向对象的语言，很多地方是需要使用的是对象而不是基本数据类型。例如，List,Map等容器类中基本数据类型是放不进去的。（2）包装类在原先的基本数据类型上，新增加了很多方法，比如Integer.valueOf(String s)等 5.既然包装类能完成所有的功能，为啥还需要基本数据类型 基本数据类型基于数值，对象类型基于引用。基本数据类型存储在栈的局部变量表中。 而对象类型的变量则是存储堆中引用，实例放在堆中，因此对象类型的变量需要占用更多的内存空间，基本数据类型因为占用更少内存被保留下来。 6.写出如下代码的输出 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2); System.out.println(i1 == i2 + i3); System.out.println(i1 == i4); System.out.println(i4 == i5); System.out.println(i4 == i5 + i6); System.out.println(40 == i5 + i6);输出及解释如下 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2);//true //Integer.valueOf()用了常量池，看上面的源码 //比较是内存地址 System.out.println(i1 == i2 + i3);//true // + 操作会导致左右两边都转换为基本数据类型 //比较是值 System.out.println(i1 == i4);//false //Integer.valueOf()使用常量池中的对象 //new Integer每次都会创建新对象 //比较是内存地址 System.out.println(i4 == i5);//false //new关键字会创建新的实例所以这是2个不同的对象 //比较是内存地址 System.out.println(i4 == i5 + i6);//true //解释在下面，比较的是值 System.out.println(40 == i5 + i6);//true //解释在下面，比较的是值语句i4 = i5 + i6,因为这个 + 操作符不适用于Integer对象，首先i5和i6进行了自动拆箱的操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int数据类型，值为40，最终这条语句转为40 == 40进行数值的比较。 本文链接：面试官：说一下八种基本数据类型及其包装类吧欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"MySQL数据库优化，看这篇就够了","slug":"mysql-database-optimization-this-article-is-enough","date":"2018-10-18T15:00:00.000Z","updated":"2019-12-20T05:27:26.199Z","comments":true,"path":"2018/10/18/mysql-database-optimization-this-article-is-enough.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/mysql-database-optimization-this-article-is-enough.html","excerpt":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图","text":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图 2. 优化笔者将优化分为了两大类,软优化和硬优化,软优化一般是操作数据库即可,而硬优化则是操作服务器硬件及参数设置. 2.1 软优化2.1.1 查询语句优化1.首先我们可以用EXPLAIN或DESCRIBE(简写:DESC)命令分析一条查询语句的执行信息.2.例:DESC SELECT * FROM user显示：其中会显示索引和查询数据读取数据条数等信息. 2.1.2 优化子查询在MySQL中,尽量使用JOIN来代替子查询.因为子查询需要嵌套查询,嵌套查询时会建立一张临时表,临时表的建立和删除都会有较大的系统开销,而连接查询不会创建临时表,因此效率比嵌套子查询高. 2.1.3 使用索引索引是提高数据库查询速度最重要的方法之一,关于索引可以参高笔者&lt;MySQL数据库索引&gt;一文,介绍比较详细,此处记录使用索引的三大注意事项: 1.LIKE关键字匹配’%’开头的字符串,不会使用索引. 2.OR关键字的两个字段必须都是用了索引,该查询才会使用索引. 3.使用多列索引必须满足最左匹配. 2.1.4 分解表对于字段较多的表,如果某些字段使用频率较低,此时应当,将其分离出来从而形成新的表, 2.1.5 中间表对于将大量连接查询的表可以创建中间表,从而减少在查询时造成的连接耗时. 2.1.6 增加冗余字段类似于创建中间表,增加冗余也是为了减少连接查询. 2.1.7 分析表,检查表,优化表分析表主要是分析表中关键字的分布,检查表主要是检查表中是否存在错误,优化表主要是消除删除或更新造成的表空间浪费. 一.分析表: 使用 ANALYZE 关键字,如ANALYZE TABLE user;1.Op:表示执行的操作.2.Msg_type:信息类型,有status,info,note,warning,error.3.Msg_text:显示信息. 二.检查表: 使用CHECK关键字,如CHECK TABLE user [option]option只对MyISAM有效,共五个参数值:1.QUICK:不扫描行,不检查错误的连接.2.FAST:只检查没有正确关闭的表.3.CHANGED:只检查上次检查后被更改的表和没被正确关闭的表.4.MEDIUM:扫描行,以验证被删除的连接是有效的,也可以计算各行关键字校验和.5.EXTENDED:最全面的的检查,对每行关键字全面查找. 三.优化表:使用OPTIMIZE关键字,如OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE user;LOCAL|NO_WRITE_TO_BINLOG都是表示不写入日志.,优化表只对VARCHAR,BLOB和TEXT有效,通过OPTIMIZE TABLE语句可以消除文件碎片,在执行过程中会加上只读锁. 2.2 硬优化2.2.1 硬件三件套1.配置多核心和频率高的cpu,多核心可以执行多个线程.2.配置大内存,提高内存,即可提高缓存区容量,因此能减少磁盘I/O时间,从而提高响应速度.3.配置高速磁盘或合理分布磁盘:高速磁盘提高I/O,分布磁盘能提高并行操作的能力. 2.2.2 优化数据库参数优化数据库参数可以提高资源利用率,从而提高MySQL服务器性能.MySQL服务的配置参数都在my.cnf或my.ini,下面列出性能影响较大的几个参数. 1.key_buffer_size:索引缓冲区大小2.table_cache:能同时打开表的个数3.query_cache_size和query_cache_type:前者是查询缓冲区大小,后者是前面参数的开关,0表示不使用缓冲区,1表示使用缓冲区,但可以在查询中使用4.SQL_NO_CACHE表示不要使用缓冲区,2表示在查询中明确指出使用缓冲区才用缓冲区,即SQL_CACHE.5.sort_buffer_size:排序缓冲区 传送门:更多参数 2.2.3 分库分表因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。另外一个，压力过大把你的数据库给搞挂了怎么办？所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这时作为主库承载写入请求。然后每个主库都挂载至少一个从库，由从库来承载读请求。 2.2.4 缓存集群 结语一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统和各种精妙的架构设计.因此一篇小文顶多具有抛砖引玉的效果,但是数据库优化的思想差不多就这些了. 原文链接:MySQL数据库优化欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.ergzcode.com/tags/Mysql/"}],"author":"ergz"},{"title":"Tomcat优化之修改内存配置","slug":"tomcat-modifying-memory-configuration-for-optimization","date":"2018-10-18T14:17:00.000Z","updated":"2019-12-18T15:43:54.028Z","comments":true,"path":"2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","excerpt":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明","text":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明 maxIdleTime：最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms）； minSpareThreads：最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值4； maxSpareThreads：最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50； maxThreads：最大线程数，大并发请求时，tomcat能创建来处理请求的最大线程数，超过则放入请求队列中进行排队，默认值为200； acceptCount：当最大线程数（maxThreads）被使用完时，可以放入请求队列排队个数，超过这个数返回connection refused（请求被拒绝），一般设置和maxThreads一样，不过这个具体需要根据自己的应用实际访问峰值和平均值来权衡，默认值为100； connectionTimeout：网络连接超时，假设设置为0表示永不超时，这样设置隐患巨大，通常可设置为30000ms，默认60000ms； Windows Tomcat允许每个进程maxThreads（最大线程数）2000，Linux Tomcat允许每个进程maxThreads（最大线程数）1000 请看下面三种情况情况1：接受一个请求，此时tomcat起动的线程数没有到达maxThreads，tomcat会起动一个线程来处理此请求。 情况2：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，tomcat会把此请求放入等待队列，等待空闲线程。 情况3：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，等待队列中的请求个数也达到了acceptCount，此时tomcat会直接拒绝此次请求，返回connection refused maxThreads如何配置一般的服务器操作都包括两方面：1计算（主要消耗cpu），2等待（io、数据库等）。 第一种极端情况，如果我们的操作是纯粹的计算，那么系统响应时间的主要限制就是cpu的运算能力，此时maxThreads应该尽量设的小，降低同一时间内争抢cpu的线程个数，可以提高计算效率，提高系统的整体处理能力。 第二种极端情况，如果我们的操作纯粹是IO或者数据库，那么响应时间的主要限制就变为等待外部资源，此时maxThreads应该尽量设的大，这样才能提高同时处理请求的个数，从而提高系统整体的处理能力。此情况下因为tomcat同时处理的请求量会比较大，所以需要关注一下tomcat的虚拟机内存设置和linux的open file限制。 我在测试时遇到一个问题，maxThreads我设置的比较大比如3000，当服务的线程数大到一定程度时，一般是2000出头，单次请求的响应时间就会急剧的增加，百思不得其解这是为什么，四处寻求答案无果，最后我总结的原因可能是cpu在线程切换时消耗的时间随着线程数量的增加越来越大，cpu把大多数时间都用来在这2000多个线程直接切换上了，当然cpu就没有时间来处理我们的程序了。以前一直简单的认为多线程=高效率。其实多线程本身并不能提高cpu效率，线程过多反而会降低cpu效率。当cpu核心数&lt;线程数时，cpu就需要在多个线程直接来回切换，以保证每个线程都会获得cpu时间，即通常我们说的并发执行。所以maxThreads的配置绝对不是越大越好。 现实应用中，我们的操作都会包含以上两种类型（计算、等待），所以maxThreads的配置并没有一个最优值，一定要根据具体情况来配置。最好的做法是：在不断测试的基础上，不断调整、优化，才能得到最合理的配置。acceptCount的配置，我一般是设置的跟maxThreads一样大，这个值应该是主要根据应用的访问峰值与平均值来权衡配置的。如果设的较小，可以保证接受的请求较快相应，但是超出的请求可能就直接被拒绝。如果设的较大，可能就会出现大量的请求超时的情况，因为我们系统的处理能力是一定的。 原文链接：Tomcat修改内存配置欢迎转载，请注明出处！","categories":[{"name":"web服务器","slug":"web服务器","permalink":"http://www.ergzcode.com/categories/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://www.ergzcode.com/tags/tomcat/"}],"author":"ergz"},{"title":"MarkdownPad2.5注册码","slug":"markdownpad2.5-license-key","date":"2016-05-15T07:25:00.000Z","updated":"2019-12-25T11:26:34.821Z","comments":true,"path":"2016/05/15/markdownpad2.5-license-key.html","link":"","permalink":"http://www.ergzcode.com/2016/05/15/markdownpad2.5-license-key.html","excerpt":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==","text":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 输入Email address和license key 注册完成 本文链接：MarkdownPad2.5注册码欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://www.ergzcode.com/tags/markdown/"}],"author":"ergz"}]}
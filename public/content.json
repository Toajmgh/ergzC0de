{"meta":{"title":"ergzC0de","subtitle":"代码也是一种艺术","description":"Java,Python,编程","author":"ergz","url":"http://www.ergzcode.com","root":"/"},"pages":[{"title":"声明","date":"2019-12-25T07:44:11.000Z","updated":"2019-12-31T09:58:04.119Z","comments":true,"path":"contact/me.html","permalink":"http://www.ergzcode.com/contact/me.html","excerpt":"","text":"本站仅提供了一个技术交流的平台，没有任何商业盈利的行为。除了原创文章外，从网络上转载的文章或搜集的一些资源在文末都有出处说明，若您认为本站资源侵犯了您的版权，请联系站长删除。 邮箱：itoajm@163.com扣扣：921936477(备注说明来意)微信：wxw0220(备注说明来意)"}],"posts":[{"title":"最新IDEA永久激活","slug":"idea-latest-active","date":"2019-12-25T12:26:00.000Z","updated":"2019-12-29T09:27:08.686Z","comments":true,"path":"2019/12/25/idea-latest-active.html","link":"","permalink":"http://www.ergzcode.com/2019/12/25/idea-latest-active.html","excerpt":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar","text":"已支持2019.2的版本且适用Windows、Mac、Ubuntu等所有平台 1.下载新版破解补丁下载链接：http://cdn.ergzcode.com/jetbrains/jetbrains-agent.jar，并将它放置到IDEA安装目录的bin目录下（位置可随意）。 2.修改配置文件如果你是刚下载的IDEA，先点击激活窗口的免费试用，创建一个新项目来进入到IDEA的工作目录。进入IDEA的工作界面后，点击IDEA的上方的菜单栏‘Help’-&gt;‘Edit Custom VM Options…’，如果提示是否要创建文件，请点‘Yes’，打开idea64.exe.vmoptions文件在末行添加：-javaagent:你的IDEA安装目录\\bin\\jetbrains-agent.jar -Xms512m -Xmx2048m -XX:ReservedCodeCacheSize=480m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot; -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true -javaagent:C:\\Program Files\\JetBrains\\ideaIU 2019.2.3\\bin\\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况，这时候可以删除用户配置目录下的IDEA文件夹: windwos：C:\\Users\\用户名\\ macos：~/Library/Preferences/ ubuntu：~/. 修改完配置文件之后重启IDEA 3.输入激活码重启IDEA之后，点击菜单栏中的 ‘Help ’-&gt; ‘Register…’，这里有两种激活方式： 一.选择最后一种License server激活方式，地址填入：http://jetbrains-license-server ,或者点击按钮：‘Discover Server’来自动填充地址，完成激活。 二.如果服务器激活方式无法激活，还可以选择Activation code方式激活，激活码下载:激活码.txt，下载复制激活码填入，点击OK即可。 服务器激活是没有期限的，是永久有效。激活码激活的有效期到2089年。 本文链接：最新IDEA永久激活欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.ergzcode.com/tags/IDEA/"}],"author":"ergz"},{"title":"资源整理[置顶]","slug":"resources-collection-top","date":"2019-12-14T11:03:00.000Z","updated":"2019-12-26T15:53:59.169Z","comments":true,"path":"2019/12/14/resources-collection-top.html","link":"","permalink":"http://www.ergzcode.com/2019/12/14/resources-collection-top.html","excerpt":"本文链接：http://www.ergzcode.com/2019/12/14/resources-collection-top.html","text":"本文链接：http://www.ergzcode.com/2019/12/14/resources-collection-top.html 1.Python 某马全套Python2018（15期）链接：https://pan.baidu.com/s/1YZ4Rt7udqhguEx44gnzoSQ 提取码：6xiv 某内全套Python2019年3-7月链接：https://pan.baidu.com/s/1JAIdeYLNI6BNReCQHHYztQ 提取码：ct3b 某男孩Python全栈15期链接：https://pan.baidu.com/s/1ZeUunSf-Q7bBL9HXFL0PDA 提取码：ad4l 某男孩Python全栈16期2019年结课链接：https://pan.baidu.com/s/17OqQ1L4PSQlPqpQxcxtDRA 提取码：bgle 某男孩Python22期（加密版本）链接：https://pan.baidu.com/s/1PPtGubLGlyM9yKbVM_Q_WQ 提取码：x4t9 Python爬虫（入门+进阶)链接：https://pan.baidu.com/s/152IMovvjz8BRKY6ZUs5Itw 提取码：5gy3 Python3+TensorFlow开发人脸识别智能小程序链接：https://pan.baidu.com/s/1QhG7fgvGq7-vOXFM6PcYHA 提取码：5u10 Python某马头条推荐系统项目链接：https://pan.baidu.com/s/1gbuZuF2LAAS2BLymj-4ZbQ 提取码：n22v python金融实务从入门到精通链接：https://pan.baidu.com/s/1qBqejqOEqI3scjEr6EcBXg 提取码：v1rv 云课堂从零搭建数字货币量化交易系统链接：https://pan.baidu.com/s/1dKehNYO337jZ67WJppBrPw 提取码：vdx6 2.运维 Docker+Kubernetes+Jenkins教程链接：：https://pan.baidu.com/s/1VMcFl3moDul3tOQdGPFRnw 提取码：w0xv 3.Java 某马18年Java教程完整版链接：https://pan.baidu.com/s/1RT2H-dI_4LLLIssq2WaEnw 提取码：m2lt 某马18年Java教程赠品完整版链接：https://pan.baidu.com/s/1Y8ASBWacpQH35wc1ZY7FZA 提取码：2rxx 某马18年Java教程赠品追加完整版链接：https://pan.baidu.com/s/1Z3Tdxcmub6WKc7Q3jfm7Qw 提取码：k10s 2019Java大厂面试整理链接：https://pan.baidu.com/s/1NTVceajFq-0EvgZ8BJreNA 提取码：lzk5 2019Java微服务千峰教程链接：https://pan.baidu.com/s/15LrqQbRSP3Ru5Eg69UWG0A 提取码：r70w 极客时间Spring全家桶链接：https://pan.baidu.com/s/1ncRq26L_U7mgNM76-7jYiw 提取码：b9lt 免责声明：以上所有资源均由网友网上搜集提供更新，仅供读者预览及学习交流使用，下载后请24小时内删除，如果喜欢请购买正版资源!原作者如果认为本站侵犯了您的版权,请联系站长,我们会立即删除!","categories":[],"tags":[],"author":"ergz"},{"title":"Nginx反向代理实现二级域名与端口的映射","slug":"nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports","date":"2019-12-14T09:27:00.000Z","updated":"2019-12-29T09:26:48.202Z","comments":true,"path":"2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","link":"","permalink":"http://www.ergzcode.com/2019/12/14/nginx-reverse-proxy-implements-the-mapping-of-secondary-domain-names-to-ports.html","excerpt":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。","text":"在之前的一篇文章：Nginx搭建HTTP文件服务器中,我们搭建了一个HTTP的文件服务器，通过8080端口来访问服务。现在我们想通过域名的方式（二级域名）来访问这个HTTP的文件服务器，我们知道通过浏览器URL地址的方式访问一个网站，比如http://www.ergzcode.com,默认的是去服务器找80端口下的服务，也就是http://www.ergzcode.com:80这个地址。考虑到80端口是比较特殊的端口，所以部署hexo时指定的端口是4000，这样将会导致只有使用http://www.ergzcode.com:4000才能访问到本站，但这种的URL无疑是让人接受不了的。 现在需要做到以下两点： 将http://www.ergzcode.com的请求转发给4000端口下的应用程序，也就是通过这种URL访问本站 将http://cdn.ergzcode.com的请求转发给8080端口下的http文件服务器 当然在这之前，有个前提就是你需要让cdn.ergzcode.com和www.ergzcode.com这两个域名解析到你的服务器IP上，DNS解析在域名提供商那里作处理,这里不再介绍 现在要做到上面的请求转发，就要用到Nginx的反向代理机制，下面来创建Nginx的配置文件，在/etc/nginx/conf.d目录下创建一个叫做reverse_proxy.conf的文件，文件名可以随意指定，但要以.conf为后缀名，然后加入下面的内容 1234567891011121314151617181920212223242526server&#123; listen 80;#监听端口 server_name www.ergzcode.com;#根据域名跳转 location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:4000;#跳转的路径 &#125;&#125;server&#123; listen 80; server_name cdn.ergzcode.com; #root /usr/local/data/file; location / &#123; # try_files $uri $uri/ =404; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080;#跳转的路径 &#125;&#125; 执行命令使修改配置生效/etc/init.d/nginx reload 访问本站：http://www.ergzcode.com访问HTTP服务器：http://cdn.ergzcode.com完成！！ 本文链接：Nginx反向代理实现二级域名与端口的映射欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"开发中常用的一些免费API","slug":"some-common-and-free-apis-for-developing","date":"2019-12-11T10:20:00.000Z","updated":"2019-12-18T15:42:20.840Z","comments":true,"path":"2019/12/11/some-common-and-free-apis-for-developing.html","link":"","permalink":"http://www.ergzcode.com/2019/12/11/some-common-and-free-apis-for-developing.html","excerpt":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址","text":"为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个api的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。 百度AccessToken:针对HTTP API调用者，百度AIP开…——接口地址语音识别:通过场景识别优化，为车载导航，智能家居和…——接口地址语音合成:将用户输入的文字，转换成流畅自然的语音输…——接口地址出租车票识别(可在线调用):针对出租车票（现支持北京、上海、深圳）的…——接口地址火车票识别(可在线调用):支持对大陆火车票的车票号、始发站、目的站…——接口地址数字识别(可在线调用):对图像中的阿拉伯数字进行识别提取，适用于…——接口地址通用文字识别(可在线调用):支持多场景下的文字检测识别，多项ICDA…——接口地址网络图片文字识别(可在线调用):能够快速准确识别各种网络图片中的文字，在…——接口地址身份证识别(可在线调用):支持对二代居民身份证正反面的关键字段识别…——接口地址银行卡识别(可在线调用):支持对主流银行卡卡号识别，并返回发卡行和…——接口地址驾驶证识别(可在线调用):支持对机动车驾驶证正页的关键字段识别，包…——接口地址行驶证识别(可在线调用):支持对机动车行驶证正页的关键字段识别，包…——接口地址手写文字识别(可在线调用):能够对手写汉字和手写数字进行识别——接口地址增值税发票识别(可在线调用):识别并结构化返回增值税发票的各个字段及其…——接口地址营业执照识别(可在线调用):支持对营业执照关键字段的识别，包括单位名…——接口地址车牌识别(可在线调用):支持对中国大陆机动车车牌的识别，包括地域…——接口地址票据识别(可在线调用):支持对增值税发票、火车票、出租车票（支持…——接口地址表格文字识别:自动识别表格线及表格内容，结构化输出表头…——接口地址通用物体和场景识别(可在线调用):支持超过10万类物体和场景识别，接口返回…——接口地址图像主体检测(可在线调用):检测图片中关键主体位置，接口支持检测单张…——接口地址品牌logo识别(可在线调用):实现2万类品牌logo识别，接口返回品牌…——接口地址植物识别(可在线调用):植物识别支持2万多种通用植物识别、近…——接口地址动物识别(可在线调用):支持数千种动物识别，接口返回名称——接口地址菜品识别(可在线调用):识别超过5万个菜品，接口返回菜品的名称、…——接口地址地标识别(可在线调用):支持识别约5万中外著名地标、景点，接口返…——接口地址车型识别(可在线调用):识别车辆的具体车型，以小汽车为主，输出图…——接口地址车辆检测:识别图像中所有机动车辆的类型和位置，并对…——接口地址GIF色情图像识别(可在线调用):人工智能鉴黄技术，智能识别图片和视频中的…——接口地址图像审核(可在线调用):通过人脸检测、文字识别、色情识别、暴恐识…——接口地址人脸检测与属性分析(可在线调用):检测图中的人脸，并为人脸标记出边框。检测…——接口地址在线活体检测(可在线调用):提供在线方式的人脸活体检测能力，在人脸识…——接口地址人体关键点识别(可在线调用):检测人体并返回人体矩形框位置，精准定位1…——接口地址人流量统计(可在线调用):统计图像中的人体个数和流动趋势，以头肩为…——接口地址人体检测与属性识别(可在线调用):检测图像中的所有人体，识别人体的20类属…——接口地址手势识别(可在线调用):识别图片中的手部位置和手势类型，可识别2…——接口地址人像分割(可在线调用):识别图像中的人体轮廓，与背景进行分离——接口地址驾驶行为分析(可在线调用):针对车载场景，识别驾驶员使用手机、抽烟、…——接口地址词法分析(可在线调用):基于大数据和用户行为的分词、词性标注、命…——接口地址词向量表示(可在线调用):词向量计算是通过训练的方法，将语言词表中…——接口地址词义相似度(可在线调用):用于计算两个给定词语的语义相似度，基于自…——接口地址依存句法分析(可在线调用):利用句子中词与词之间的依存关系来表示词语…——接口地址DNN语言模型(可在线调用):语言模型是通过计算给定词组成的句子的概率…——接口地址短文本相似度(可在线调用):短文本相似度计算服务能够提供不同短文本之…——接口地址文本纠错(可在线调用):文本纠错支持短文本、长文本、语音识别结果…——接口地址情感倾向分析(可在线调用):针对带有主观描述的中文文本，可自动判断该…——接口地址评论观点抽取(可在线调用):自动分析评论关注点和评论观点，并输出评论…——接口地址对话情绪识别(可在线调用):针对一段对话文本，自动识别出当前会话者所…——接口地址文章标签(可在线调用):文章标签服务对文章的标题和内容进行深度分…——接口地址文章分类(可在线调用):文章分类服务对文章内容进行深度分析，输出…——接口地址新闻摘要(可在线调用):基于深度语义分析模型，自动抽取新闻文本中…——接口地址通用翻译(可在线调用):支持28种语言实时互译，覆盖中、英、日、…——接口地址实体标注(可在线调用):结合上下文，识别文本中的实体并将其关联到…——接口地址新闻头条(可在线调用):最新新闻头条，各类社会、国内、国际、体育…——接口地址手机号码归属地(可在线调用):根据手机号码或手机号码的前7位，查询手机…——接口地址彩票开奖结果查询(可在线调用):目前支持双色球、大乐透、七乐彩、七星彩、…——接口地址天气预报(可在线调用):查询天气情况：温度、湿度、AQI、天气、…——接口地址二维码生成(可在线调用):按照设定的参数、生成二维码——接口地址汇率(可在线调用):外汇报价，货币汇率——接口地址历史上的今天(可在线调用):回顾历史的长河，历史是生活的一面镜子——接口地址成语词典(可在线调用):新华字典在线查字,最新最全——接口地址新华字典(可在线调用):最大最全的新华汉语词典，按拼音查、按部首…——接口地址微信精选(可在线调用):微信精选文章——接口地址笑话大全(可在线调用):搜集网络幽默、搞笑、内涵段子，不间断更新——接口地址全国WIFI(可在线调用):全国免费的WIFI热点分布——接口地址货币汇率(可在线调用):支持人民币牌价、外汇汇率查询；数据仅供参…——接口地址手机固话来电显示:查询手机/固话号码归属地，是否诈骗、营销…——接口地址简/繁/火星字体转换(可在线调用):实现简体、繁体、火星文之间的转换,转换字…——接口地址全国邮编查询(可在线调用):提供全国邮政编码大全,为你快速准确查邮编——接口地址老黄历(可在线调用):提供老黄历查询,黄历每日吉凶宜忌查询——接口地址周公解梦(可在线调用):周公解梦,周公解梦大全,周公解梦查询，免…——接口地址净值数据(可在线调用):根据基金类型及分页参数来获取数据(开放式…——接口地址星座运势(可在线调用):十二星座每日、每月、每年运势——接口地址图书电商数据(可在线调用):于万千之中选择你所爱–好书推荐，值得你…——接口地址身份证查询(可在线调用):身份证归属地信息查询——接口地址黄金数据(可在线调用):黄金品种、最新价、开盘价、最高价等信息——接口地址IP地址(可在线调用):根据查询的IP地址或者域名，查询该IP所…——接口地址笑话大全——文字(可在线调用):每小时更新。文字笑话大全，信息搜集整理于…——接口地址笑话大全——图片(可在线调用):每小时更新。图片笑话大全，信息搜集整理于…——接口地址最新新闻:新闻API接口 官方自营 会员接口…——接口地址美图大全:根据几十个种类获取图片列表，每日更新。种…——接口地址手机归属地查询:最全、最新的手机号段数据库。本地找不到的…——接口地址历史上的今天:回顾历史的长河,历史是生活的一面镜子;历…——接口地址来福岛笑话——图片:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址来福岛笑话——文字:来福岛爆笑娱乐网创建于2000年，是国内…——接口地址全国景点查询:全国景点查询接口（来自同程网的合作数据）…——接口地址健康知识:根据养生、用药、两性等频道内容获取健康知…——接口地址猜一猜:随机返回谜语，有2.5万谜语，每日更新。…——接口地址身份证查询:可根据身份证号，查询其签发地、生日、性别…——接口地址爱飞天气插件:爱飞天气是ShowAPI官方天气接口的一…——接口地址PM2.5空气质量指数:本接口每小时更新1次。空气质量指数提供实…——接口地址全球IP地址查询:全球IP地址——接口地址域名查询:域名查询地理位置——接口地址汉字转拼音:将汉字转换为拼音和拼音首字母缩写——接口地址中文分词:中文分词接口。将长段中文切词分开。使用场…——接口地址图片验证码生成:图形|图片验证码生成，支持自定义高宽，文…——接口地址新闻、网页正文抽取:传入一个新网或网页地址，接口将返回此ur…——接口地址实时IP代理查询:代理数量并不是越多越好，可以用才是真正的…——接口地址今日油价:今日油价，可查询全国31个省的油价。每天…——接口地址QQ号码测凶吉:输入qq号码，得到此号码的算命情况，例如…——接口地址地址转换经纬度:根据城市和名称转换为相应的经纬度——接口地址经纬度转换地址:根据经纬度转换成相应地址——接口地址黄历运势:根据输入日期，查看某一天的黄历运势——接口地址十大银行实时汇率:包括工商银行、中国银行、农业银行、交通银…——接口地址汇率转换:1分钟更新1次。当前十大银行，包括工商银…——接口地址添加图片水印:传入底板图及水印图，根据位置参数，接口把…——接口地址图像裁剪:裁剪原图的部份区域——接口地址生成缩略图:根据传入的比率将原图生成缩略图——接口地址星座运势:每天1点、7点、17点更新。包含十二星座…——接口地址PDF文件正文抽取:抽取PDF文件中的文字信息——接口地址网络搜索热词排行:每2小时更新一次。根据分类查询网络最热的…——接口地址二维码识别:根据图片的Base64信息,识别图片中的…——接口地址二维码生成:生成二维码图片 图片存放在showapi…——接口地址中文文本相似度检测:通过计算向量间的夹角（余弦公式），来判断…——接口地址全国火车票查询:数据来源于12306。 包括城市列表\\列…——接口地址药品查询:药品信息——接口地址菜谱大全:本菜谱的信息来源于网络,所以本信息仅用于…——接口地址台风最新坐标轨迹:可查询当前存在威胁的台风列表，每个台风的…——接口地址网页级别查询:google的pr查询——接口地址关键词抽取:根据传入的大段文字，使用TextRank…——接口地址全国行政区划分:最新最全的全国省、市、区县、乡镇的分级查…——接口地址微信小程序查询:搜索查询已经上架的微信小程序。包括基本信…——接口地址生成文章摘要:根据传入的长篇文章，系统使用智能算法抽取…——接口地址藏头诗生成:藏头诗生成器。可输入人名生成藏头、藏尾、…——接口地址国际原油价格查询:WTI和布伦特的油价查询——接口地址水质查询:根据地点和时间查询水质——接口地址条码生成:提供EAN_8、EAN_13、CODE_…——接口地址条码识别:提供EAN_8、EAN_13、CODE_…——接口地址全国站点换乘线路查询:提供全国站点换乘线路查询——接口地址全国公交换乘查询:提供全国公交换乘查询——接口地址汽车品牌查询:收录了近200个品牌/子品牌,上万辆车型…——接口地址周公解梦:根据周公解梦全书提供相关信息——接口地址正能量新闻:社会正能量的新闻资讯，每天更新——接口地址全国酒店查询:该接口所返回的所有图片链接将在12小时内…——接口地址经典语句:根据名人，查询经典名言——接口地址商品比价:搜索商品，根据商品url搜索各大商城的历…——接口地址姓名打分:根据姓名，返回此姓名的运势得分——接口地址公司名测吉凶:根据公司名，返回此公司的运势得分——接口地址车牌号测吉凶:根据车牌名，返回此车牌号的运势得分——接口地址手机号测吉凶:根据手机号码，返回此号码的运势得分——接口地址图书ISBN查询:通过国际图书号查询图书相关信息，目前只支…——接口地址影讯查询:影讯查询——接口地址手机套餐售价:全国手机流量充值，4G流量，当月有效——接口地址紫微斗数:根据出生时间定紫薇斗数命盘，供命理研究，…——接口地址唐诗宋词元曲等诗词查询:根据朝代Id或诗人名称查询诗人信息——接口地址脑筋急转弯:查询常见的脑筋急转弯金句——接口地址虚拟数字币|比特币行情:查询主流虚拟货币实时行情，例如btc(比…——接口地址全国房产信息:搜索最新楼盘开盘信息、最新市场房价信息——接口地址手游排行榜:手游最热排行榜及最期待榜——接口地址网游排行榜:网游最热排行榜及最期待榜——接口地址黄金行情:上金所黄金行情——接口地址电商淘宝平台联想词:提供淘宝联想词查询——接口地址中文反义词:中文反义词——接口地址中文近义词:中文近义词——接口地址歇后语查询:查询歇后语列表——接口地址中国互联网络信息:中国互联网络信息——接口地址实时票房排行:实时票房中国（包括香港）、北美、全球票房…——接口地址爱奇艺热点趋势:爱奇艺视频指数——接口地址空气质量指数(可在线调用):空气质量指数提供实时空气质量情况，目前支…——接口地址IP地址查询(可在线调用):提供rest风格的IP地址查询接口，只需…——接口地址天气预报(可在线调用):全国天气预报，预报7天天气，以及当天的生…——接口地址人脸识别(可在线调用):检测图片(Image)中的人脸(Face…——接口地址指纹识别:检测图片(Image)中的指纹(Fing…——接口地址医疗科室(可在线调用):医药健康接口专用的医疗科室字典项获取——接口地址健康菜谱(可在线调用):健康菜谱，让人们在宣泄的都市中体验在家常…——接口地址疾病信息(可在线调用):通过名称取得疾病详情——接口地址药品查询(可在线调用):通过药品名字直接得到药品说明书、价格、生…——接口地址食疗大全(可在线调用):通过名称取得食品详情只要是食品都有它…——接口地址手术项目(可在线调用):通过名称取得手术详情通过名称取得手术…——接口地址药房药店(可在线调用):通过名称取得药店信息通过名称取得药店…——接口地址病状信息(可在线调用):通过名称取得病状详情——接口地址微信精选(可在线调用):微信热门精选文章，实时更新——接口地址国内新闻(可在线调用):国内新闻数据，实时更新——接口地址国际新闻(可在线调用):国际新闻数据，实时更新——接口地址体育新闻(可在线调用):体育新闻数据，实时更新——接口地址科技新闻(可在线调用):科技新闻数据，实时更新——接口地址奇闻轶事(可在线调用):奇闻轶事数据，实时更新——接口地址旅游新闻(可在线调用):旅游热点数据，实时更新——接口地址新华字典(可在线调用):新华字典数据库，可查字的拼音、读音、偏旁…——接口地址五笔字根(可在线调用):查询汉字的五笔字根——接口地址简繁体火星文转换(可在线调用):汉字的简体、繁体、火星文转换——接口地址成语词典(可在线调用):成语查询——接口地址歇后语(可在线调用):歇后语查询，根据关键字搜索歇后语——接口地址唐诗宋词(可在线调用):根据关键字搜索唐诗宋词——接口地址历史上的今天(可在线调用):以史为镜，可以知兴替。借历史上的成败得失…——接口地址辞海(可在线调用):查询词语解释——接口地址手机号码归属地(可在线调用):通过手机号码查询归属地、运营商、号码类型…——接口地址笑话大全(可在线调用):海量互联网幽默、内涵段子、趣味图片，不间…——接口地址同义词:通过输入的词语查询对应的同义词——接口地址全国WIFI(可在线调用):查询周边免费WIFI热点；全国免费WIF…——接口地址NBA赛事(可在线调用):NBA赛事赛程信息，球队赛程赛事查询——接口地址全国邮编查询(可在线调用):通过地名查询地区邮编，精确到街道——接口地址周公解梦(可在线调用):周公解梦大全——接口地址名人名言(可在线调用):通过关键字查询名人名言——接口地址今日油价(可在线调用):可查询全国31个省的油价——接口地址国际白银实时价格:国际交易市场白银实时价格(美元/盎司)，…——接口地址时事新闻检索(可在线调用):时事新闻，新闻检索等，实时更新——接口地址号码吉凶(可在线调用):手机号码、QQ号码、车牌号等所有数字类型…——接口地址金额小写转大写(可在线调用):人民币金额小写转大写——接口地址电影票房(可在线调用):最新票房榜，网票票房——接口地址全国长途汽车(可在线调用):全国长途汽车时刻表查询——接口地址足球联赛(可在线调用):目前支持 英超，西甲，德甲，意甲，法甲，…——接口地址影视影讯(可在线调用):影视信息播放链接检索，城市影讯检索——接口地址标准电码查询(可在线调用):提供的标准中文电码查询程序结果——接口地址火车时刻表(可在线调用):火车时刻表，站到站检索——接口地址姓氏起源(可在线调用):《百家姓》是我国汉族姓氏总集，载有四百多…——接口地址短链接生成(可在线调用):查找网提供长的网址链接缩短为新浪短网扯，…——接口地址翻译(可在线调用):翻译API提供免费开放接口，覆盖中、英、…——接口地址乌云漏洞(可在线调用):查看乌云最新的安全漏洞——接口地址微信公众号查询(可在线调用):根据关键字搜索热门微信文章、微信公众号等…——接口地址在线分词(可在线调用):基于深度学习的中文在线抽词——接口地址MD5破解(可在线调用):md5密文：16位，32位,sha1(4…——接口地址星座配对(可在线调用):星座配对测姻缘——接口地址生肖配对(可在线调用):生肖配对测姻缘——接口地址获取外网IP信息(可在线调用):取得客户端访问互联网时的外网ip及对应的…——接口地址百度权重(可在线调用):根据网址查询百度权重——接口地址新闻头条(可在线调用):最新新闻头条——接口地址星座运势(可在线调用):黄道十二星座每日、每月、每年运势、不间断…——接口地址 2019.7.3更新接口 实时段子(可在线调用):实时段子,神评版本——接口地址音乐搜索(可在线调用):根据音乐名称返回音乐详情——接口地址小说查询(可在线调用):获取小说的详细信息——接口地址天气查询(可在线调用):获取最近天气情况——接口地址音悦tai搜索:音悦Tai-是以高清MV为主的娱乐视频网…——接口地址识别身份证文字(可在线调用):AI人工智能识别身份证图像文字 URL图…——接口地址编码解码:常见的编码和解码——接口地址网站备案查询:网站备案信息查询接口——接口地址身份证信息查询(可在线调用):身份证信息查询(不支持查询百岁老人)——接口地址图片PS:在线图片加文字,返回为字符串,需要处理下——接口地址一言:随机返回一句话——接口地址短链接生成与还原:短链接生成与还原，包括新浪、腾讯、百度——接口地址获取用户大致信息:获取用户信息如网络运营商等等——接口地址三合一收款码:包括支付宝，qq，微信——接口地址IP查询:根据ip地址获取其所在省市区——接口地址IP经纬度查询:根据ip地址和经纬度获取其所在省市区——接口地址 2019.8.7更新接口 淘宝ip(可在线调用):来自淘宝的ip查询，可以根据ip地址查询…——接口地址360ip(可在线调用):来自360的ip查询，可以根据ip地址查…——接口地址地理编码(可在线调用):将详细的结构化地址转换为高德经纬度坐标。…——接口地址逆地理编码(可在线调用):将经纬度转换为详细结构化的地址，且返回附…——接口地址步行路径规划:可以规划100KM以内的步行通勤方案，并…——接口地址驾车路径规划(可在线调用):规划以小客车、轿车通勤出行的方案，并且返…——接口地址公交路径规划:规划综合各类公共（火车、公交、地铁）交通…——接口地址骑行路径规划(可在线调用):用于规划骑行通勤方案，规划时不会考虑路况…——接口地址距离测量:根据经纬度测量距离——接口地址行政区域查询(可在线调用):根据用户输入的搜索条件可以帮助用户快速的…——接口地址矩形区域交通态势:能够确定矩形交通态势情况，路况信息2分钟…——接口地址圆形区域交通态势:能够确定圆形交通态势情况，路况信息2分钟…——接口地址指定线路交通态势:能够确定指定线路交通情况，路况信息2分钟…——接口地址输入提示(可在线调用):提供根据用户输入的关键词查询返回建议列表——接口地址天气查询(可在线调用):查询目标区域当前/未来的天气情况——接口地址IP定位(可在线调用):将IP信息转换为地理位置信息——接口地址地点范围查询(可在线调用):根据经纬度查询查询其地址相关信息——接口地址 2019.9.9更新接口 行政区划区域检索(可在线调用):开发者可通过该功能，检索某一行政区划内（…——接口地址圆形区域检索(可在线调用):开发者可设置圆心和半径，检索圆形区域内的…——接口地址矩形区域检索(可在线调用):开发者可设置检索区域左下角和右上角坐标，…——接口地址地点详情检索(可在线调用):地点详情检索针对指定POI，检索其相关的…——接口地址地点输入提示(可在线调用):用户可通过该服务，匹配用户输入关键词的地…——接口地址地理编码服务(可在线调用):用户可通过该功能，将结构化地址（省/市/…——接口地址全球逆地理编码(可在线调用):用户可通过该功能，将位置坐标解析成对应的…——接口地址公交路线规划(可在线调用):根据起点和终点检索符合条件的公共交通方案…——接口地址骑行路线规划(可在线调用):根据起终点坐标检索符合条件的骑行路线规划…——接口地址驾车路线规划(可在线调用):根据起终点坐标检索符合条件的驾车路线规划…——接口地址批量算路:用户可通过该服务，根据起点和终点坐标计算…——接口地址普通IP定位(可在线调用):用户可以通过该服务，根据IP定位来获取大…——接口地址道路实时路况查询(可在线调用):查询具体道路的实时拥堵评价和拥堵路段、拥…——接口地址时间偏移查询(可在线调用):查询坐标所在地与协调世界时的时间偏移信息…——接口地址周边上车点推荐(可在线调用):用户可通过该功能检索坐标点周围的上车点。…——接口地址非百度坐标系转换(可在线调用):用户可通过该服务，实现 非百度坐标系→百…——接口地址快递查询(可在线调用):可根据快递单号查询大部分主流快递的快递信…——接口地址文件转换:文件转换成指定格式，成功则返回成功转换的…——接口地址获取文件转换内容:根据文件转换成功所获取的id，查询转换成…——接口地址 2019.10.8更新接口 全球IP地理位置(可在线调用):单个IPv4 / IPv6地址或域名…——接口地址域名备案(可在线调用):根据域名查询域名备案状态——接口地址十五天天气预报:采用城市ID来精准查询15天内的天气，接…——接口地址农历查询(可在线调用):根据日期获取农历、黄历、禁忌、星期、生肖…——接口地址ICP备案查询(可在线调用):根据域名查询ICP备案号——接口地址三合一收款二维码:将QQ、微信、支付宝收款集合到一起，省去…——接口地址二维码生成:将网址直接转换成二维码图片——接口地址二维码解码(可在线调用):将二维码图片进行解码，解析处理——接口地址短网址生成(可在线调用):将长网址进行缩短，支持百度、新浪、腾讯短…——接口地址短网址还原(可在线调用):将缩短的短网址进行还原,支持常见的短网址——接口地址网易云音乐随机歌曲(可在线调用):网易云音乐，随机歌曲输出——接口地址获取访客相关信息(可在线调用):根据访客IP地址，操作系统，浏览器，访问…——接口地址随机头像输出(可在线调用):随机头像输出——接口地址 2019.11.5更新接口 文章短篇:根据日期获取一篇文章，有网上的，也有名家…——接口地址必应故事:随机获取来自必应的故事，可根据pid获取…——接口地址每日一言:获取来自一言、有道或金山词霸的每日一言内…——接口地址二维码解析:还原二维码的原始URL，支持支付宝，微信…——接口地址生成海报:根据提交的内容格式化生成可分享的精美海报——接口地址历史上的今天:历史上的今天——接口地址生成二维码:可根据传入的内容，生成对应的二维码，还可…——接口地址IP地址详情信息:IP地址详情信息查询——接口地址XLS生成:生成XLS——接口地址土味情话:和妹妹说的情话，返回一句随机的内容——接口地址随机笑话(可在线调用):随机的笑话——接口地址 2019.12.4更新接口 经纬度信息(可在线调用):获取当前经纬度信息——接口地址历史上的今天(可在线调用):历史上的今天——接口地址Bing 壁纸获取(可在线调用):获取最近的Bing 壁纸——接口地址天气查询(可在线调用):获取今天和未来三天的天气情况，来源于高德——接口地址天气查询(可在线调用):根据城市名，获取今天和未来三天的天气情况…——接口地址天气查询(可在线调用):根据城市id，获取未来15天的天气情况，…——接口地址手机归属地查询(可在线调用):根据手机号码查询手机号的归属地信息——接口地址手机归属地查询:根据手机号码查询手机号的归属地信息，来源…——接口地址IP域名归属地查询(可在线调用):查询IP或者域名归属地——接口地址身份证查询(可在线调用):根据身份证获取该身份证号码的籍贯，出生年…——接口地址淘宝关键字(可在线调用):淘宝搜索关键字——接口地址百度关键字:百度搜索关键字——接口地址Bing关键字(可在线调用):Bing搜索关键字——接口地址获取用户设备信息(可在线调用):通过 user-agent 分析用户设备…——接口地址百度音乐搜索(可在线调用):根据关键字获取音乐的相关信息——接口地址 努力添加中…… 原文链接：https://github.com/fangzesheng/free-api欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"API","slug":"API","permalink":"http://www.ergzcode.com/tags/API/"}],"author":"ergz"},{"title":"PM2介绍","slug":"pm2-common-commands-introduction","date":"2019-12-10T03:22:00.000Z","updated":"2019-12-29T09:26:24.318Z","comments":true,"path":"2019/12/10/pm2-common-commands-introduction.html","link":"","permalink":"http://www.ergzcode.com/2019/12/10/pm2-common-commands-introduction.html","excerpt":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 )","text":"pm2 是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 主要特性：1.内建负载均衡（使用Node cluster 集群模块）2.后台运行3.0秒停机重载，我理解大概意思是维护升级的时候不需要停机4.具有Ubuntu和CentOS的启动脚本5.停止不稳定的进程（避免无限循环）6.控制台检测7.提供 HTTP API8.远程控制和实时的接口API(Nodejs模块,允许和PM2进程管理器交互 ) 安装1npm install -g pm2 #命令行安装pm2 用法123456789101112131415161718192021222324252627282930pm2 start app.js -i 4 #后台运行pm2，启动4个app.jspm2 start app.js --name my-api #命名进程pm2 list #显示所有进程状态pm2 monit #监视所有进程pm2 logs #显示所有进程日志pm2 stop all #停止所有进程pm2 restart all #重启所有进程pm2 reload all #0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0 #停止指定的进程pm2 restart 0 #重启指定的进程pm2 startup #产生 init 脚本 保持进程活着pm2 web #运行健壮的 computer API endpointpm2 delete 0 #杀死指定的进程pm2 delete all #杀死全部进程运行进程的不同方式：pm2 start app.js -i max #根据有效CPU数目启动最大进程数目pm2 start app.js -i 3 #启动3个进程pm2 start app.js -x #用fork模式启动 app.js 而不是使用 clusterpm2 start app.js -x -- -a 23 #用fork模式启动 app.js 并且传递参数 (-a 23)pm2 start app.js --name serverone #启动一个进程并把它命名为 serveronepm2 stop serverone #停止serverone进程pm2 start app.json #启动进程, 在app.json里设置选项pm2 start app.js -i max -- -a 23 #在--之后给app.js传递参数pm2 start app.js -i max -e err.log -o out.log #启动 并生成一个配置文件你也可以执行用其他语言编写的app ( fork 模式):pm2 start my-bash-script.sh -x --interpreter bashpm2 start my-python-script.py -x --interpreter pythonpm2 list #列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次pm2 monit #监视每个node进程的CPU和内存的使用情况。 本文链接：PM2介绍欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"}],"author":"ergz"},{"title":"PM2守护hexo的进程","slug":"pm2-watch-hexo-process","date":"2019-12-08T00:01:00.000Z","updated":"2019-12-29T09:26:10.070Z","comments":true,"path":"2019/12/08/pm2-watch-hexo-process.html","link":"","permalink":"http://www.ergzcode.com/2019/12/08/pm2-watch-hexo-process.html","excerpt":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2","text":"在服务器上安装好了hexo，执行hexo sever来启动它的服务，会发现过了一段时间hexo的进程总是莫名其妙的挂掉，然后导致网站无法访问。从网上搜索了一些解决方案，发现能使用PM2来接管hexo的后台进程，从而让hexo进程一直常驻后台。 操作步骤如下： 1.首先安装pm21npm install -g pm2 2.写一个shell hexo_daemon.js12345678910//runconst &#123; exec &#125; = require('child_process')exec('hexo server -p 80 &amp; ',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 3.在根目录下执行shell1pm2 start hexo_daemon.js 本文链接：PM2守护hexo的进程欢迎转载，请注明出处！参考:PM2使用","categories":[{"name":"shell","slug":"shell","permalink":"http://www.ergzcode.com/categories/shell/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.ergzcode.com/tags/pm2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.ergzcode.com/tags/hexo/"}],"author":"ergz"},{"title":"Git常用命令使用","slug":"git-orders_02","date":"2019-11-26T14:26:00.000Z","updated":"2019-12-31T08:56:23.134Z","comments":true,"path":"2019/11/26/git-orders_02.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-orders_02.html","excerpt":"1.查看工作区的状态$ git status 2.查看文件具体修改了什么内容$ git diff &lt;file&gt; 3.查看提交的历史记录该命令显示从最近到最远的历史记录：$ git log。如果嫌输出信息太多，可以试试加上--pretty=oneline参数：$ git log --graph --pretty=oneline --abbrev-commit，命令如下： 123$ git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示","text":"1.查看工作区的状态$ git status 2.查看文件具体修改了什么内容$ git diff &lt;file&gt; 3.查看提交的历史记录该命令显示从最近到最远的历史记录：$ git log。如果嫌输出信息太多，可以试试加上--pretty=oneline参数：$ git log --graph --pretty=oneline --abbrev-commit，命令如下： 123$ git log --graph --pretty=oneline --abbrev-commiteede197ffb267fbda60482da9554ba654ff523e3 init hexo repo1f2508638115730cb301f73c51b9971fca5c7f09 Initial commit 上面输出的一大串数字其实是 commit id(版本号)，这是一个SHA1计算出来的一个非常大的数字，用十六进制表示 4.回退版本$ git reset在git中用HEAD表示当前版本，HEAD^表示上个版本，HEAD^^表示上上版本……以此类推，HEAD~100表示往上100个版本现在我们用命令回退到上个版本： 12$ git reset --hard HEAD^HEAD is now at 1f2508 可以根据版本号commit id指定回退到某个版本：$ git reset --hard eede19这里的版本号没必要写全，前几位就可以了，Git会自动去找，这样我们就又回到最新的版本了。Git版本的回退速度非常快，在Git内部有个指向当前版本的指针HEAD，所以我们在进行版本回退或回到最新的版本的时候，Git只是帮我们将HEAD指针指向某个版本号。 5.记录你的每一条命令$ git reflog可以查看commit id,提交具体的操作和提交输入的信息，命令如下： 12345$ git reflog eede197 HEAD@&#123;0&#125;: rebase finished: returning to refs/heads/mastereede197 HEAD@&#123;1&#125;: pull --rebase origin master: init hexo repo1f25086 HEAD@&#123;2&#125;: pull --rebase origin master: checkout 1f2508638115730cb301f73c51b9971fca5c7f09fe14566 HEAD@&#123;3&#125;: commit (initial): init hexo repo 6.丢弃工作区的修改$ git checkout -- &lt;file&gt;文件修改还没有添加到暂存区，命令如下： 1$ git checkout -- readme.txt 当文件修改后已经添加到了暂存区又作了修改，现在撤销修改就回到添加到暂存区后的状态。 7.把添加到暂存区的内容撤销$ git reset HEAD &lt;file&gt; HEAD表示当前分支的最新提交 8.分支 查看分支：$ git branch 创建分支：$ git branch &lt;name&gt;。我们创建新分支dev时，Git会新建一个指针叫dev，指向当前分支master的相同的提交点（HEAD指针指向的是当前分支），再把HEAD指向dev，之后的操作就在dev分支上完成，如图： 切换分支：$ git checkout &lt;name&gt; OR $ git switch &lt;name&gt; 创建并切换分支：$ git checkout -b &lt;name&gt; OR $ git switch -c &lt;name&gt; 合并分支到当前分支:$ git merge &lt;name&gt;。当dev分支开发结束后，我们需要把dev分支合并到master（主分支）上，Git是如何操作的呢？Git直接把master指向dev的当前提交，就完成了合并，这些操作都是靠指针来完成，文件并没有发生变化，如图：分支合并时，Git默认使用Fast forward模式，使用这种模式，删除分支后，会丢掉分支的历史信息，使用--no-ff可以禁用Fast forward模式 $ git merge --no-ff -m &quot;merge with no-ff&quot; dev，这样每次合并会创建一个新的commit，加上-m参数，写上commit的描述。 删除分支：$ git branch -d &lt;name&gt;。合并完分支后就可以删除dev分支，删除dev分支就是把dev指针给删掉，删掉后我们就剩下了一条master分支，如图： 12.查看分支合并图：$ git log --graph 9.标签 新建一个标签，默认为HEAD,也可以指定一个commit id:$ git tag &lt;tagname&gt; &lt;commit&gt;,不指定commit id时，默认标签是打在最新提交的commit上 创建带有说明的标签，用-a指定标签名，-m指定说明文字:$ git tag -a &lt;tagname&gt; -m &quot;tag message&quot; &lt;commit&gt; 查看所有标签：$ git tag 删除指定标签：$ git tag -d &lt;tagname&gt; 推送某个标签到远程：$ git push &lt;remote&gt; &lt;tagname&gt; 一次性推送全部尚未推送到远程的本地标签:$ git push &lt;remote&gt; --tags 删除远程标签,先从本地删除:$ git tag -d &lt;tagname&gt; ，然后 $ git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 10.cherry-pick从不同的分支里选择某次提交并且把它合并到当前的分支。首先切换到我想要放入该提交的分支，然后执行如下命令：$ git cherry-pick [commit_hash] 团队协作的分支开发流程图，如图： 本文链接：Git常用命令使用欢迎转载，请注明出处！参考：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}]},{"title":"工作中99%能用到的Git命令","slug":"git-orders_01","date":"2019-11-26T13:58:00.000Z","updated":"2019-12-31T09:19:03.086Z","comments":true,"path":"2019/11/26/git-orders_01.html","link":"","permalink":"http://www.ergzcode.com/2019/11/26/git-orders_01.html","excerpt":"分支操作： git branch 创建分支 git branch -b 创建并切换到新建的分支上 git checkout 切换分支 git branch 查看分支列表 git branch -v 查看所有分支的最后一次操作 git branch -vv 查看当前分支 git brabch -b 分支名 origin/分支名 创建远程分支到本地 git branch –merged 查看别的分支和当前分支合并过的分支 git branch –no-merged 查看未与当前分支合并的分支 git branch -d 分支名 删除本地分支 git branch -D 分支名 强行删除分支 git branch origin 分支名 删除远处仓库分支(不可用) git push origin :分支名 删除远处仓库分支（可用），冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支 git merge 分支名 合并分支到当前分支上","text":"分支操作： git branch 创建分支 git branch -b 创建并切换到新建的分支上 git checkout 切换分支 git branch 查看分支列表 git branch -v 查看所有分支的最后一次操作 git branch -vv 查看当前分支 git brabch -b 分支名 origin/分支名 创建远程分支到本地 git branch –merged 查看别的分支和当前分支合并过的分支 git branch –no-merged 查看未与当前分支合并的分支 git branch -d 分支名 删除本地分支 git branch -D 分支名 强行删除分支 git branch origin 分支名 删除远处仓库分支(不可用) git push origin :分支名 删除远处仓库分支（可用），冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支 git merge 分支名 合并分支到当前分支上 暂存操作： git stash 暂存当前修改 git stash apply 恢复最近的一次暂存 git stash pop 恢复暂存并删除暂存记录 git stash list 查看暂存列表 git stash drop 暂存名(例：stash@{0}) 移除某次暂存 git stash clear 清除暂存 回退操作： git reset –hard HEAD^ 回退到上一个版本 git reset –hard ahdhs1(commit_id) 回退到某个版本 git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态) git reset HEAD file 撤回暂存区的文件修改到工作区 标签操作： git tag 标签名 添加标签(默认对当前版本) git tag 标签名 commit_id 对某一提交记录打标签 git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注 git tag 列出所有标签列表 git show 标签名 查看标签信息 git tag -d 标签名 删除本地标签 git push origin 标签名 推送标签到远程仓库 git push origin –tags 推送所有标签到远程仓库 git push origin :refs/tags/标签名 从远程仓库中删除标签 常规操作： git push origin test 推送本地分支到远程仓库 git rm -r –cached 文件/文件夹名字 取消文件被版本控制 git reflog 获取执行过的命令 git log –graph 查看分支合并图 git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录 git check-ignore -v 文件名 查看忽略规则 git add -f 文件名 强制将文件提交 git创建项目仓库： git init 初始化 git remote add origin url 关联远程仓库 git pull git fetch 获取远程仓库中所有的分支到本地 忽略已加入到版本库中的文件： git update-index –assume-unchanged file 忽略单个文件 git rm -r –cached 文件/文件夹名字 (. 忽略全部文件) 取消忽略文件： git update-index –no-assume-unchanged file 拉取、上传免密码： git config –global credential.helper store 原文链接：https://www.cxiansheng.cn/daily/490欢迎转载，请注明出处！","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}],"author":"ergz"},{"title":"GIT命令清单","slug":"git-cheat-sheet","date":"2019-11-24T17:20:00.000Z","updated":"2019-12-30T06:57:37.642Z","comments":true,"path":"2019/11/25/git-cheat-sheet.html","link":"","permalink":"http://www.ergzcode.com/2019/11/25/git-cheat-sheet.html","excerpt":"文档来源于Tower&gt;Git版本控制系统-使一切变的简单 英文原版下载地址：http://cdn.ergzcode.com/git/git-cheatsheet.pdf 由ergzC0de翻译，如有错误之处，欢迎留言指正 1.创建库克隆一个现有版本库 $ git clone ssh://user@domain.com/repo.git","text":"文档来源于Tower&gt;Git版本控制系统-使一切变的简单 英文原版下载地址：http://cdn.ergzcode.com/git/git-cheatsheet.pdf 由ergzC0de翻译，如有错误之处，欢迎留言指正 1.创建库克隆一个现有版本库 $ git clone ssh://user@domain.com/repo.git 创建一个本地版本库 $ git init 2.本地更改查看工作区的状态 $ git status 查看被跟踪的文件更改了什么内容 $ git diff &lt;file&gt;添加所有的文件修改到暂存区 $ git add . 指定某个文件添加到暂存区，-p参数可省略 $ git add -p &lt;file&gt; 提交跟踪文件中的所有本地更改，建议一般不使用-a参数 $ git commit -a将暂存区里的更改给提交到本地版本库，-m参数指定提交信息 $ git commit -m &quot;message&quot;更改最后一次提交,不修改已发布的提交,也就是追加提交，不会增加新的commit id将新的修改追加到前一次的commit id中 $ git commit --amend3.提交历史显示提交的日志 $ git log某个文件的提交日志 $ git log -p &lt;file&gt;何人何时修改的某个文件日志 $ git blame &lt;file&gt;4.分支和标签列出所有的分支 $ git branch -av 切换当前分支 $ git checkout &lt;branch&gt;创建新分支 $ git branch &lt;new-branch&gt;基于远程分支创建一个新的跟踪分支 $ git checkout --track &lt;remote/branch&gt;删除一个分支 $ git branch -d &lt;branch&gt;给当前提交贴一个标签，常用于发布版本 $ git tag &lt;tag-name&gt;5.更新和发布列出所有当前配置的远程地址 $ git remote -v显示某个远程地址的信息 $ git remote show &lt;remote&gt;关联一个远程库，一般别名用origin $ git remote add &lt;shortname&gt; &lt;url&gt;从远程库下载所有的更改，但不合并到当前分支上 $ git fetch &lt;remote&gt;从远程库下载所有的更改并直接合并到当前分支上 $ git pull &lt;remote&gt; &lt;branch&gt;推送本地修改到远程库 $ git push &lt;remote&gt; &lt;branch&gt;删除远程库的分支 $ git branch -dr &lt;remote/branch&gt;推送标签 $ git push --tags6.分支和重定合并指定分支到当前分支上 $ git merge &lt;branch&gt;将最新的分支提交到本地 $ git rebase &lt;branch&gt;中止一个rebase $ git rebase --abort解决冲突后继续重新执行rebase $ git rebase --continue使用您配置的合并工具来解决冲突 $ git mergetool使用您的编辑器手动解决冲突和(解决后)标记文件作为解决 $ git add &lt;resolved-file&gt; $ git rm &lt;resolved-file&gt;7.撤销（回退）撤销工作区的所有本地更改 $ git reset --hard HEAD丢弃工作区的修改，文件修改还没有添加到暂存区,推荐第2种 $ git checkout HEAD &lt;file&gt; or $ git checkout -- &lt;file&gt;还原提交(通过产生具有相反更改的新提交) $ git revert &lt;commit&gt;回退到某个版本 //回退到上个版本 $ git reset --hard HEAD^ //根据指定commit id回退版本 $ git reset --hard &lt;commit&gt;保存未添加暂存区的所有更改 $ git reset &lt;commit&gt;保存未提交的本地更改 $ git reset --keep &lt;commit&gt;把添加到暂存区的内容撤销（补充） $ git reset HEAD &lt;file&gt;本文链接：GIT命令清单欢迎转载，请注明出处！","categories":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.ergzcode.com/tags/git/"}],"author":"ergz"},{"title":"Nginx搭建HTTP文件服务器","slug":"nginx-build-http-file-system","date":"2019-11-14T08:04:00.000Z","updated":"2019-12-29T09:25:33.242Z","comments":true,"path":"2019/11/14/nginx-build-http-file-system.html","link":"","permalink":"http://www.ergzcode.com/2019/11/14/nginx-build-http-file-system.html","excerpt":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署","text":"介绍Nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时能提供了IMAP/POP3/SMTP服务，Nginx的优点： 1.高性能，支持高并发连接2.低资源消耗，内存占用少3.稳定性高4.配置简单5.支持热部署 使用1.检查Nignx是否安装使用以下命令检查Nginx服务器状态： 1systemctl status nginx 2.安装Nginx(ubuntu)命令： 1sudo apt-get install nginx Ubuntu安装之后的文件结构大致为： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 程序文件/usr/sbin/nginx 日志在/var/log/nginx目录中 启动脚本nginx在/etc/init.d/下 默认的虚拟主机的目录设置在了/var/www/nginx-default (有的版本默认的虚拟主机的目录设置在了/var/www, 请参考/etc/nginx/sites-available里的配置) 在/etc/nginx目录下，nginx.conf是Nginx的核心配置文件，可以修改处理器数量、日志路径、pid文件等。在nginx.conf文件中有一段代码：inxclude /etc/nginx/conf.d/*.conf,这表示可以将自己的配置文件放在conf.d/中，Nginx会自动识别这个配置文件 3.修改配置文件vim /etc/nginx/sites-available/default 12345678910111213141516server &#123; listen 8080 default_server; listen [::]:8080 default_server; #root /usr/share/nginx/html; root /usr/local/data/file; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; autoindex on;#显示目录 autoindex_exact_size on;#显示文件大小 autoindex_localtime on;#显示文件时间 charset utf-8; &#125;&#125; 4.启动nginx1/etc/init.d/nginx start 5.浏览器访问浏览器打开：http://localhost:8080可以看到/data/file目录下的文件，点击可下载 6.修改配置后重载1/etc/init.d/nginx reload 本文链接：Nginx搭建HTTP文件服务器欢迎转载，请注明出处！","categories":[{"name":"linux","slug":"linux","permalink":"http://www.ergzcode.com/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.ergzcode.com/tags/Nginx/"}],"author":"ergz"},{"title":"图解SQL的各种join用法","slug":"diagrams-for-various-join-uses-of-sql","date":"2019-11-09T07:50:00.000Z","updated":"2019-12-18T15:43:04.408Z","comments":true,"path":"2019/11/09/diagrams-for-various-join-uses-of-sql.html","link":"","permalink":"http://www.ergzcode.com/2019/11/09/diagrams-for-various-join-uses-of-sql.html","excerpt":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法","text":"下图展示了LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法 具体分解如下：1.INNER JOIN（内连接） 1234SELECT &lt;select_list&gt; FROM Table_A AINNER JOIN Table_B BON A.Key = B.Key 2.LEFT JOIN（左连接） 1234SELECT &lt;select_list&gt;FROM Table_A ALEFT JOIN Table_B BON A.Key = B.Key 3.RIGHT JOIN（右连接） 1234SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.Key 4.OUTER JOIN（外连接） 1234SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.Key 5.LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接） 12345SELECT &lt;select_list&gt; FROM Table_A ALEFT JOIN Table_B BON A.Key = B.KeyWHERE B.Key IS NULL 6.RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL 7.OUTER JOIN EXCLUDING INNER JOIN（外连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL OR B.Key IS NULL 原文链接：看一张图秒懂SQL的各种JOIN用法欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://www.ergzcode.com/tags/sql/"}],"author":"ergz"},{"title":"IDEA常用快捷键","slug":"idea-keyboard-shortcuts_01","date":"2019-06-08T10:27:00.000Z","updated":"2019-12-31T10:37:02.124Z","comments":true,"path":"2019/06/08/idea-keyboard-shortcuts_01.html","link":"","permalink":"http://www.ergzcode.com/2019/06/08/idea-keyboard-shortcuts_01.html","excerpt":"快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标的下一行 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按一次取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按一次取消注释 Alt+Ins 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 移动当前代码行 Shift+F6 鼠标选中全局修改名称","text":"快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标的下一行 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按一次取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按一次取消注释 Alt+Ins 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 移动当前代码行 Shift+F6 鼠标选中全局修改名称 更新… 本文链接：IDEA常用快捷键欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.ergzcode.com/tags/IDEA/"}],"author":"ergz"},{"title":"面试官：Maven的jar包冲突如何解决","slug":"java-interview_0029","date":"2019-01-31T08:58:00.000Z","updated":"2020-01-04T09:04:45.169Z","comments":true,"path":"2019/01/31/java-interview_0029.html","link":"","permalink":"http://www.ergzcode.com/2019/01/31/java-interview_0029.html","excerpt":"介绍本文主要介绍了解决Maven中jar包冲突的几种方式 依赖传递假设我们现在又一个多模块的项目，依赖关系如下，我们在st-web模块中引入st-dal依赖时，st-common-lib这个依赖也会被我们引入，这个就是依赖传递。下表列出了scope在依赖过程中发生的变化，列标题为被依赖的模块，每行为要依赖的模块","text":"介绍本文主要介绍了解决Maven中jar包冲突的几种方式 依赖传递假设我们现在又一个多模块的项目，依赖关系如下，我们在st-web模块中引入st-dal依赖时，st-common-lib这个依赖也会被我们引入，这个就是依赖传递。下表列出了scope在依赖过程中发生的变化，列标题为被依赖的模块，每行为要依赖的模块 st-common-lib &lt;- st-dal &lt;- st-web [scope] compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime 依赖仲裁依赖仲裁就是当项目中引入的jar包，groupID（公司名倒过来）和artifactID（功能命令）一样，但是version不一样，应该选用哪一个version？经常也被人叫做依赖冲突 最短路径原则 假如说我们现在的项目依赖关系如下，那么maven会选用st-common-lib的那个版本呢？ 答案是1.1这个版本，st-web到st-common-lib（1.1）的距离为1，st-web到st-common-lib（1.0）的距离为2，选用距离短的，即最短路径原则 st-common-lib(1.0) &lt;- st-dal &lt;- st-web -&gt; st-common-lib(1.1) 如何看出依赖的距离关系呢？之前的一篇关于maven的文章说过，执行如下命令打印出全局的依赖树，层级关系特别清楚mvn dependency：tree &gt; show.txt 声明优先原则 项目依赖如下，路径一样？会选用st-common-lib的哪个版本呢？这就得看你在pom文件中先声明哪个依赖，如果在pom.xml文件中，st-remote-invoke写在前面，就会用1.0这个版本，如果st-dal写在前面，则会用1.1这个版本 st-common-lib（1.0） &lt;- st-remote-invoke &lt;- st-webst-common-lib（1.1） &lt;- st-dal &lt;- st-web 依赖排除 去掉间接引入的jar包 如果不想用spring boot默认提供的log，想集成第三方的log时 或者说上面依赖仲裁的第二个例子中，只想用st-common-lib的1.1版本，就可以把1.0版本排除 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;本文链接：面试官：Maven的jar包冲突如何解决欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：mvn package和mvn install都能打包，他们有区别吗","slug":"java-interview_0028","date":"2019-01-30T08:50:00.000Z","updated":"2020-01-04T08:57:38.197Z","comments":true,"path":"2019/01/30/java-interview_0028.html","link":"","permalink":"http://www.ergzcode.com/2019/01/30/java-interview_0028.html","excerpt":"介绍我们用maven打包一般用如下2个命令 mvn clean package 清理打包mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 区别就是install比package多了一步将打好的jar包放到本地仓库的过程 我从头说一下maven帮我们做了那些，并解释一下maven的工程流程","text":"介绍我们用maven打包一般用如下2个命令 mvn clean package 清理打包mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 区别就是install比package多了一步将打好的jar包放到本地仓库的过程 我从头说一下maven帮我们做了那些，并解释一下maven的工程流程 没有Maven之前的日子个人的一个小感受，学习一个新技术，应该以历史的眼光来看待这个新技术出现的原因，以及帮我们解决了什么问题。我们来回忆一下没有Maven的日子是怎么样的？ 开发一个项目，需要用别人写好的jar包，我们先把开源的jar包下载下来放到项目的lib目录下，并且把这个目录添加到classpath（告诉Java执行环境，在哪些目录下可以找到你要执行的Java程序需要的类或者包）。我们下载了a.jar发现a.jar还需要依赖b.jar，结果又去把b.jar下载下来开始运行。如果运气够好，我们项目在添加完所有的依赖后，能正常运行了。如果运气不好，还会遇到jar包版本的问题，例如a.jar在调用b.jar的时候发现b.jar根本没有这个方法，在别的版本中才有，现在好了，光找依赖和适配版本就能花上不少时间。而且我们往git上上传代码的时候，还必须把这些lib都上传上去。别人下载我们的代码也必须把lib下载下来，这个真心耗费时间 这时候Maven作为Java世界包管理工具出现了，当然Java的世界还有其他的包管理工具，例如gradle等。就像yum是Linux世界的包管理工具，webpack是前端世界的包管理工具一样 Maven仓库的种类本地仓库，私服，中央仓库Maven找jar包的过程是这样的，先在本地仓库找，找不到再去私服(如果配置了的话)，再找不到去中央仓库（Maven团队维护中） 从中央仓库找到后，会在私服和本地仓库放一份，从私服找到后也会在本地仓库放一份 当你安装好了Maven后，在conf目录下有个settings.xml文件，这个里面的配置的项很多，后文会详细介绍这个配置文件 &lt;!-- localRepository --&gt; Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;在这个配置文件下有这样的一段话，说了Maven默认的本地仓库的地址为${user.home}/.m2/repository（当然你可以重新设置本地仓库的地址，上面就是模板），我是windows电脑，来看看这个目录可以看到很多jar包被存在本地，当然如果你想配置私服也是在settings.xml进行配置，随便一搜很多教程，不再赘述 搭建私服好处多多，在一个公司内部可以开发一些公共的基础组件放到私服上，方便其他同事使用 Maven的默认配置一个Maven的项目整体结构是这样的 在这里插入图片描述（图片省略…） 为什么一个Maven项目的文件结构是这种的呢？ 这里就不得不说Maven的一个特性，约定优于配置 Maven默认配置了：${project.basedir}/src/main/java为项目的源代码目录${project.basedir}/src/main/test为项目的测试源代码目录${project.basedir}/target为项目的编译输出目录等 spring boot 就是约定优于配置的体现，想想我们用springMVC的时候还得配置视图解析器，包的自动扫描，而用spring boot框架后，我们就完全不用再配置了 Maven的项目详解安装还是挺简单的，我就不再介绍了，我也没有单独下载，一般就有了idea自带的Maven插件，下载完后目录结构如下：bin目录该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。 boot目录该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的Java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库 conf目录该目录包含了一个非常重要的文件settings.xml文件。直接修改该文件，就能在机器上全局的定制Maven的行为，即对所有用户都生效。一般情况下，我们更偏向于复制该文件至/.m2/目录下（表示用户家目录，windows下~就是C:\\Users{用户名}），然后修改该文件，在用户级别定制Maven的行为。 lib目录该目录包含了所有Maven运行需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar，maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如common-cli-1.2.jar,common-lang-2.6.jar等等。 settings.xml配置文件详解我们来细说一下settings.xml文件，这个文件可以定制Maven的行为，上面已经说到settings.xml可以可以放在2个位置，~/.m2/settings.xml(默认没有，需要我们自己复制)和${maven.home}/conf/settings.xml 这2个配置文件的加载顺序为~/.m2/settings.xml &gt; ${maven.home}/conf/settings.xml，为了不影响他人，所以我们将conf下的settings.xml配置文件复制到家目录，在用户级别定制Maven的行为 这个和配置环境变量有点类似，Windows和Linux都可以配置系统级别的环境变量和用户级别的环境变量，这里单说一下Linux的吧，在/etc/profile里面配置的就是系统级别的环境变量，在~/.bash_profile里面配置的就是用户级别的环境变量 各种配置项还是挺多的，设置镜像仓库（国内用阿里云的比较多），设置代理，不再赘述 Maven常用命令 命令 描述 mvn -version 显示版本信息 mvn clean 删除target目录 mvn compile 编译src/main/java下的代码 mvn package 打包，在target目录下生成jar或war包 mvn test 执行src/test/java下以Test开头或者以Test结尾的的测试用例 mvn install 打包，并把jar或war包复制到本地仓库，供其他模块引用 mvn deploy 将打包的文件发到私服 mvn dependency：tree 打印出项目整个依赖树 当然也可以连着使用mvn clean package 清理打包mvn clean package -DskipTest=true 清理打包，并跳过测试用例mvn clean install 清理打包，并将jar包或者war包复制到本地仓库 运行单元测试的时候也没必要一个一个的点击测试方法，mvn test一个命令跑完所有的测试用例，要注意的是只会执行以Test开头或者结尾的测试类，也没必要自己写测试类，网上有些文章介绍了快速生成测试类的方法，可以去搜索看看，生成的测试类都是以Test开头或结尾的，这里不再赘述。 mvn dependency:tree &gt; show.txt将项目的整个依赖重定向到文件中，方便查看 本文链接：面试官：mvn package和mvn install都能打包，他们有区别吗欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：每次你可以爬1或者2个台阶，爬到第n级台阶有多少种方法","slug":"java-interview_0019","date":"2019-01-29T07:38:00.000Z","updated":"2019-12-31T10:36:02.184Z","comments":true,"path":"2019/01/29/java-interview_0019.html","link":"","permalink":"http://www.ergzcode.com/2019/01/29/java-interview_0019.html","excerpt":"介绍这是leeCode的第70题 题目描述 假设你正在爬楼梯。需要n阶你才能到达楼顶。 每次你可以爬1或者2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定n是一个正整数。 示例1： 输入：2 输出：2 解释：有两种方法可以爬到楼顶。 1.1阶 + 1阶 2.2阶","text":"介绍这是leeCode的第70题 题目描述 假设你正在爬楼梯。需要n阶你才能到达楼顶。 每次你可以爬1或者2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定n是一个正整数。 示例1： 输入：2 输出：2 解释：有两种方法可以爬到楼顶。 1.1阶 + 1阶 2.2阶 示例2： 输入：3 输出：3解释：有三种方法可以爬到楼顶。 1.1阶 + 1阶 + 1阶 2.1阶 + 2阶 3.2阶 + 1阶思路分析这是一个简单的递推题目，搞懂了其实就是一个斐波那契数列。你想的没错，就是你开始学编程时，那个兔子繁殖的问题。 如果一开始有一对兔子，他们每月生育一对兔子，小兔出生后一个月又开始生育繁殖的情况与最初的那对兔子一样，那么一年后有多少对兔子呢？ 答案是，每月兔子的总数可以用一下数列表示：1，1，2，3，5，8，13，21，34，55，89，144，233… 来想一下，第n阶台阶可以从那一节上爬上来?只能是n-1和n-2啊，所以我们就能得到递推公式f(n)=f(n-1)+f(n-2),f(n)表示到n阶台阶方法数，这不就是典型的斐波那契数列吗？有意思的是斐波那契数列有很多种实现方法，看来一一道来。 第一种：递归 递归出口是当n=1的值为1，当n=2时值为2 class solution{ public int climbStairs(int n){ if(n==1||n==2) return n; } return climbStairs(n-1)+climbStairs(n-2); }这种代码在Leecode上会超时，因为递归比较耗时和耗内存。面试的时候也不要回答这种方法。 第二种：递推当n=1值为1，当n=2时值为2 当n&gt;=3的递推公式是f(n)=f(n-1)+f(n-2) public class solution{ public int climbStairs(int n){ if(n==1) return 1; } int[] f = new int[n+1]; f[1]=1; f[2]=2; for (int i = 3; i &lt;= n; i++) { f[i] = f[i-2] + f[i-1]; } return f[n]; }一般回答这种方式即可，时间复杂度为O(n) 第三种 通向公式 很多人其实并不知道有通向公式，通向公式如下 递推过程就不分析了，写这种算法是因为你可以和面试官说一波，因为很多面试官其实也不知道这种方法 public static int climbStaris1(int n){ double sqrt5=Math.sqrt(5); double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1); return (int) (fibn/sqrt5); } public static void main(String[] args) { System.out.println(climbStaris1(4)); }矩阵快速幂 这种算法用了矩阵乘法的思想，因为要讲清楚还得复习一遍高等数学的矩阵乘法，面试也很少写这种算法，就不再解释了，有兴趣的可以找相关的资料来看，面试中一般用递推打出来就行。面大厂的可以看一波这个算法，偶尔会问的深一点。 本文链接：面试官：每次你可以爬1或者2个台阶，爬到第n级台阶有多少种方法欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：写一下单例模式吧，知道单例模式有几种写法吗","slug":"java-interview_0012","date":"2019-01-28T04:24:00.000Z","updated":"2019-12-31T05:29:06.741Z","comments":true,"path":"2019/01/28/java-interview_0012.html","link":"","permalink":"http://www.ergzcode.com/2019/01/28/java-interview_0012.html","excerpt":"参考之前的一篇文章：深入Java单例模式 介绍设计模式很多，单例模式绝对是问的最多的一个了，也是让手写的最多的一个设计模式。很多人只会写双重检测的设计模式，但问的深一点其实很多人答不上来。比如，变量为什么要用volatile修饰，为什么要写2个if，一个if不行吗？还有就是单例模式有很多种写法。我以演进的方式写一个单例模式的5种写法，面试的时候建议写双重检测的写法和静态内部类的写法。 有一些对象其实我们只需要一个，比如说：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能看到一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者不一致的结果。","text":"参考之前的一篇文章：深入Java单例模式 介绍设计模式很多，单例模式绝对是问的最多的一个了，也是让手写的最多的一个设计模式。很多人只会写双重检测的设计模式，但问的深一点其实很多人答不上来。比如，变量为什么要用volatile修饰，为什么要写2个if，一个if不行吗？还有就是单例模式有很多种写法。我以演进的方式写一个单例模式的5种写法，面试的时候建议写双重检测的写法和静态内部类的写法。 有一些对象其实我们只需要一个，比如说：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能看到一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者不一致的结果。 第一种（懒汉）//code1 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } }当2个线程同时进入getInstance()的if语句里面，会返回2个不同的实例，因此这种方式是线程不安全的 //code2 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} //同步方法 public static synchronized Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } }用所synchronized修饰可以保证线程安全，但是只有第一次执行此方法时才需要同步，设置好uniqueInstance，就不需要同步这个方法了，之后每次调用这个方法，同步都是一种累赘。 双重检查锁定（推荐）synchronized锁粒度太大，人们就想到通过双重检查锁定来降低同步的开销，下面是实例代码 //code3 public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ //同步代码块 synchronized(Singleton.class){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } } } return uniqueInstance; } }如上面的代码所示，如果第一次检查uniqueInstance不为null，那么就不需要执行下面的加锁和初始化操作，可以大幅降低synchronized带来的性能消耗，当在多线程环境下试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象，这就保证了只有一个实例的创建。 经常有人对code3中，为什么要执行2次if语句不太清楚，简答的描述一下，有可能有AB2个线程同时进入第一个if语句，然后A拿到锁，创建对象完成。因为B线程也判断了uniqueInstance为null,如果不再做一次判空处理的话，B拿到锁后会重新创建对象，但是加了第二个if语句后，就直接返回退出了。 双重检查锁定看起来似乎很完美，但这里一个错误的优化！在线程执行到getInstance()方法的第4行时，代码读取到uniqueInstance不为null，uniqueSingleton引用指向的对象有可能还没有完成初始化（半初始化）。 简单概述一下《Java并发编程的艺术》的解释， uniqueInstance = new Singleton()可以分解为如下三行代码： memory = allocate();//1：申请一块内存空间分配给对象 ctorInstance(memory);//2:调用构造方法初始化对象 uniqueInstance = memory;//3：设置uniqueInstance指向刚分配的内存地址3行伪代码中的2和3之间，可能会被重排序，重排序后执行的顺序如下 memory = allocate();//1：申请一块内存空间分配给对象 uniqueInstance = memory;//3：设置uniqueInstance指向刚分配的内存地址 //注意：此时对象还没有初始化 ctorInstance(memory);//2:调用构造方法初始化对象多个线程访问时可能出现如下的情况 时间 线程A 线程B 11 A1：分配对象的内存空间 12 A3：设置uniqueInstance指向的内存地址 13 B1：判断uniqueInstance是否为空 14 B2：由于uniqueInstance不为null，线程B访问uniqueInstance引用的对象 15 A2：初始化对象 16 A4：访问instance引用的对象 这样会导致线程B访问到一个还没有初始化的对象，此时可以用volatile修饰Singleton,这样3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止 //code4 public class Singleton { private volatile static Singleton uniqueSingleton; private Singleton(){} public static Singleton getInstance(){ if (uniqueSingleton == null){ synchronized(Singleton.class){ if (uniqueSingleton == null){ uniqueSingleton = new Singleton(); } } } return uniqueSingleton; } }第三种（饿汉）如果应用程序总是创建并使用单例模式，或者在创建和运行时方面的负担不太繁重，我们可以以饿汉式的方式来创建单例code5（静态常量） //code5 public class Singleton { private static final Singleton INSTANCE =new Singleton(); private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } }code6（静态代码块） //code6 public class Singleton { private static Singleton instance; private Singleton(){} static { uniqueSingleton = new Singleton(); } public static Singleton getInstance(){ return instance; } }在类加载的时候直接创建这个对象，这样既可以提高效率，又能保证线程安全，code5和code6几乎没有区别，因为静态成员变量和静态代码块都是类初始化的时候加载执行。 第四种静态内部类（推荐用）//code7 public class Singleton { private static class SingletonHolder{ private static final Singleton instance = new Singleton(); } private Singleton(){} public static Singleton getInstance(){ return SingletonHolder.instance ; } }饿汉式的方式只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading的效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示的通过调用getInstance()方法时，才会显示装载SingletonHolder类，从而实例化instance。 第五种枚举（推荐用）public enum Singleton { INSTANCE; public void whateverMethod() { } }枚举是公认实现单例的最好方式。借助JDK1.5中添加的枚举来实现的单例模式，不仅能避免多线程安全问题，而且还能防止反序列化和反射对单例的破坏问题。 总结不管采用何种方案，请记住使用单例的三大点： 线程安全 延迟加载 序列化和反序列化安全 本文链接：面试官：写一下单例模式吧，知道单例模式有几种写法吗欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：volatile关键字用过吧？说一下作用和实现吧","slug":"java-interview_0017","date":"2019-01-27T06:14:00.000Z","updated":"2019-12-31T05:28:45.441Z","comments":true,"path":"2019/01/27/java-interview_0017.html","link":"","permalink":"http://www.ergzcode.com/2019/01/27/java-interview_0017.html","excerpt":"极简计算机发展史我们知道，计算机的CPU和内存的交互是最频繁的，内存是我们的高速缓存区。而刚开始是用户磁盘和CPU进行交互，CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一矛盾，CPU厂商在每颗CPU上加上了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。 CPU&lt;-&gt;High Speed cache memory&lt;-&gt;Main memory physical menory","text":"极简计算机发展史我们知道，计算机的CPU和内存的交互是最频繁的，内存是我们的高速缓存区。而刚开始是用户磁盘和CPU进行交互，CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一矛盾，CPU厂商在每颗CPU上加上了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。 CPU&lt;-&gt;High Speed cache memory&lt;-&gt;Main memory physical menory 单核CPU的性能不可能无限制的增长，要想很多的提升性能，需要多个处理器协同工作，这就是多核处理器的由来。基于高速缓存的存储交互很好的解决了处理器和内存之间的矛盾。也引入了新的问题：缓存一致性的问题。在多核处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一个块内存（下文成主存，main memory主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要用这些协议来保证数据的一致性。 缓存一致性协议中最出名的就是Intel的MESI协议。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它的核心的思想是：当CPU写数据时，如果发生操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存设置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量是无效状态，那么它就会从内存中重新读取 Java内存模型Java的内存模型和上面的结构还是挺相似的，此时在看工作内存和主内存的关系，从逻辑上，高速缓存对应工作内存，每个线程分配到CPU时间片时，独自享有高速缓存的使用能力。主内存对应存储的物理内存，这只是逻辑上的对等关系，物理上的具体对应关系十分复杂，这里不讨论。 volatile的作用是什么volatile可以保证可见性，有序性，但不保证原子性： 可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值 假如说有2个线程对一个变量data进行操作，线程先会把主内存中的值缓存到工作内存，这样做的原因和上面提到的高速缓存类似，提高效率 但是这样会引入新的问题，假如说线程A把data的值修改为1，线程A的工作内存data的值为1，但是主内存和线程B的工作内存data值为0，此时就有可能出现Java并发编程中的可见性问题 举个例子，如下面代码，线程A已经将flag的值改变，但是线程B并没有及时感知到，导致一直进行死循环 public class Test{ public static boolean flag = false; public static void main(String[] args){ new Thread(()-&gt;{ while(!flag){ } System.out.println(&quot;threadB end&quot;); }).start(); try{ TimeUnit.SECONDS.sleep(1); }catch(InterruptedException e){ e.printstackTrace(); } new Thread(()-&gt;{ flag= =true; System.out.println(&quot;threadA end&quot;); }).start(); } }线程B一直没有结束,输出为: threadA end但是如果将data定义为如下形式，线程A对data的变更，线程B立马能感知到 public static volatile boolean flag = false;输出为: threadA end threadB end那么是如何实现的呢？其实volatile保证可见性的方式和上面提到的缓存一致性协议的原理很类似： 1.线程A将工作内存的data更改后，强制将data值刷回主内存2.如果线程B的工作内存中有data值变量的缓存，会强制让这个data变量缓存失效3.当线程B需要读取data变量的值时，先从工作内存中读，发现已经失效过期，就会从主内存中加载data变量的最新值了 放个图理解的更清楚 有序性 有序性即程序执行的顺序按照代码的先后顺序执行 int i = 0; boolean flag = false; i = 1;//语句1 flag = true;//语句2上面的代码定义了一个int型的变量，定义了一个boolean类型的变量，然后分别对这两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序的运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码的执行结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序运行结果并没有影响，那么就有可能在执行的过程中，语句2先执行而语句1后执行。 但是有依赖关系的语句不会进行重排序，如下面求圆面积的代码 double pi = 4.14;//A double r = 1.0;//B double area = pi * r * r;//C程序的执行顺序只有下面这2种形式 A-&gt;B-&gt;C和B-&gt;A-&gt;C，因为A和C之间存在依赖关系，同时B和C之间也存在依赖关系。因此最终执行的指令序列中C不能被重排序到A和B前面。 虽然重排序不会影响单个线程内程序的执行结果，但是多线程呢？下面看一个例子 //线程1 context = loadContext();//语句1 inited = true;//语句2 //线程2 while(!inited){ sleep(); } doSomethingwithconfig(context);上面的代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行的过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)的方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性 当写双重检测锁定版本（double check）的单例模式时，就要用到volatile关键来保证可见性 原子性 原子性即一个操作或多个操作，要么全部执行并且执行的过程中不会被任何因素打断，要么就都不会执行。 public class Test{ public static volatile int inc = 0; public static void main(String[] args){ //新建一个线程池 ExecutorService service = Executors.newCachedThreadPool(); for(int i = 0;i &lt; 5;i++){ service.execute(()-&gt;{ for(int j = 0;j &lt; 1000;j++){ inc++; } }); } //关闭线程池 service.shutdown(); try{ TimeUnit.SECONDS.sleep(1); }cacth(InterruptedException e){ e.printStackTrace(); } System.out.println(&quot;inc = &quot;+inc); } }执行上面的代码结果并不是每次都是5000，表明volatile并不能保证原子性 可能回有朋友就会有疑问，不对啊，上面是对变量Inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对Inc自增完之后，其他线程中都能看到修改后的值啊，所以有5个线程分别进行了1000次操作，那么最终Inc的值应该是1000*5=5000。 这里面就有一个误区了，volatile关键字能保证可见性是没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值，进行加1操作，写入工作内存。那么就是说自增操作的三个子操作可能会分割执行，就有可能导致下面这种情况出现： 加入某个时刻变量Inc的值为10，线程1对变量进行自增操作，线程1先读取变量Inc的原始值，然后线程1倍阻塞了；然后线程2对变量进行自增操作，线程2也去读取inc的原始值，由于线程1只是对变量进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存失效，也不会导致主内存中inc的值刷新，所以线程2会直接从工作内存中读取Inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值（inc++，包括3个操作，1.读取inc的值，2.进行加1操作，3.写入新的值），注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加1。 根源就在这里，自增操作不是原子操作，而且volatile关键字也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过使用AtomicInteger 应用前面已经演示过了 1.状态标记量 2.单例模式中的double check 总结volatile有两部分，一个是lock，禁止指令重排序，因为重排序会导致MESI的一致性协议失效；二是push,设置cache line失效。 本文链接：面试官：volatile关键字用过吧？说一下作用和实现吧欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下Spring StringBuffer StringBuilder的区别","slug":"java-interview_0003","date":"2019-01-26T14:23:00.000Z","updated":"2019-12-30T04:33:23.161Z","comments":true,"path":"2019/01/26/java-interview_0003.html","link":"","permalink":"http://www.ergzcode.com/2019/01/26/java-interview_0003.html","excerpt":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象","text":"介绍先来看String类的实现 public final class String implements java.io.serializable,Comparable&lt;String&gt;,CharSequence{ /** The value is used for character storage **/ private final char value[]; }先来说说final关键字的作用 final修饰类时，表明这个类不能被继承 final修饰方法时，表明方法不能被重写 final修饰变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 可以看到String类和保存变量的value数组都被final修饰，表明String类是不可变的。 StringBuffer和StringBuilder都继承自AbstractStringBuilder类，看一下AbstractStringBuilder类的定义 abstract class AbstractStringBuilder implements Appendable,CharSequence{ /** *The value is userd for character storage */ char[] value; }看到区别了吗？ value数组没有用private和final修饰，说明了StringBuffer和StringBuilder是可变的。 而StringBuilder和StringBuffer的方法是差不多的，只不过StringBuffer在方法上添加了synchronized关键字，所以在多线程环境下用StringBuffer来获得更高的效率。 看2个类中同一个方法的定义 StringBUffer类 //StringBuffer append方法 @Override public synchronized StringBuffer append(char[] str){ toStringCache = null; super.append(str); return this; }StringBuilder类 //StringBuilder append方法 @Override public StringBuilder append(char[] str){ super.append(str); return this; }因为StringBuffer和StringBulider的实现类似，所以性能比较就落在String和StringBuilder之间了。 1.String是不可变对象，每次操作都会生成新的String对象，然后指针指向新的对象。 2.抽象类AbstractStringBuilder内部提供了一个自动扩容机制，当发现长度不够的时候，会自动进行扩容工作（具体扩容可以看源码，很容易理解），会创建一个新的数组，并将原来数组的数据复制到新的数组，不会创建新的对象，所以拼接字符串的效率高。 用源码证实一下 String类 public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); }StringBuilder类 public StringBuilder append(String str) { super.append(str); return this; }介绍完毕，所以你应该知道这道题应该怎么答了 常见面试题1. 说一下String StringBuffer StringBuilder的区别 都是final类，不能被继承 String长度是不可变的，StringBuffer和StringBuilder长度是可变的 StringBuffer是线程安全的，StringBuilder不是线程安全的。但他们的方法很相似，StringBuffer在方法上添加了synchronized关键字修饰，保证了线程安全 StringBuilder比StringBuffer拥有更好的性能 如果一个String类型的字符串，在编译时可以确定是一个字符串常量，则编译完成后，字符串会自动拼接成一个常量，此时String比StringBuffer和StringBuilder的性能好的多 我用例子解释一下第五条 String a = &quot;a&quot;; String b = &quot;b&quot;; String c = a+b; String d = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;反编译class的文件是这样的 String a = &quot;a&quot;; String b = &quot;b&quot;; (new StringBuilder()).append(a).append(b).toString(); String d = &quot;abc&quot;;看到String d,理解了吗？ 同时看c的拼接过程，先生成一个StringBuilder对象，再调用2次append方法，最后再返回一个String对象，知道StringBuilder比String慢的愿意了吧。 本文链接：面试官：说一下Spring StringBuffer StringBuilder的区别欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下构造函数，静态代码块，构造代码块的加载顺序","slug":"java-interview_0002","date":"2019-01-25T03:00:00.000Z","updated":"2019-12-30T04:33:04.537Z","comments":true,"path":"2019/01/25/java-interview_0002.html","link":"","permalink":"http://www.ergzcode.com/2019/01/25/java-interview_0002.html","excerpt":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } }","text":"介绍构造函数，静态代码块，构造代码块的执行顺序 class Test{ //静态代码块1 static{ System.out.println(&quot;我的静态代码块1&quot;); } //构造代码块1 { System.out.println(&quot;我的构造代码块1&quot;); } //构造函数1 public Test(){ System.out.println(&quot;我是无参数构造函数&quot;); } //构造函数2 public Test(int t){ System.out.println(&quot;我是带参数构造函数，&quot;+&quot;参数是&quot;+t); } //静态代码块2 static{ System.out.println(&quot;我的静态代码块2&quot;); } //构造代码块2 { System.out.println(&quot;我的构造代码块2&quot;); } } 来New一个Test类看看会输出什么？ public class TestShow{ public static void main(String[] args){ /*创建第一个对象 我是静态代码块1 我的静态代码块2 我的构造代码块1 我的构造代码块2 我是无参数构造函数 */ System.out.println(&quot;创建第一个对象：&quot;); Test test1 = new Test(); /*创建第二个对象 我的构造代码块1 我的构造代码块2 我是带参数构造函数，参数是5 */ System.out.println(&quot;创建第二个对象：&quot;); Test test2 = new Test(5); } }从输出我们可以总结处如下结论： 执行时间：静态代码块 &gt; 构造代码块 &gt; 构造函数，静态代码块只会在类被加载入内存时加载一次，构造代码块和构造函数都是在对象创建的时候执行，有几个对象就会执行几次，所以一般将加载配置文件的过程写在静态代码块中。 没有继承的加载顺序 先定义一个类作为成员变量，方便看打印输出 public class Parameter { public Parameter(String str){ System.out.println(str); } }写一个测试类 public Test1{ public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); public Test1(){ System.out.println(&quot;构造函数&quot;); } //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } }输出如下 public class ForShow{ public static void main(String[] args){ /*静态成员变量 静态代码块 非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); /*非静态成员变量 构造代码块a 构造代码块b 构造函数 */ new Test1(); } }可以看出静态成员变量和静态代码块一样，只会在类被加载到内存时加载唯一的一次 改变一下Test类中定义的顺序，看看有什么变化。 public Test2{ //静态代码块 static{ System.out.println(&quot;静态代码块&quot;); } //构造函数 public Test2(){ System.out.println(&quot;构造函数&quot;); } //构造代码块b { System.out.println(&quot;构造代码块b&quot;); } //构造代码块a { System.out.println(&quot;构造代码块a&quot;); } public static Prarmeter parameter1 = new Parameter(&quot;静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;非静态成员变量&quot;); }输出如下 public class ForShow{ public static void main(String[] args){ /*静态代码块 静态成员变量 构造代码块b 构造代码块a 非静态成员变量 构造函数 */ new Test2(); } }没有继承情况的执行顺序 静态代码块和静态成员变量，加载的顺序由编写的顺序决定 构造代码块和非静态成员变量，加载顺序由编写顺序决定 构造函数 有继承情况的执行顺序 定义父类 public class Father{ public static Prarmeter parameter1 = new Parameter(&quot;父类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;父类非静态成员变量&quot;); public Father(){ System.out.println(&quot;父类构造函数&quot;); } }定义子类 public class Son extends Father{ public static Prarmeter parameter1 = new Parameter(&quot;子类静态成员变量&quot;); public Prarmeter parameter2 = new Parameter(&quot;子类非静态成员变量&quot;); public Son(){ System.out.println(&quot;子类构造函数&quot;); } }有继承情况的执行顺序 父类的静态（静态代码块，静态成员变量），子类的静态（静态代码块，静态成员变量） 父类的非静态（构造代码块，非静态成员变量），父类的构造函数 子类的非静态（构造代码块，非静态成员变量），子类的构造函数 记住这几条规则足以应付这一类型的所有面试题 常见的面试题1.Java类定义如下，写出main函数执行后的输出结果 public class A{ static { System.out.println(&quot;static A&quot;); } public A(){ System.out.println(&quot;class A&quot;); } } public class B extends A{ public B(){ System.out.println(&quot;class B&quot;); } public static void main(String[] args){ B instance = new B(); } }上面的知识点如果理解的很清楚的话，这个结果立马就能写出来 所以输出如下 static A class A class B2.问题是如果main函数中的代码如下呢？就是B这个类new了2次 public static void main(String[] args){ B instance1 = new B(); B instance2 = new B(); }万变不离其宗，输出如下 static A class A class B class A class B因为静态成员变量和静态代码块只会在类被载入内存时加载一次。 本文链接：面试官：说一下构造函数，静态代码块，构造代码块的加载顺序欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"面试官：说一下八种基本数据类型及其包装类吧","slug":"java-interview_0001","date":"2019-01-24T14:40:00.000Z","updated":"2019-12-31T03:10:21.457Z","comments":true,"path":"2019/01/24/java-interview_0001.html","link":"","permalink":"http://www.ergzcode.com/2019/01/24/java-interview_0001.html","excerpt":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character","text":"介绍Java基本数据类型分为4大类： 整数型：byte,short,int,long 浮点型：flost,double 逻辑型：boolean 字符型：char 原始类型 所占字节数 包装类 byte 1个字节 Byte short 2个字节 Short int 4个字节 Integer long 8个字节 Long float 4个字节 Float double 8个字节 Double boolean 1个字节 Boolean char 2个字节 Character 常见面试题要注意的是基本数据的包装类很多都实现了享元模式。享元模式就是运用共享技术有效地支持大量细粒度对象的复用。用一个常见的面试题来解释 1.判断如下代码的输出，并说出原因 Integer a1 = 40; Integer a2 = 40; System.out.println(a1==a2); Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);由自动装箱和拆箱可以知道这2种写法是等价的 Integer a1 = 40; Integer a1 = Integer.valueOf(40);看一下Integer.valueOf(int i)的方法 //...valueOf(int):Integer public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } //...IntegerCache private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }IntegerCache是Integer的静态内部类，默认创建了[-128,127]的对象，并放到IntegerCache内部的一个cache数组中，在[-128,127]这个范围内的整数对象，不用创建。直接从IntegerCache中的cache数组中根据下标拿就可以了,超出这个范围的每次去创建新的对象。其他几种包装类型的常量池和Integer的思路差不多，源码都很相似。所以答案如下： Integer a1 = 40; Integer a2 = 40; System.out.println(a1 == a2);//true Integer a3 = 200; Integer a4 = 200; System.out.println(a3 == a4);//false包装类缓存数据范围如下： 包装类 缓存范围 Byte -128~127 Short -128~127 Integer -128~127 Long -128~127 Character 0~127 2.Java一个char类型可以存储中文吗？ 可以，因为Java中使用了Unicode字符，不论是中文还是英文固定占用2个字节。 char a = &apos;中&apos;； // 中 System.out.println(a); 3.什么是自动装箱，自动拆箱 自动装箱就是Java自动将原始类型转换为对应的对象，比如将int的变量转换为Integer对象，这个过程就是装箱，反之将Integer对象转换为int类型的值，这个过程就是拆箱。因为这里的装箱和拆箱是自动进行的非人为转换的，所以就称作自动装箱和自动拆箱。 自动装箱时编译器调用ValueOf将原始类型值转换为对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换为原始类型值 //jdk1.5之前的写法 Integer tempNum1 = Integer.valueOf(5); int num1 = tempNum1.intValue(); //jdk1.5之后的写法，自动装箱和拆箱 Integer tempNum2= 5; int num1 = tempNum2;4.为什么要需要基本数据类型的包装类 （1）Java是面向对象的语言，很多地方是需要使用的是对象而不是基本数据类型。例如，List,Map等容器类中基本数据类型是放不进去的。（2）包装类在原先的基本数据类型上，新增加了很多方法，比如Integer.valueOf(String s)等 5.既然包装类能完成所有的功能，为啥还需要基本数据类型 基本数据类型基于数值，对象类型基于引用。基本数据类型存储在栈的局部变量表中。 而对象类型的变量则是存储堆中引用，实例放在堆中，因此对象类型的变量需要占用更多的内存空间，基本数据类型因为占用更少内存被保留下来。 6.写出如下代码的输出 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2); System.out.println(i1 == i2 + i3); System.out.println(i1 == i4); System.out.println(i4 == i5); System.out.println(i4 == i5 + i6); System.out.println(40 == i5 + i6);输出及解释如下 Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(i1 == i2);//true //Integer.valueOf()用了常量池，看上面的源码 //比较是内存地址 System.out.println(i1 == i2 + i3);//true // + 操作会导致左右两边都转换为基本数据类型 //比较是值 System.out.println(i1 == i4);//false //Integer.valueOf()使用常量池中的对象 //new Integer每次都会创建新对象 //比较是内存地址 System.out.println(i4 == i5);//false //new关键字会创建新的实例所以这是2个不同的对象 //比较是内存地址 System.out.println(i4 == i5 + i6);//true //解释在下面，比较的是值 System.out.println(40 == i5 + i6);//true //解释在下面，比较的是值语句i4 = i5 + i6,因为这个 + 操作符不适用于Integer对象，首先i5和i6进行了自动拆箱的操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int数据类型，值为40，最终这条语句转为40 == 40进行数值的比较。 本文链接：面试官：说一下八种基本数据类型及其包装类吧欢迎转载，请注明出处！","categories":[{"name":"搞定Java面试题","slug":"搞定Java面试题","permalink":"http://www.ergzcode.com/categories/%E6%90%9E%E5%AE%9AJava%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"},{"title":"MySQL数据库优化，看这篇就够了","slug":"mysql-database-optimization-this-article-is-enough","date":"2018-10-18T15:00:00.000Z","updated":"2019-12-20T05:27:26.199Z","comments":true,"path":"2018/10/18/mysql-database-optimization-this-article-is-enough.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/mysql-database-optimization-this-article-is-enough.html","excerpt":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图","text":"前言数据库优化一方面是找出系统的瓶颈,提高MySQL数据库的整体性能,而另一方面需要合理的结构设计和参数调整,以提高用户的相应速度,同时还要尽可能的节约系统资源,以便让系统提供更大的负荷. 1. 优化一览图 2. 优化笔者将优化分为了两大类,软优化和硬优化,软优化一般是操作数据库即可,而硬优化则是操作服务器硬件及参数设置. 2.1 软优化2.1.1 查询语句优化1.首先我们可以用EXPLAIN或DESCRIBE(简写:DESC)命令分析一条查询语句的执行信息.2.例:DESC SELECT * FROM user显示：其中会显示索引和查询数据读取数据条数等信息. 2.1.2 优化子查询在MySQL中,尽量使用JOIN来代替子查询.因为子查询需要嵌套查询,嵌套查询时会建立一张临时表,临时表的建立和删除都会有较大的系统开销,而连接查询不会创建临时表,因此效率比嵌套子查询高. 2.1.3 使用索引索引是提高数据库查询速度最重要的方法之一,关于索引可以参高笔者&lt;MySQL数据库索引&gt;一文,介绍比较详细,此处记录使用索引的三大注意事项: 1.LIKE关键字匹配’%’开头的字符串,不会使用索引. 2.OR关键字的两个字段必须都是用了索引,该查询才会使用索引. 3.使用多列索引必须满足最左匹配. 2.1.4 分解表对于字段较多的表,如果某些字段使用频率较低,此时应当,将其分离出来从而形成新的表, 2.1.5 中间表对于将大量连接查询的表可以创建中间表,从而减少在查询时造成的连接耗时. 2.1.6 增加冗余字段类似于创建中间表,增加冗余也是为了减少连接查询. 2.1.7 分析表,检查表,优化表分析表主要是分析表中关键字的分布,检查表主要是检查表中是否存在错误,优化表主要是消除删除或更新造成的表空间浪费. 一.分析表: 使用 ANALYZE 关键字,如ANALYZE TABLE user;1.Op:表示执行的操作.2.Msg_type:信息类型,有status,info,note,warning,error.3.Msg_text:显示信息. 二.检查表: 使用CHECK关键字,如CHECK TABLE user [option]option只对MyISAM有效,共五个参数值:1.QUICK:不扫描行,不检查错误的连接.2.FAST:只检查没有正确关闭的表.3.CHANGED:只检查上次检查后被更改的表和没被正确关闭的表.4.MEDIUM:扫描行,以验证被删除的连接是有效的,也可以计算各行关键字校验和.5.EXTENDED:最全面的的检查,对每行关键字全面查找. 三.优化表:使用OPTIMIZE关键字,如OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE user;LOCAL|NO_WRITE_TO_BINLOG都是表示不写入日志.,优化表只对VARCHAR,BLOB和TEXT有效,通过OPTIMIZE TABLE语句可以消除文件碎片,在执行过程中会加上只读锁. 2.2 硬优化2.2.1 硬件三件套1.配置多核心和频率高的cpu,多核心可以执行多个线程.2.配置大内存,提高内存,即可提高缓存区容量,因此能减少磁盘I/O时间,从而提高响应速度.3.配置高速磁盘或合理分布磁盘:高速磁盘提高I/O,分布磁盘能提高并行操作的能力. 2.2.2 优化数据库参数优化数据库参数可以提高资源利用率,从而提高MySQL服务器性能.MySQL服务的配置参数都在my.cnf或my.ini,下面列出性能影响较大的几个参数. 1.key_buffer_size:索引缓冲区大小2.table_cache:能同时打开表的个数3.query_cache_size和query_cache_type:前者是查询缓冲区大小,后者是前面参数的开关,0表示不使用缓冲区,1表示使用缓冲区,但可以在查询中使用4.SQL_NO_CACHE表示不要使用缓冲区,2表示在查询中明确指出使用缓冲区才用缓冲区,即SQL_CACHE.5.sort_buffer_size:排序缓冲区 传送门:更多参数 2.2.3 分库分表因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。另外一个，压力过大把你的数据库给搞挂了怎么办？所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这时作为主库承载写入请求。然后每个主库都挂载至少一个从库，由从库来承载读请求。 2.2.4 缓存集群 结语一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统和各种精妙的架构设计.因此一篇小文顶多具有抛砖引玉的效果,但是数据库优化的思想差不多就这些了. 原文链接:MySQL数据库优化欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.ergzcode.com/tags/Mysql/"}],"author":"ergz"},{"title":"Tomcat优化之修改内存配置","slug":"tomcat-modifying-memory-configuration-for-optimization","date":"2018-10-18T14:17:00.000Z","updated":"2019-12-18T15:43:54.028Z","comments":true,"path":"2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","link":"","permalink":"http://www.ergzcode.com/2018/10/18/tomcat-modifying-memory-configuration-for-optimization.html","excerpt":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明","text":"一、配置Tomcat/conf/server.xml修改配置 123456789&lt;connector port=\"8080\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" minSpareThreads=\"25\" maxSpareThreads=\"300\" maxThreads=\"500\" acceptCount=\"500\" connectionTimeout=\"30000\" enableLookups=\"false\"/&gt; 二、参数说明 maxIdleTime：最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms）； minSpareThreads：最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值4； maxSpareThreads：最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50； maxThreads：最大线程数，大并发请求时，tomcat能创建来处理请求的最大线程数，超过则放入请求队列中进行排队，默认值为200； acceptCount：当最大线程数（maxThreads）被使用完时，可以放入请求队列排队个数，超过这个数返回connection refused（请求被拒绝），一般设置和maxThreads一样，不过这个具体需要根据自己的应用实际访问峰值和平均值来权衡，默认值为100； connectionTimeout：网络连接超时，假设设置为0表示永不超时，这样设置隐患巨大，通常可设置为30000ms，默认60000ms； Windows Tomcat允许每个进程maxThreads（最大线程数）2000，Linux Tomcat允许每个进程maxThreads（最大线程数）1000 请看下面三种情况情况1：接受一个请求，此时tomcat起动的线程数没有到达maxThreads，tomcat会起动一个线程来处理此请求。 情况2：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，tomcat会把此请求放入等待队列，等待空闲线程。 情况3：接受一个请求，此时tomcat起动的线程数已经到达maxThreads，等待队列中的请求个数也达到了acceptCount，此时tomcat会直接拒绝此次请求，返回connection refused maxThreads如何配置一般的服务器操作都包括两方面：1计算（主要消耗cpu），2等待（io、数据库等）。 第一种极端情况，如果我们的操作是纯粹的计算，那么系统响应时间的主要限制就是cpu的运算能力，此时maxThreads应该尽量设的小，降低同一时间内争抢cpu的线程个数，可以提高计算效率，提高系统的整体处理能力。 第二种极端情况，如果我们的操作纯粹是IO或者数据库，那么响应时间的主要限制就变为等待外部资源，此时maxThreads应该尽量设的大，这样才能提高同时处理请求的个数，从而提高系统整体的处理能力。此情况下因为tomcat同时处理的请求量会比较大，所以需要关注一下tomcat的虚拟机内存设置和linux的open file限制。 我在测试时遇到一个问题，maxThreads我设置的比较大比如3000，当服务的线程数大到一定程度时，一般是2000出头，单次请求的响应时间就会急剧的增加，百思不得其解这是为什么，四处寻求答案无果，最后我总结的原因可能是cpu在线程切换时消耗的时间随着线程数量的增加越来越大，cpu把大多数时间都用来在这2000多个线程直接切换上了，当然cpu就没有时间来处理我们的程序了。以前一直简单的认为多线程=高效率。其实多线程本身并不能提高cpu效率，线程过多反而会降低cpu效率。当cpu核心数&lt;线程数时，cpu就需要在多个线程直接来回切换，以保证每个线程都会获得cpu时间，即通常我们说的并发执行。所以maxThreads的配置绝对不是越大越好。 现实应用中，我们的操作都会包含以上两种类型（计算、等待），所以maxThreads的配置并没有一个最优值，一定要根据具体情况来配置。最好的做法是：在不断测试的基础上，不断调整、优化，才能得到最合理的配置。acceptCount的配置，我一般是设置的跟maxThreads一样大，这个值应该是主要根据应用的访问峰值与平均值来权衡配置的。如果设的较小，可以保证接受的请求较快相应，但是超出的请求可能就直接被拒绝。如果设的较大，可能就会出现大量的请求超时的情况，因为我们系统的处理能力是一定的。 原文链接：Tomcat修改内存配置欢迎转载，请注明出处！","categories":[{"name":"web服务器","slug":"web服务器","permalink":"http://www.ergzcode.com/categories/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://www.ergzcode.com/tags/tomcat/"}],"author":"ergz"},{"title":"Maven之私服nexus","slug":"maven-nexus_01","date":"2016-05-24T11:03:00.000Z","updated":"2020-01-04T11:15:23.562Z","comments":true,"path":"2016/05/24/maven-nexus_01.html","link":"","permalink":"http://www.ergzcode.com/2016/05/24/maven-nexus_01.html","excerpt":"介绍Maven仓库分为本地仓库，远程仓库（私服），中央仓库，本文主要介绍了私服的使用。 将项目发布到私服首先要把代码上传到私服上，必须要能登录到私服上，在Maven的settings.xml文件，配置连接私服的用户和密码。","text":"介绍Maven仓库分为本地仓库，远程仓库（私服），中央仓库，本文主要介绍了私服的使用。 将项目发布到私服首先要把代码上传到私服上，必须要能登录到私服上，在Maven的settings.xml文件，配置连接私服的用户和密码。 1.在Maven配置文件settings.xml的域中添加以下代码： &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;releases 连接发布版本项目仓库snapshots 连接测试版本项目仓库 2.配置项目pom.xml配置私服仓库的地址，本公司的自己的jar包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt;注意：pom.xml这里和settings.xml配置对应！ 从私服下载jar包1.在setting.xml中配置仓库 &lt;!-- 下载jar包配置 --&gt; &lt;profile&gt; &lt;!--profile的id --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库id，repositories可以配置多个仓库，保证id不重复 --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即nexus仓库组的地址 --&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载releases构件 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载snapshots构件 --&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;使用profile定义仓库需要激活才可生效 &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt;这里的activeProfile必须与上方profile的id一致 安装第三方jar包到本地仓库这里将fastjson-1.1.37.jar上传到本地仓库，有2种方式：1.进入jar包所在目录运行 mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dfile=fastjson-1.1.37.jar -Dpackaging=jar2.打开cmd直接运行 mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=C:\\Users\\TOAJMER\\Desktop\\fastjson-1.1.37.jar安装第三方jar包到私服这里将fastjson-1.1.37.jar上传到私服，在settings配置文件中添加登录私服第三方登录信息： &lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;有2种方式：1.进入jar包所在目录运行 mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=fastjson-1.1.37.jar -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty2.打开cmd直接运行 mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=C:\\Users\\TOAJMER\\Desktop\\fastjson-1.1.37.jar -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty本文链接：Maven之私服nexus欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"author":"ergz"},{"title":"应届毕业生踏入社会需要注意的几点社会经验总结","slug":"a-few-social-experience-summary-for-fresh-graduates ","date":"2016-05-22T13:54:00.000Z","updated":"2020-01-03T16:04:50.184Z","comments":true,"path":"2016/05/22/a-few-social-experience-summary-for-fresh-graduates .html","link":"","permalink":"http://www.ergzcode.com/2016/05/22/a-few-social-experience-summary-for-fresh-graduates%20.html","excerpt":"一、经历比学历重要现在一些年轻人，大学毕业后便急着考研究生，以为学历越高便越有水平，便越好找工作。其实对多数人来说，考研究生是浪费时间，说不定学的越多越无能。 当代社会的工作，多数要不了那么多知识，大学毕业的水平就足够了。大学所学的知识，十分之一也用不到。还要考研究生，实在是浪费青春。除非你是想做科学研究工作，想当物理学家、数学家，那是一定要上研究生的。不然就没有必要。尤其是学文科专业，更是没有必要上研究生。","text":"一、经历比学历重要现在一些年轻人，大学毕业后便急着考研究生，以为学历越高便越有水平，便越好找工作。其实对多数人来说，考研究生是浪费时间，说不定学的越多越无能。 当代社会的工作，多数要不了那么多知识，大学毕业的水平就足够了。大学所学的知识，十分之一也用不到。还要考研究生，实在是浪费青春。除非你是想做科学研究工作，想当物理学家、数学家，那是一定要上研究生的。不然就没有必要。尤其是学文科专业，更是没有必要上研究生。 对于非科研工作，多数是要在工作中有针对性的学习的。在工作中实际可用的专业知识很少，多数是要在工作中根据实际需要学习。由于在工作中的学习是有目的的，是可应用的，学二个月胜过在学校学一年。成效非常明显。因此人要在工作中不断学习，而不是在学校学习。 有些人想上研究生，是因为对找工作没有信心，以为学历高了，就好找工作。其实如果有三年的实际工作经验，比上研究生可能更容易找工作。上研究生有两大缺点。本来学生最缺的是工作经验和社会经验，大学刚一毕业就上研究生，不会增加工作经验，更不能锻炼社会经验。本来就因为天天上学，显得傻乎乎，再上三年学，会变得更是傻乎乎。长期呆在校园，人会没有竞争意识，看什么都很难，看什么都不顺眼。研究生毕业了，更经不起社会的摔打和磨难，只想着能留校或是在一个稳稳当当的单位工作。意志被书本磨灭，一生都不可能有闯劲。 长期上学，人会变得清高自负，而实际工作能力很差。即使研究生毕业了，也可能缺少实际工作能力。人需要的是磨练，受苦，经历各种人生的磨难，才能真正理解人，适应社会。上研究生，则是在逃避社会，受不了委屈，受不了苦，不懂世故，干什么事都会碰壁，又不能圆通的解决。我带过很多新记者，发现一个现象，研究生不如本科生，本科生不如大专生。研究生采访不到的，专科生由于人生经验丰富，能屈能伸，随机应变，反而能采访到。 有三年的时间上研究生，不如三年换六个单位积累的人生经验多。每半年换一个单位，接触一批人，三年下来，会积累很多的社会经验和人脉关系。比上研究生收获大多了。人在三十岁之前，可以尽可能多的换单位，五六年下来，你将会成为全才，为三十岁以后的发展打下基础。 再说了，现在的学校里，没有几个有实际工作经验的老师，学不到真东西，无非是多读了几本书。用不上，也没有多少实际意义。 二、会说比会做重要现在的年轻人，一般都不懂世故，不会说话。有时一句话不慎，就可能毁掉自己一生，而自己还不知道原因。记得有一位年轻人，说了一句老同志能干的事情，我也能干。结果十年时间里，没有老同志愿带他工作，也没有独立工作的机会。有的年轻人，说话比较冲，在领导批评时，爱辩解，看起来维护了面子，但领导不喜欢这样的人，对他敬而远之。 会做的不如会说的。这就是现实。年轻人总相信有水平就一定能受领导重视，其不知任何领导用人的第一原则是听话和亲近。年轻人喜欢追求个性，好张扬，老同志看不惯，无形当中被当成了另类。人的一生，要么是动手，要么是动嘴。多数人注意培养动手能力，不注意培养动嘴能力。这是一大误区。多数做管理的人，都是靠一张嘴。会不会管理，其实就是看你会不会说话。能不能做成生意，也在于你会不会说话。 三、会笑比会说重要年轻人由于心理自卑，表现上喜欢装成熟，一般不爱笑，或是笑不出。最美丽的表情是微笑，比化装品重要。会笑的人，心情好，表情好，易被人接受。你去看周围的人，会笑的人可以左右逢源，容易做事。 四、做人比做事重要年轻人一般都比较愿意多做事，做大事，但往往忽视做人。有的人性格孤避，不爱结交朋友，不爱巴结领导，不爱说讨好人的话，遇事固执己见。做了很多事，却受不到大家肯定。有的人做事不多，能力不强，却见职务在上升。没有办法，不要看不惯，社会本来就是如此，柯责没有意义，也改变不了，反倒是要多反思自己。其实是自己不会做人。 五、做早比做好重要*拒绝拖延症，想到什么就立即实施。关于oracle方面想要学习到更多必然要去一些有用的网站看看，比如IT PUB, CSDN, Chinaunix, 思庄、中国IT、CNOUG等等。 六、听话比说话重要七、心态比成绩重要有的人是一个积极的心态，乐观的心态，不管遇到什么困难、委屈，仍然会积极进取。有的人，稍吃一点亏便难以承受。有的人有了一点成绩，便要翅尾巴，结果引来嫉妒。心态决定人的一生，应当好好修练。 八、性格比水平重要多数人干不了大事，不是由于水平问题，而是性格问题。在中国的企业家当中，有一半是从部队转业的。这些人本来专业技能并不算高，为何却能做大事呢。主要是在部队经过了严格的组织纪律性训练，养成了良好的生活和工作习惯，坚韧不拔，善于协作，敢担责任，敢冒风险。而学生出身的人，多作风散慢，性格懦弱，反而干不了什么大事。 九、今天比明天重要先把今天的事做好，比构想明天的事更有意义。 来源：CSDN社区推荐欢迎转载，请注明出处！","categories":[{"name":"生活职场","slug":"生活职场","permalink":"http://www.ergzcode.com/categories/%E7%94%9F%E6%B4%BB%E8%81%8C%E5%9C%BA/"}],"tags":[],"author":"ergz"},{"title":"深入Java单例模式","slug":"design-pattern-for-singleton","date":"2016-05-22T09:11:00.000Z","updated":"2020-01-04T09:10:39.697Z","comments":true,"path":"2016/05/22/design-pattern-for-singleton.html","link":"","permalink":"http://www.ergzcode.com/2016/05/22/design-pattern-for-singleton.html","excerpt":"前言这是关于单例，我看过的，真的写的最好的一篇博文。非常的详尽，并且有浅及深 在GoF的23种设计模式中，单例模式是比较简单的一种。然而有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用生命周期中保证只有一个实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。","text":"前言这是关于单例，我看过的，真的写的最好的一篇博文。非常的详尽，并且有浅及深 在GoF的23种设计模式中，单例模式是比较简单的一种。然而有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。 所谓单例模式，简单来说，就是在整个应用生命周期中保证只有一个实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 1. 最简单的实现首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给调用者。这样，调用者就可以通过这个引用使用到这个类的实例了。 public class SingletonClass { private static final SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() { return instance; } private SingletonClass() { } }如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 2. 性能优化——lazy loaded上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？为了解决这个问题，我们想到了新的解决方案： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } } 代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。 我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。 3. 同步上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下： 线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！ 解决的方法也很简单，那就是加锁： public class SingletonClass { private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() { if(instance == null) { instance = new SingletonClass(); } return instance; } private SingletonClass() { } }是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。 4. 又是性能上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码： public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } return instance; } private SingletonClass() { } }首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？ public class SingletonClass { private static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if (instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } }还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。 这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。 5. 从源头检查下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。 要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。 下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存空间，然后把指针指向这块内存，最后调用构造方法进行初始化。 下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存空间，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就使用了这个实例，程序就会出现错误了！ 6. 解决方案说了这么多，难道单例没有办法在Java中实现吗？其实不然！在JDK5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。 public class SingletonClass { private volatile static SingletonClass instance = null; public static SingletonClass getInstance() { if (instance == null) { synchronized (SingletonClass.class) { if(instance == null) { instance = new SingletonClass(); } } } return instance; } private SingletonClass() { } }然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响： public class SingletonClass { private static class SingletonClassInstance { private static final SingletonClass instance = new SingletonClass(); } public static SingletonClass getInstance() { return SingletonClassInstance.instance; } private SingletonClass() { } }在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。 由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是非并发的，所以getInstance()也并不需要加同步。 至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。 本文链接：深入Java单例模式欢迎转载，请注明出处！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ergzcode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.ergzcode.com/tags/DesignPattern/"}],"author":"ergz"},{"title":"MarkdownPad2.5注册码","slug":"markdownpad2.5-license-key","date":"2016-05-15T07:25:00.000Z","updated":"2019-12-29T09:19:06.130Z","comments":true,"path":"2016/05/15/markdownpad2.5-license-key.html","link":"","permalink":"http://www.ergzcode.com/2016/05/15/markdownpad2.5-license-key.html","excerpt":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==","text":"邮箱 Soar360@live.com 注册码GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 输入Email address和license key 注册完成 本文链接：MarkdownPad2.5注册码欢迎转载，请注明出处！","categories":[{"name":"工具","slug":"工具","permalink":"http://www.ergzcode.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://www.ergzcode.com/tags/markdown/"}],"author":"ergz"},{"title":"阅读生活之人生赢家","slug":"read-lifes_01","date":"2016-01-04T14:05:00.000Z","updated":"2020-01-03T16:59:40.020Z","comments":true,"path":"2016/01/04/read-lifes_01.html","link":"","permalink":"http://www.ergzcode.com/2016/01/04/read-lifes_01.html","excerpt":"1、给你90天，成为不一样的自己 如果你想成功，从现在起和比自己成功的人去接触，别人的成功不是没有道理的；如果你想得到某个领域的经验，那就跨出你自己的领域去认识这个领域的人，任何方式都可以；如果你碍于面子，跨不出现有的圈子你就一直会在原地踏步；放下面子，放下偏见，放下自卑，重新认识你身边的人 2、吵架公约：把最后一句话留给对方说 不论我们正在遭遇何种困局或是挣扎，所谓的吵架如果不能避免，那最后那一句话也要留给对方说，适可而止也是人生的一种高境界，能够成全自己的幸福人生。","text":"1、给你90天，成为不一样的自己 如果你想成功，从现在起和比自己成功的人去接触，别人的成功不是没有道理的；如果你想得到某个领域的经验，那就跨出你自己的领域去认识这个领域的人，任何方式都可以；如果你碍于面子，跨不出现有的圈子你就一直会在原地踏步；放下面子，放下偏见，放下自卑，重新认识你身边的人 2、吵架公约：把最后一句话留给对方说 不论我们正在遭遇何种困局或是挣扎，所谓的吵架如果不能避免，那最后那一句话也要留给对方说，适可而止也是人生的一种高境界，能够成全自己的幸福人生。 3、做事要找靠谱的人，聪明的人只能聊聊天 这些年体会最深的是，一个靠谱的人给你介绍的朋友，合作起来就是人品好，办事靠谱的人。而一个不靠谱的人给你介绍一个朋友或者一个同事，也能碰到靠谱的，但需要你有慧眼，否则就只能碰运气。我们做事选择靠谱，是选择一种优秀的品质。一旦你靠谱的对待事情，你可能暂时受到伤害。 4、如何在这操蛋的世界里保持快乐？ 恩，本质上，快乐的技术就是烂俗的。海明威不是说了嘛，心理健康有时候就意味着庸俗。爱你所拥有的。珍惜你所拥有的。快乐不等于傻逼。我们深知世界的复杂、黑暗和荒谬，依然选择面对复杂，保持欢喜。 5、那些不声不响就把事情做了的人 你何时才能做一个不动声色的大人，取决于你拥有一颗怎样的心。树欲静则风止，这才是不动声色的境界。继续修炼吧！少年。 6、为什么以前对你好的同学现在都不理你了？ 我们不要指望别人有义务拉你一把。人家又不是你爹你妈，凭什么要惯着你啊。这个世界就是马太效应。你越牛逼，机会越多。没有什么雪中送炭，这个世界只有锦上添花。你想要锦上添花，你得先变成锦。 7、向这些教育方式说不 爱孩子要爱得其法，孩子，不仅给了我们生命最本质的活力和喜悦，也给我们一个契机，重新审视生活，自省个人的言行。带孩子，是一条和孩子共同修行的路，我们不是领他们成长，而是和他们相伴，一起成长。 8、朋友升官发财，你不必难过 所以，不必看到别人手里拿着利剑而万分焦虑，很可能你的怀里揣着枪呢。在被打得落花流水的时候想一想，你是不是比错了项目，好好摸摸自己的口袋，找到那个最让你自信的、最多人为你点赞的、最常带给你优越感的能力，那就是你的武器，掏出它来，到属于你的战场战斗吧。 9、不要一直在自己身上找原因 和人划清界限，知道哪些责任是自己的，哪些东西根本和自己无关是非常重要的。一个没有界限感的人，即便是怀着好心，最终也很有可能酿成大错。“一日三省吾身”是好，但这个“省身”也应该包括检查自己有没有过分承担。换句话说，你若一直在自己身上找原因，也是你太高估自己了。 10、听懂另一半说爱你的方式 而我也慢慢学会，不再用自己表达爱的方式去绑架他，他也和我一样，而是渐渐懂得他表达爱和责任的方式，然后默默记在日记本里，记在心里… … 11、你不是不会爱，而是怕麻烦 坚持本来就是一件极其不易的事情，即便我们能够一辈子做自己的太阳，光芒偶尔也会被雾霾遮挡，但心中有爱的人终究不会迷途，因为从未曾忘记一路上予人玫瑰，手留余香又会还你满满的正能量。 12、你永远不可能靠点赞融入那个不属于你的圈子 其次时间宝贵，年纪越大越不想徒劳消耗，有这个时间还不如去想想怎么挣钱，或者消耗在自己真心喜欢的人和事上。最后很残酷的一点，如果你自己没资本，社交也并不能给你带来什么你需要的人脉或真心的朋友。“没有平起平坐的资本，任何社交都无法换来有用的人脉。”所以不用硬融，你到了那种阶段，你会很自然被你喜欢的那群人吸纳进去。 13、等人把话说完，是一种修养 等别人把话说完是一种素质，看似絮絮叨叨的表达，身前身后却是气象万千的智慧和懂得。听别人说话，其实在渡你我到彼岸，一回头已是郁郁葱葱，繁花似锦。 14、好与不好都走了，幸与不幸都过了 有时候，珍惜，是为了更好的拥有；而放下，则是为了更好的前行。好与不好都走了，幸与不幸都过了。人生的际遇，就像那窗外的雨，淋过，湿过；散了，远了。容不得我们许与不许，便已然不再。于是，人生，便总是从告别中走向明天。将美好留于心底，淡淡的就好；将悲伤置于脑后，遗忘了最好。 15、为什么很多人工资不高，却还要拥挤在大城市生活？ 演出场地也是很多城市的标配，但是扪心自问，你一年内会在小城市看几场演出？体验是由物质和精神两个层面叠加起来的，即便配套跟一线城市完全没有区别，但生活在这个地方的人群跟你不同道，你也无法习惯。 16、岁月美人都是养出来的 天生丽质的女子凤毛麟角，绝大多数的美人儿都是后天养出来的，而且绝对要富养，经济条件的好坏并不能决定你的颜值，但精神世界的高低，却能让岁月美人从众多莺莺燕燕中脱颖而出，在水一方窈窈窕窕，孤不孤单都是一种最精彩。美人需要很多爱的供养，很多自律的修炼，很多快乐的分享，很多生活的勇气，很多纯真的执着，所以我们要一起上路，任重道远也要彼此共勉，成就做一位岁月美人的终极梦想。 17、林清玄：死在路上也是很好的事，总比没去过好 因此，我们对生命如果还有未完成的期盼，此刻就要去融入它，不要寄希望于渺茫的来生，活在一个又一个的片刻里，到死前都保有向前的姿势，只要完全融入一个纯粹天真的片刻，那也就够了。有很多人活在过去与未来的交错、预期、烦恼之中，从来没有进入过那个片刻呢！ 18、没人稀罕你做自己 中国人讲究含蓄，西方人讲究距离，没人稀罕你做自己。还不如回家照照镜子，看看对着那张熟悉的放肆面容能不能和平相处，再考虑其他。至于真正的自己，回到斗室中再做也不迟。毕竟，能容忍自己的只有自己，能原谅自己的也只有自己。 19、他没有用你理想的方式爱你，也很好 在非原则性的问题上，降低期望值，不较真儿，不偏执，懂得尊重与退让，愿意为爱妥协，才能爱得更轻松、更愉快。要相信，即使他没有用你理想的方式爱你，但只要真心依旧，其实也很好。 20、你不快乐，是因为活得不宽容 哪怕我们身边的世界再复杂再艰难，也要好好保护你内心的宽容与温柔，愿你能遇见未知的那个美好的自己，在此之前你先要对别人宽容，愿你被世界温柔相待，在此之前你先要温柔相待这个世界。生活从不会辜负那些快乐又美好的人生，你若宽容温柔，不必算计争抢，自有命运打赏。 来源：阅读时间欢迎转载，请注明出处！","categories":[{"name":"生活职场","slug":"生活职场","permalink":"http://www.ergzcode.com/categories/%E7%94%9F%E6%B4%BB%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.ergzcode.com/tags/%E7%94%9F%E6%B4%BB/"}],"author":"ergz"},{"title":"关于mysql查询缓存详解","slug":"mysql-query-cache_01","date":"2016-01-01T14:48:00.000Z","updated":"2020-01-03T17:11:23.656Z","comments":true,"path":"2016/01/01/mysql-query-cache_01.html","link":"","permalink":"http://www.ergzcode.com/2016/01/01/mysql-query-cache_01.html","excerpt":"mysql查询缓存 在sql调优的过程中，发现原本很慢的一条sql（将近1分钟）在第二次运行时，瞬间就完成了（0.04sec）。 这是因为mysql自带的缓存机制，将查询结果进行缓存，如果table数据未发生变化，再次使用同一条sql进行查询时，直接从上次的查询结果缓存中读取数据，而不是重新分析、执行sql。 如果table数据发生变化，所有与之相关的缓存数据都会被释放刷新，这样就不会出现数据脏读问题。","text":"mysql查询缓存 在sql调优的过程中，发现原本很慢的一条sql（将近1分钟）在第二次运行时，瞬间就完成了（0.04sec）。 这是因为mysql自带的缓存机制，将查询结果进行缓存，如果table数据未发生变化，再次使用同一条sql进行查询时，直接从上次的查询结果缓存中读取数据，而不是重新分析、执行sql。 如果table数据发生变化，所有与之相关的缓存数据都会被释放刷新，这样就不会出现数据脏读问题。 The query cache stores the text of a SELECT statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client. 是否使用查询缓存 为了避免缓存，可以在sql查询语句的字段前增加SQL_NO_CACHE关键字，如： 1select * from t_user; 1select SQL_NO_CACHE * from t_user; 反之，你也可以使用SQL_CACHE关键字，强制mysql从缓存中读取数据，如： 1select SQL_CACHE * from t_user; mysql还提供了一种释放全部缓存的方法: 1reset query cache; 设置查询缓存 查看是否有查询缓存： 1SHOW VARIABLES LIKE 'have_query_cache'; 注意，只要数据库拥有查询缓存功能，这个VALUE就是YES，无论查询缓存是否启用，mysql默认为启用状态。mysql查询缓存可以通过两个变量来控制：query_cache_type和query_cache_size。 querycachetype 1SHOW VARIABLES LIKE 'query_cache_type'; query_cache_type包含三种状态： 0 or OFF 此时不会从缓存中读取查询数据。 1 or ON 表示除非声明了SELECT SQL_NO_CACHE，否则都会从缓存中读取数据。 2 or DEMAND 表示所有语句都会从缓存中读取，相当于所有查询语句都使用了SELECT SQL_CACHE。 通过如下命令可以设置查询缓存状态(需要管理员权限)，执行后，需要重启mysql服务才能生效。 1SET GLOBAL query_cache_type = 1; 但是此命令会影响所有的使用此mysql服务的client。可以通过如下命令，关闭此客户端的查询缓存状态，但是同样需要重启server后才能生效。 12SET SESSION query_cache_type = OFF; SHOW VARIABLES LIKE 'query_cache_type'; querycachesize 1SHOW VARIABLES LIKE 'query_cache_size'; querycachesize表示缓存大小，默认为1M。如果设置为0，则相当于:query_cache_type=OFF，同样可通过SET GLOBAL进行设置。 SET GLOBAL query_cache_size=40000; 需要注意的是，设置的querycachesize，并不全是用于存储数据，还有约40KB的空间来维护查询缓存的结构。 本文链接：关于mysql查询缓存详解欢迎转载，请注明出处！","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.ergzcode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.ergzcode.com/tags/Mysql/"}],"author":"ergz"},{"title":"Hibernate查询Jackson序列化懒加载问题","slug":"jackson-hibernateLazyInitializer_01","date":"2015-05-26T05:51:00.000Z","updated":"2019-12-31T08:16:58.226Z","comments":true,"path":"2015/05/26/jackson-hibernateLazyInitializer_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/26/jackson-hibernateLazyInitializer_01.html","excerpt":"在Hibernate查询出数据实体类使用jackson序列化为json时,出现下面错误： org.springframework.http.converter.HttpMessageNotWritableException... ... disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS引起以上问题的主要原因就是jackson把懒加载也作为pojo进行序列化了。一般解决方法：在实体类上加上 @JsonIgnoreProperties({&quot;hibernateLazyInitializer&quot;, &quot;handler&quot;})","text":"在Hibernate查询出数据实体类使用jackson序列化为json时,出现下面错误： org.springframework.http.converter.HttpMessageNotWritableException... ... disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS引起以上问题的主要原因就是jackson把懒加载也作为pojo进行序列化了。一般解决方法：在实体类上加上 @JsonIgnoreProperties({&quot;hibernateLazyInitializer&quot;, &quot;handler&quot;}) 如果实体类中有集合属性那么将类里面所有的集合都加入到@JsonIgnoreProperties 这个方法注解是放在类定义上面的,例如:@JsonIgnorePropertiesclass A{} 如果你定义的类是这样的: class A{ private String description; private Boolean enable; private Integer createUser; private Date createTime; private Integer updateUser; private Date updateTime; private Set operations = new HashSet(0); private Set roles = new HashSet(0); private Set menus = new HashSet(0); }则把下面这句话加到类上 @JsonIgnoreProperties(value={“hibernateLazyInitializer”,”handler”,”operations”,”roles”,”menus”})注意：其中hibernateLazyInitializer，handler必须添加！ 本文链接：Hibernate查询Jackson序列化懒加载问题欢迎转载，请注明出处！","categories":[{"name":"Json","slug":"Json","permalink":"http://www.ergzcode.com/categories/Json/"}],"tags":[{"name":"jackson","slug":"jackson","permalink":"http://www.ergzcode.com/tags/jackson/"}],"author":"ergz"},{"title":"JSP中basePath作用","slug":"jsp-basePath_01","date":"2015-05-19T08:11:00.000Z","updated":"2019-12-31T08:18:11.738Z","comments":true,"path":"2015/05/19/jsp-basePath_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/19/jsp-basePath_01.html","excerpt":"","text":"通常在JSP页面中有如下代码： 1234&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\"; %&gt; 这段代码的意思是获取当前项目的路径，如：http://localhost:8080/项目名称。 在中通常有如下代码： 1&lt;base href=\"&lt;%=basePath%&gt;\"&gt; 这是设置基础路径的，basePath为变量，简单的静态网页的话你设置比如：&lt;base href=&quot;http://www.baidu.com&quot;&gt;，那你下面的href属性就会以你上面设置的值的为基准，如：&lt;a href=&quot;http://www.baidu.com/xxx.htm&quot;&gt;&lt;/a&gt;你现在就只需要写&lt;a href=&quot;xxx.htm&quot;&gt;&lt;/a&gt; 原文链接：http://lzc0088.iteye.com/blog/504015欢迎转载，请注明出处！","categories":[{"name":"前端","slug":"前端","permalink":"http://www.ergzcode.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Jsp","slug":"Jsp","permalink":"http://www.ergzcode.com/tags/Jsp/"}],"author":"ergz"},{"title":"Java备份和还原MySQL数据库","slug":"java-backup-and-recover-mysql_01","date":"2015-05-16T02:11:00.000Z","updated":"2020-01-01T02:15:21.830Z","comments":true,"path":"2015/05/16/java-backup-and-recover-mysql_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/16/java-backup-and-recover-mysql_01.html","excerpt":"使用Java代码备份和还原MySQL数据库","text":"使用Java代码备份和还原MySQL数据库 备份12345678910111213141516171819202122public static void backup(String path) throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(\"mysqldump -u root -p123456 db\"); InputStream inputStream = process.getInputStream(); InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader br = new BufferedReader(reader); String s = null; StringBuffer sb = new StringBuffer(); while ((s = br.readLine()) != null) &#123; sb.append(s + \"\\r\\n\"); &#125; s = sb.toString(); System.out.println(s); File file = new File(path); file.getParentFile().mkdirs(); FileOutputStream fileOutputStream = new FileOutputStream(file); fileOutputStream.write(s.getBytes()); fileOutputStream.close(); br.close(); reader.close(); inputStream.close(); &#125; 还原12345678910111213141516171819public static void recover(String path) throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(\"mysql -u root -p123456 --default-character-set=utf8 db\"); OutputStream outputStream = process.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(path))); String str = null; StringBuffer sb = new StringBuffer(); while ((str = br.readLine()) != null) &#123; sb.append(str + \"\\r\\n\"); &#125; str = sb.toString(); System.out.println(str); OutputStreamWriter writer = new OutputStreamWriter(outputStream, \"utf-8\"); writer.write(str); writer.flush(); outputStream.close(); br.close(); writer.close(); &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"}],"author":"ergz"},{"title":"Java中的this关键字","slug":"java-this_01","date":"2015-05-08T11:04:00.000Z","updated":"2020-01-01T02:46:10.626Z","comments":true,"path":"2015/05/08/java-this_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/08/java-this_01.html","excerpt":"","text":"主要有三点： 1.使用this调用本类的属性(this.xx) 2.使用this调用构造方法(this(),this(xx)) 3.表示当前对象的引用(谁调用就代表谁)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"}],"author":"ergz"},{"title":"Java中的final关键字","slug":"java-final_01","date":"2015-05-07T07:55:00.000Z","updated":"2019-12-31T11:10:40.509Z","comments":true,"path":"2015/05/07/java-final_01.html","link":"","permalink":"http://www.ergzcode.com/2015/05/07/java-final_01.html","excerpt":"介绍Java中的final关键字非常重要，它可以应用于类、方法以及变量。这篇文章中我将带你看看什么是final关键字？将变量，方法和类声明为final代表了什么？使用final的好处是什么？最后也有一些使用final关键字的实例。final经常和static一起使用来声明常量，你也会看到final是如何改善应用性能的。 final关键字的含义?final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。","text":"介绍Java中的final关键字非常重要，它可以应用于类、方法以及变量。这篇文章中我将带你看看什么是final关键字？将变量，方法和类声明为final代表了什么？使用final的好处是什么？最后也有一些使用final关键字的实例。final经常和static一起使用来声明常量，你也会看到final是如何改善应用性能的。 final关键字的含义?final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。 什么是final变量？凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。下面是final变量的例子： public static final String LOAN = &quot;loan&quot;; LOAN = new String(&quot;loan&quot;) //invalid compilation errorfinal变量是只读的。 什么是final方法?final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。下面是final方法的例子： class PersonalLoan{ public final String getName(){ return &quot;personal loan&quot;; } } class CheapPersonalLoan extends PersonalLoan{ @Override public final String getName(){ //compilation error: overridden method is final return &quot;cheap personal loan&quot;; } }什么是final类？使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。下面是final类的实例： final class PersonalLoan{ } //compilation error: cannot inherit from final class class CheapPersonalLoan extends PersonalLoan{ }final关键字的好处下面总结了一些使用final关键字的好处 final关键字提高了性能。JVM和Java应用都会缓存final变量 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销 使用final关键字，JVM会对方法、变量及类进行优化 不可变类创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。 关于final的重要知识点 final关键字可以用于成员变量、本地变量（局部变量）、方法以及类 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误 不能够对final变量再次赋值 局部变量必须在声明时赋值 在匿名类中使用的所有外部变量都必须是final变量（*） final方法不能被重写 final类不能被继承 final关键字不同于finally关键字，后者用于异常处理 final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法 接口中声明的所有变量本身是final的（*） final和abstract这两个关键字是反相关的，final类就不可能是abstract的 final方法在编译阶段绑定，称为静态绑定(static binding) 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化” 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化 按照Java代码惯例，final变量就是常量，而且通常常量名要大写： private final int COUNT = 10; 对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容，譬如： private final List Loans = new ArrayList(); list.add(“home loan”); //valid list.add(“personal loan”); //valid loans = new Vector(); //not valid 我们已经知道final变量、final方法以及final类是什么了。必要的时候使用final，能写出更快、更好的代码的。 本文链接：Java中的final关键字欢迎转载，请注明出处！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.ergzcode.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.ergzcode.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.ergzcode.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"ergz"}]}